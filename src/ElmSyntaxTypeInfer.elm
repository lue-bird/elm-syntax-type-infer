module ElmSyntaxTypeInfer exposing
    ( valueAndFunctionDeclarations
    , ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
    , ModuleOriginLookup, importsToModuleOriginLookup
    , TypedNode, Expression(..), LetDeclaration(..), Pattern(..), Base10Or16(..)
    , Type(..), TypeNotVariable(..)
    )

{-| Add type information to the nodes
of an [elm-syntax](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/) tree.

@docs valueAndFunctionDeclarations

## context

@docs ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
@docs ModuleOriginLookup, importsToModuleOriginLookup


## syntax

@docs TypedNode, Expression, LetDeclaration, Pattern, Base10Or16
@docs Type, TypeNotVariable

If you are interested in exposing helpers like `expressionMapType`,
[open an issue](https://github.com/lue-bird/elm-syntax-type-infer/issues/new)

-}

import Elm.Docs
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.Import
import Elm.Syntax.ModuleName
import Elm.Syntax.Node
import Elm.Syntax.Pattern
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import Elm.Type
import FastDict


{-| Known types of members in a module.
Create with [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)
-}
type alias ModuleTypes =
    { signatures :
        -- value, function, port
        FastDict.Dict String (Type String)
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : Type String
            , recordFieldOrder : Maybe (List String)
            }
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List (Type String))
            }
    }


{-| [`ModuleTypes`](#ModuleTypes) exposed in `elm/core`.

Please _always_ start with [`elmCoreTypes`](#elmCoreTypes)
and add further module info with [`FastDict.union`](https://dark.elm.dmy.fr/packages/miniBill/elm-fast-dict/latest/FastDict#union)
using [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

And if for some reason you already know used dependencies at compile time,
you can re-use the [code generator used for these elm/core types](https://github.com/lue-bird/elm-syntax-type-infer/tree/main/codegen)

-}
elmCoreTypes :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypes =
    elmCoreTypesGeneratedFromDocsJson


{-| When syntax _introduces_ type variables from another "context" (another (let) declaration, another branch, another element, ...)
we need to differentiate these from variables in the current "context"

For example,

    ( 0, 1 )
    -- ( number, number )
    ( identity, List.map identity )
    -- ( a -> a, List a -> List a )

would be incorrect inferences because
the `number` in `0` and `1` or `a` in `identity` and `List.map` are not related
and can be different types.
So in practice these are

    ( 0, 1 )
    -- ( ( { ... 3 }, "number" ), ( { ... 6 }, "number" ) )

    ( identity, List.map identity )
    -- ( ( { ... 3 }, "a" ) -> ( { ... 3 }, "a" )
    -- , List ( { ... 15 }, "a" ) -> List ( { ... 15 }, "a" )
    -- )

Here { ... 3 } refers to the use range with n as the start column.


This system of tracking origin ranges by itself is arguably
worse than a simple ast path or similar
but it has the unique advantage that it allows us to quickly
find out which let value/function type variable
is "forall" (as in: should be instantiated on use) or not
by checking whether its range extends to outside the let declaration body.
There might be some other way to track this but I couldn't think of one.

Performance note: `TypeVariableFromContext` is a tuple to allow for internal use as a dict key.
See also `RangeAsComparable`

-}
type alias TypeVariableFromContext =
    ( -- combined Range from all uses
      RangeAsComparable
    , String
    )


type TypeVariableConstraint
    = TypeVariableConstraintNumber
    | TypeVariableConstraintAppendable
    | TypeVariableConstraintComparable
    | TypeVariableConstraintCompappend


typeVariableIgnoringContext : TypeVariableFromContext -> String
typeVariableIgnoringContext ( _, name ) =
    name


typeVariableConstraint : String -> Maybe TypeVariableConstraint
typeVariableConstraint variableName =
    if variableName |> String.startsWith "number" then
        justTypeVariableConstraintNumber

    else
        -- small optimization because they are all equal in length
        case variableName |> String.slice 0 10 of
            "appendable" ->
                justTypeVariableConstraintAppendable

            "comparable" ->
                justTypeVariableConstraintComparable

            "compappend" ->
                justTypeVariableConstraintCompappend

            _ ->
                Nothing


justTypeVariableConstraintCompappend : Maybe TypeVariableConstraint
justTypeVariableConstraintCompappend =
    Just TypeVariableConstraintCompappend


justTypeVariableConstraintComparable : Maybe TypeVariableConstraint
justTypeVariableConstraintComparable =
    Just TypeVariableConstraintComparable


justTypeVariableConstraintAppendable : Maybe TypeVariableConstraint
justTypeVariableConstraintAppendable =
    Just TypeVariableConstraintAppendable


justTypeVariableConstraintNumber : Maybe TypeVariableConstraint
justTypeVariableConstraintNumber =
    Just TypeVariableConstraintNumber


maybeTypeVariableConstraintMerge : Maybe TypeVariableConstraint -> Maybe TypeVariableConstraint -> Result String (Maybe TypeVariableConstraint)
maybeTypeVariableConstraintMerge a b =
    case a of
        Nothing ->
            Ok b

        Just aConstraint ->
            case b of
                Nothing ->
                    Ok (Just aConstraint)

                Just bConstraint ->
                    Result.map Just
                        (typeVariableConstraintMerge aConstraint bConstraint)


typeVariableConstraintMerge : TypeVariableConstraint -> TypeVariableConstraint -> Result String TypeVariableConstraint
typeVariableConstraintMerge a b =
    case a of
        TypeVariableConstraintNumber ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintCompappend ->
                    Err "number and compappend variables cannot be unified"

        TypeVariableConstraintAppendable ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintAppendable

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintComparable ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintComparable

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintCompappend ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and compappend variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend


okTypeVariableConstraintCompappend : Result error_ TypeVariableConstraint
okTypeVariableConstraintCompappend =
    Ok TypeVariableConstraintCompappend


okTypeVariableConstraintComparable : Result error_ TypeVariableConstraint
okTypeVariableConstraintComparable =
    Ok TypeVariableConstraintComparable


okTypeVariableConstraintNumber : Result error_ TypeVariableConstraint
okTypeVariableConstraintNumber =
    Ok TypeVariableConstraintNumber


okTypeVariableConstraintAppendable : Result error_ TypeVariableConstraint
okTypeVariableConstraintAppendable =
    Ok TypeVariableConstraintAppendable


{-| Type information attached to expressions and patterns,
see [`TypedNode`](#TypedNode).

This is different from [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)
in that it doesn't contain
information unrelated to type inference like ranges, qualification levels or parens.

-}
type Type variable
    = TypeVariable variable
    | TypeNotVariable (TypeNotVariable variable)


{-| [`Type`](#Type) except the variable case
-}
type TypeNotVariable variable
    = TypeUnit
    | TypeConstruct
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type variable)
        }
    | TypeTuple
        { part0 : Type variable
        , part1 : Type variable
        }
    | TypeTriple
        { part0 : Type variable
        , part1 : Type variable
        , part2 : Type variable
        }
    | TypeRecord (FastDict.Dict String (Type variable))
    | TypeRecordExtension
        { recordVariable : variable
        , fields : FastDict.Dict String (Type variable)
        }
    | TypeFunction
        { input : Type variable
        , output : Type variable
        }


typeMapVariables :
    (variable -> changedVariable)
    -> Type variable
    -> Type changedVariable
typeMapVariables variableMap type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariable (variable |> variableMap)

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariable
                    |> typeNotVariableMapVariables variableMap
                )


typeNotVariableMapVariables :
    (variable -> variableMapped)
    -> TypeNotVariable variable
    -> TypeNotVariable variableMapped
typeNotVariableMapVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            TypeUnit

        TypeFunction typeFunction ->
            TypeFunction
                { input = typeFunction.input |> typeMapVariables variableMap
                , output = typeFunction.output |> typeMapVariables variableMap
                }

        TypeTuple typeTuple ->
            TypeTuple
                { part0 = typeTuple.part0 |> typeMapVariables variableMap
                , part1 = typeTuple.part1 |> typeMapVariables variableMap
                }

        TypeTriple typeTriple ->
            TypeTriple
                { part0 = typeTriple.part0 |> typeMapVariables variableMap
                , part1 = typeTriple.part1 |> typeMapVariables variableMap
                , part2 = typeTriple.part2 |> typeMapVariables variableMap
                }

        TypeConstruct typeConstruct ->
            TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> typeMapVariables variableMap
                            )
                }

        TypeRecord typeRecordFields ->
            TypeRecord
                (typeRecordFields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> typeMapVariables variableMap
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable =
                    typeRecordExtension.recordVariable
                        |> variableMap
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
                }


{-| because the FastSet module doesn't offer certain helpers
that are highly valuable for performance which FastDict does have
e.g. fast conversion between the two or restructure
-}
type alias FastSetFast a =
    FastDict.Dict a ()


typeMapVariablesAndCollectResultingVariables :
    (variable -> comparableChangedVariable)
    -> Type variable
    ->
        { type_ : Type comparableChangedVariable
        , containedVariables : FastSetFast comparableChangedVariable
        }
typeMapVariablesAndCollectResultingVariables variableMap type_ =
    case type_ of
        TypeVariable variable ->
            let
                variableMapped : comparableChangedVariable
                variableMapped =
                    variable |> variableMap
            in
            { type_ = TypeVariable variableMapped
            , containedVariables = FastDict.singleton variableMapped ()
            }

        TypeNotVariable typeNotVariable ->
            let
                typeNotVariableMapped :
                    { type_ : TypeNotVariable comparableChangedVariable
                    , containedVariables : FastSetFast comparableChangedVariable
                    }
                typeNotVariableMapped =
                    typeNotVariable
                        |> typeNotVariableMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ = TypeNotVariable typeNotVariableMapped.type_
            , containedVariables = typeNotVariableMapped.containedVariables
            }


typeUnitContainedVariablesEmpty :
    { type_ : TypeNotVariable comparableChangedVariable
    , containedVariables : FastSetFast comparableChangedVariable
    }
typeUnitContainedVariablesEmpty =
    { type_ = TypeUnit
    , containedVariables = FastDict.empty
    }


typeNotVariableMapVariablesAndCollectResultingVariables :
    (variable -> comparableChangedVariable)
    -> TypeNotVariable variable
    ->
        { type_ : TypeNotVariable comparableChangedVariable
        , containedVariables : FastSetFast comparableChangedVariable
        }
typeNotVariableMapVariablesAndCollectResultingVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            typeUnitContainedVariablesEmpty

        TypeFunction typeFunction ->
            let
                inputMapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                inputMapped =
                    typeFunction.input |> typeMapVariablesAndCollectResultingVariables variableMap

                outputMapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                outputMapped =
                    typeFunction.output |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeFunction
                    { input = inputMapped.type_
                    , output = outputMapped.type_
                    }
            , containedVariables =
                FastDict.union
                    inputMapped.containedVariables
                    outputMapped.containedVariables
            }

        TypeTuple typeTuple ->
            let
                part0Mapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                part0Mapped =
                    typeTuple.part0 |> typeMapVariablesAndCollectResultingVariables variableMap

                part1Mapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                part1Mapped =
                    typeTuple.part1 |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeTuple
                    { part0 = part0Mapped.type_
                    , part1 = part1Mapped.type_
                    }
            , containedVariables =
                FastDict.union
                    part0Mapped.containedVariables
                    part1Mapped.containedVariables
            }

        TypeTriple typeTriple ->
            let
                part0Mapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                part0Mapped =
                    typeTriple.part0 |> typeMapVariablesAndCollectResultingVariables variableMap

                part1Mapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                part1Mapped =
                    typeTriple.part1 |> typeMapVariablesAndCollectResultingVariables variableMap

                part2Mapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                part2Mapped =
                    typeTriple.part2 |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeTriple
                    { part0 = part0Mapped.type_
                    , part1 = part1Mapped.type_
                    , part2 = part2Mapped.type_
                    }
            , containedVariables =
                part0Mapped.containedVariables
                    |> FastDict.union part1Mapped.containedVariables
                    |> FastDict.union part2Mapped.containedVariables
            }

        TypeConstruct typeConstruct ->
            let
                argumentsMapped : { types : List (Type comparableChangedVariable), containedVariables : FastSetFast comparableChangedVariable }
                argumentsMapped =
                    typeConstruct.arguments
                        |> List.foldr
                            (\argument soFar ->
                                let
                                    argumentMapped : { type_ : Type comparableChangedVariable, containedVariables : FastSetFast comparableChangedVariable }
                                    argumentMapped =
                                        argument |> typeMapVariablesAndCollectResultingVariables variableMap
                                in
                                { types = argumentMapped.type_ :: soFar.types
                                , containedVariables =
                                    FastDict.union
                                        soFar.containedVariables
                                        argumentMapped.containedVariables
                                }
                            )
                            typedListEmptyContainedVariablesEmpty
            in
            { type_ =
                TypeConstruct
                    { moduleOrigin = typeConstruct.moduleOrigin
                    , name = typeConstruct.name
                    , arguments = argumentsMapped.types
                    }
            , containedVariables = argumentsMapped.containedVariables
            }

        TypeRecord typeRecordFields ->
            let
                fieldsMapped : FastDict.Dict String (Type comparableChangedVariable)
                fieldsMapped =
                    typeRecordFields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
            in
            { type_ = TypeRecord fieldsMapped
            , containedVariables =
                fieldsMapped
                    |> FastDict.foldl
                        (\_ value soFar ->
                            FastDict.union soFar
                                (value |> typeContainedVariables)
                        )
                        FastDict.empty
            }

        TypeRecordExtension typeRecordExtension ->
            let
                recordVariableMapped : comparableChangedVariable
                recordVariableMapped =
                    typeRecordExtension.recordVariable
                        |> variableMap

                fieldsMapped : FastDict.Dict String (Type comparableChangedVariable)
                fieldsMapped =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
            in
            { type_ =
                TypeRecordExtension
                    { recordVariable = recordVariableMapped
                    , fields = fieldsMapped
                    }
            , containedVariables =
                fieldsMapped
                    |> FastDict.foldl
                        (\_ value soFar ->
                            FastDict.union soFar
                                (value |> typeContainedVariables)
                        )
                        (FastDict.singleton recordVariableMapped ())
            }


typedListEmptyContainedVariablesEmpty :
    { types : List (Type comparableChangedVariable)
    , containedVariables : FastSetFast comparableChangedVariable
    }
typedListEmptyContainedVariablesEmpty =
    { types = [], containedVariables = FastDict.empty }


typeContainedVariables :
    Type comparableTypeVariable
    -> FastSetFast comparableTypeVariable
typeContainedVariables type_ =
    case type_ of
        TypeVariable variable ->
            FastDict.singleton variable ()

        TypeNotVariable typeNotVariable ->
            typeNotVariableContainedVariables typeNotVariable


typeNotVariableContainedVariables :
    TypeNotVariable comparableTypeVariable
    -> FastSetFast comparableTypeVariable
typeNotVariableContainedVariables typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            FastDict.empty

        TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> typeContainedVariables)
                (typeFunction.output |> typeContainedVariables)

        TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> typeContainedVariables)
                (typeTuple.part1 |> typeContainedVariables)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> typeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> typeContainedVariables)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetFastsAndUnify typeContainedVariables

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> typeContainedVariables)
                    )
                    FastDict.empty

        TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> typeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable ())


typeVariableFromContextEquals : TypeVariableFromContext -> TypeVariableFromContext -> Bool
typeVariableFromContextEquals ( aRangeAsComparable, aName ) ( bRangeAsComparable, bName ) =
    (aName == bName)
        && rangeAsComparableEquals aRangeAsComparable bRangeAsComparable


rangeAsComparableEquals : RangeAsComparable -> RangeAsComparable -> Bool
rangeAsComparableEquals ( aStart, aEnd ) ( bStart, bEnd ) =
    locationAsComparableEquals aStart bStart
        && locationAsComparableEquals aEnd bEnd


locationAsComparableEquals : LocationAsComparable -> LocationAsComparable -> Bool
locationAsComparableEquals ( aRow, aColumn ) ( bRow, bColumn ) =
    (aRow - bRow == 0)
        && (aColumn - bColumn == 0)


typeContainsVariable :
    TypeVariableFromContext
    -> Type TypeVariableFromContext
    -> Bool
typeContainsVariable variableToCheckFor type_ =
    case type_ of
        TypeVariable variable ->
            typeVariableFromContextEquals variableToCheckFor variable

        TypeNotVariable typeNotVariable ->
            typeNotVariableContainsVariable variableToCheckFor typeNotVariable


typeNotVariableContainsVariable :
    TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableContainsVariable variableToCheckFor typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            False

        TypeFunction typeFunction ->
            (typeFunction.input |> typeContainsVariable variableToCheckFor)
                || (typeFunction.output |> typeContainsVariable variableToCheckFor)

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeContainsVariable variableToCheckFor)
                || (typeTuple.part1 |> typeContainsVariable variableToCheckFor)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeContainsVariable variableToCheckFor)
                || (typeTriple.part1 |> typeContainsVariable variableToCheckFor)
                || (typeTriple.part2 |> typeContainsVariable variableToCheckFor)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any
                    (\argument ->
                        argument |> typeContainsVariable variableToCheckFor
                    )

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> fastDictAny
                    (\value ->
                        value |> typeContainsVariable variableToCheckFor
                    )

        TypeRecordExtension typeRecordExtension ->
            typeVariableFromContextEquals
                typeRecordExtension.recordVariable
                variableToCheckFor
                || (typeRecordExtension.fields
                        |> fastDictAny
                            (\value ->
                                value |> typeContainsVariable variableToCheckFor
                            )
                   )


{-| How to map names and symbols used in a module to their origin module.
Create with [`importsToModuleOriginLookup`](#importsToModuleOriginLookup).

Contains variants, type alias names, choice type names, port names, value/function declaration names
and whether `(|.)` and or `(|=)` are imported from `Parser.Advanced`.

Also contains locally declared names when available.

Type- and expression/pattern-level members
are separated since you can for example have a local `List` variant
while also using an (implicitly) imported `List` type.

-}
type alias ModuleOriginLookup =
    { references :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , typeConstructs :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , keepOperatorIsExposedFromParserAdvanced : Bool
    , ignoreOperatorIsExposedFromParserAdvanced : Bool
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports, see [`ModuleOriginLookup`](#ModuleOriginLookup).

Requires all exposed [`ModuleTypes`](#ModuleTypes)
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleOriginLookup :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleOriginLookup
importsToModuleOriginLookup modulesTypes imports =
    let
        importsNormal :
            List
                { moduleName : Elm.Syntax.ModuleName.ModuleName
                , alias : Maybe String
                , typeExposes : List String
                , referenceExposes : List String
                }
        importsNormal =
            imports
                |> List.foldl
                    (\(Elm.Syntax.Node.Node _ syntaxImport) importNormalsSoFar ->
                        (syntaxImport |> importToNormal modulesTypes)
                            :: importNormalsSoFar
                    )
                    implicitImports
                |> importsCombine

        operatorIsExposedFromParserAdvanced : String -> Bool
        operatorIsExposedFromParserAdvanced operator =
            importsNormal
                |> List.any
                    (\syntaxImport ->
                        case syntaxImport.moduleName of
                            [ "Parser", "Advanced" ] ->
                                syntaxImport.referenceExposes
                                    |> List.any
                                        (\syntaxExpose ->
                                            (syntaxExpose == operator)
                                                || (syntaxExpose == ("(" ++ operator ++ ")"))
                                        )

                            _ ->
                                False
                    )
    in
    importsNormal
        |> List.foldl
            (\syntaxImport soFar ->
                case modulesTypes |> FastDict.get syntaxImport.moduleName of
                    Nothing ->
                        soFar

                    Just moduleTypes ->
                        let
                            moduleAliasOrFullName : Elm.Syntax.ModuleName.ModuleName
                            moduleAliasOrFullName =
                                case syntaxImport.alias of
                                    Nothing ->
                                        syntaxImport.moduleName

                                    Just importAlias ->
                                        [ importAlias ]

                            exposedTypeConstructsFromImportedModuleItself :
                                FastDict.Dict
                                    ( Elm.Syntax.ModuleName.ModuleName, String )
                                    Elm.Syntax.ModuleName.ModuleName
                            exposedTypeConstructsFromImportedModuleItself =
                                moduleTypes.choiceTypes
                                    |> FastDict.foldl
                                        (\choiceTypeName _ variantNamesSoFar ->
                                            variantNamesSoFar
                                                |> FastDict.insert
                                                    ( moduleAliasOrFullName, choiceTypeName )
                                                    syntaxImport.moduleName
                                        )
                                        (moduleTypes.typeAliases
                                            |> FastDict.foldl
                                                (\typeAliasName _ referenceNamesSoFar ->
                                                    referenceNamesSoFar
                                                        |> FastDict.insert
                                                            ( moduleAliasOrFullName, typeAliasName )
                                                            syntaxImport.moduleName
                                                )
                                                FastDict.empty
                                        )

                            exposedReferencesFromImportedModuleItself :
                                FastDict.Dict
                                    ( Elm.Syntax.ModuleName.ModuleName, String )
                                    Elm.Syntax.ModuleName.ModuleName
                            exposedReferencesFromImportedModuleItself =
                                moduleTypes.choiceTypes
                                    |> FastDict.foldl
                                        (\_ choiceType variantNamesSoFar ->
                                            choiceType.variants
                                                |> FastDict.foldl
                                                    (\variantName _ soFarAndVariantNamesOfCurrentChoiceType ->
                                                        soFarAndVariantNamesOfCurrentChoiceType
                                                            |> FastDict.insert
                                                                ( moduleAliasOrFullName, variantName )
                                                                syntaxImport.moduleName
                                                    )
                                                    variantNamesSoFar
                                        )
                                        (moduleTypes.signatures
                                            |> FastDict.foldl
                                                (\reference _ referenceNamesSoFar ->
                                                    referenceNamesSoFar
                                                        |> FastDict.insert
                                                            ( moduleAliasOrFullName, reference )
                                                            syntaxImport.moduleName
                                                )
                                                (moduleTypes.typeAliases
                                                    |> FastDict.foldl
                                                        (\typeAliasName typeAliasInfo recordTypeALiasNamesSoFar ->
                                                            case typeAliasInfo.recordFieldOrder of
                                                                Nothing ->
                                                                    recordTypeALiasNamesSoFar

                                                                Just _ ->
                                                                    recordTypeALiasNamesSoFar
                                                                        |> FastDict.insert
                                                                            ( moduleAliasOrFullName, typeAliasName )
                                                                            syntaxImport.moduleName
                                                        )
                                                        FastDict.empty
                                                )
                                        )
                        in
                        { keepOperatorIsExposedFromParserAdvanced =
                            soFar.keepOperatorIsExposedFromParserAdvanced
                        , ignoreOperatorIsExposedFromParserAdvanced =
                            soFar.ignoreOperatorIsExposedFromParserAdvanced
                        , references =
                            syntaxImport.referenceExposes
                                |> List.foldl
                                    (\expose referencesSoFarAndImportExposed ->
                                        referencesSoFarAndImportExposed
                                            |> FastDict.insert ( [], expose )
                                                syntaxImport.moduleName
                                    )
                                    soFar.references
                                |> FastDict.union
                                    exposedReferencesFromImportedModuleItself
                        , typeConstructs =
                            syntaxImport.typeExposes
                                |> List.foldl
                                    (\expose typeConstructsSoFarAndImportExposed ->
                                        typeConstructsSoFarAndImportExposed
                                            |> FastDict.insert ( [], expose )
                                                syntaxImport.moduleName
                                    )
                                    soFar.typeConstructs
                                |> FastDict.union
                                    exposedTypeConstructsFromImportedModuleItself
                        }
            )
            { references = FastDict.empty
            , typeConstructs = FastDict.empty
            , keepOperatorIsExposedFromParserAdvanced =
                operatorIsExposedFromParserAdvanced "|."
            , ignoreOperatorIsExposedFromParserAdvanced =
                operatorIsExposedFromParserAdvanced "|="
            }


importToNormal :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Elm.Syntax.Import.Import
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importToNormal modulesTypes syntaxImport =
    let
        importModuleName : Elm.Syntax.ModuleName.ModuleName
        importModuleName =
            syntaxImport.moduleName |> Elm.Syntax.Node.value
    in
    { moduleName = importModuleName
    , alias =
        syntaxImport.moduleAlias
            |> Maybe.map
                (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                    syntaxAlias |> String.join "."
                )
    , typeExposes =
        case syntaxImport.exposingList of
            Nothing ->
                []

            Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                case modulesTypes |> FastDict.get importModuleName of
                    Nothing ->
                        []

                    Just moduleTypes ->
                        case syntaxExposing of
                            Elm.Syntax.Exposing.All _ ->
                                moduleTypes.choiceTypes
                                    |> FastDict.foldl
                                        (\choiceTypeName _ soFar ->
                                            choiceTypeName :: soFar
                                        )
                                        (moduleTypes.typeAliases |> FastDict.keys)

                            Elm.Syntax.Exposing.Explicit exposes ->
                                exposes
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ expose) ->
                                            case expose of
                                                Elm.Syntax.Exposing.InfixExpose _ ->
                                                    Nothing

                                                Elm.Syntax.Exposing.FunctionExpose _ ->
                                                    Nothing

                                                Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                    Just name

                                                Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                    Just choiceTypeExpose.name
                                        )
    , referenceExposes =
        case syntaxImport.exposingList of
            Nothing ->
                []

            Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                case modulesTypes |> FastDict.get importModuleName of
                    Nothing ->
                        []

                    Just moduleTypes ->
                        case syntaxExposing of
                            Elm.Syntax.Exposing.All _ ->
                                moduleTypes.typeAliases
                                    |> FastDict.foldl
                                        (\typeAliasName info soFar ->
                                            case info.recordFieldOrder of
                                                Nothing ->
                                                    soFar

                                                Just _ ->
                                                    typeAliasName :: soFar
                                        )
                                        (moduleTypes.choiceTypes
                                            |> FastDict.foldl
                                                (\_ choiceTypeInfo soFar ->
                                                    choiceTypeInfo.variants
                                                        |> FastDict.foldl
                                                            (\variantName _ soFarWithVariants ->
                                                                variantName :: soFarWithVariants
                                                            )
                                                            soFar
                                                )
                                                (moduleTypes.signatures |> FastDict.keys)
                                        )

                            Elm.Syntax.Exposing.Explicit exposes ->
                                exposes
                                    |> List.foldl
                                        (\(Elm.Syntax.Node.Node _ expose) namesSoFar ->
                                            case expose of
                                                Elm.Syntax.Exposing.TypeOrAliasExpose opaqueTypeOrTypeAliasName ->
                                                    case moduleTypes.typeAliases |> FastDict.get opaqueTypeOrTypeAliasName of
                                                        Nothing ->
                                                            namesSoFar

                                                        Just typeAlias ->
                                                            case typeAlias.recordFieldOrder of
                                                                Nothing ->
                                                                    namesSoFar

                                                                Just _ ->
                                                                    opaqueTypeOrTypeAliasName :: namesSoFar

                                                Elm.Syntax.Exposing.InfixExpose operator ->
                                                    operator :: namesSoFar

                                                Elm.Syntax.Exposing.FunctionExpose name ->
                                                    name :: namesSoFar

                                                Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                    case choiceTypeExpose.open of
                                                        Nothing ->
                                                            namesSoFar

                                                        Just _ ->
                                                            case moduleTypes.choiceTypes |> FastDict.get choiceTypeExpose.name of
                                                                Nothing ->
                                                                    namesSoFar

                                                                Just choiceTypeDeclared ->
                                                                    choiceTypeDeclared.variants
                                                                        |> FastDict.foldl
                                                                            (\name _ namesSoFarWithVariantNames ->
                                                                                name :: namesSoFarWithVariantNames
                                                                            )
                                                                            namesSoFar
                                        )
                                        []
    }


implicitImports :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
implicitImports =
    [ { moduleName = [ "Basics" ]
      , alias = Nothing
      , typeExposes = [ "Int", "Float", "Order", "Bool", "Never" ]
      , referenceExposes =
            [ "(+)"
            , "(-)"
            , "(*)"
            , "(/)"
            , "(//)"
            , "(^)"
            , "toFloat"
            , "round"
            , "floor"
            , "ceiling"
            , "truncate"
            , "(==)"
            , "(/=)"
            , "(<)"
            , "(>)"
            , "(<=)"
            , "(>=)"
            , "max"
            , "min"
            , "compare"
            , "LT"
            , "EQ"
            , "GT"
            , "True"
            , "False"
            , "not"
            , "(&&)"
            , "(||)"
            , "xor"
            , "(++)"
            , "modBy"
            , "remainderBy"
            , "negate"
            , "abs"
            , "clamp"
            , "sqrt"
            , "logBase"
            , "e"
            , "pi"
            , "cos"
            , "sin"
            , "tan"
            , "acos"
            , "asin"
            , "atan"
            , "atan2"
            , "degrees"
            , "radians"
            , "turns"
            , "toPolar"
            , "fromPolar"
            , "isNaN"
            , "isInfinite"
            , "identity"
            , "always"
            , "(<|)"
            , "(|>)"
            , "(<<)"
            , "(>>)"
            , "never"
            ]
      }
    , { moduleName = [ "List" ], alias = Nothing, typeExposes = [ "List" ], referenceExposes = [ "(::)" ] }
    , { moduleName = [ "Maybe" ], alias = Nothing, typeExposes = [ "Maybe" ], referenceExposes = [ "Just", "Nothing" ] }
    , { moduleName = [ "Result" ], alias = Nothing, typeExposes = [ "Result" ], referenceExposes = [ "Ok", "Err" ] }
    , { moduleName = [ "String" ], alias = Nothing, typeExposes = [ "String" ], referenceExposes = [] }
    , { moduleName = [ "Char" ], alias = Nothing, typeExposes = [ "Char" ], referenceExposes = [] }
    , { moduleName = [ "Tuple" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Debug" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Platform" ], alias = Nothing, typeExposes = [ "Program" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Cmd" ], alias = Just "Cmd", typeExposes = [ "Cmd" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Sub" ], alias = Just "Sub", typeExposes = [ "Sub" ], referenceExposes = [] }
    ]


importsCombine :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importsMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importsMerge :
    { moduleName : Elm.Syntax.ModuleName.ModuleName
    , alias : Maybe String
    , typeExposes : List String
    , referenceExposes : List String
    }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importsMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , typeExposes =
        exposingCombine earlier.typeExposes later.typeExposes
    , referenceExposes =
        exposingCombine earlier.referenceExposes later.referenceExposes
    }


exposingCombine : List String -> List String -> List String
exposingCombine a b =
    listAppendFastButInReverseOrder a b
        |> exposeListToNormal


exposeListToNormal :
    List String
    -> List String
exposeListToNormal syntaxExposeList =
    syntaxExposeList
        |> List.sort
        |> exposesCombine


exposesCombine : List String -> List String
exposesCombine syntaxExposes =
    exposesCombineFrom [] syntaxExposes


exposesCombineFrom : List String -> List String -> List String
exposesCombineFrom soFar syntaxExposes =
    case syntaxExposes of
        [] ->
            soFar

        [ onlyExpose ] ->
            onlyExpose :: soFar

        expose0 :: expose1 :: expose2Up ->
            case Basics.compare expose0 expose1 of
                EQ ->
                    exposesCombineFrom soFar (expose0 :: expose2Up)

                LT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)

                GT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)


syntaxToType :
    ModuleOriginLookup
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String (Type String)
syntaxToType moduleOriginLookup syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            okTypeUnit

        Elm.Syntax.TypeAnnotation.GenericType variableName ->
            Ok (TypeVariable variableName)

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( qualification, unqualifiedName )) argumentNodes ->
            case moduleOriginLookup.typeConstructs |> FastDict.get ( qualification, unqualifiedName ) of
                Nothing ->
                    Err
                        (case qualification of
                            [] ->
                                "could not find imported/local declaration for "
                                    ++ unqualifiedName

                            qualificationPart0 :: qualificationPart1Up ->
                                "could not find imported declaration for "
                                    ++ qualifiedToString
                                        { qualification = qualificationPart0 :: qualificationPart1Up
                                        , name = unqualifiedName
                                        }
                        )

                Just originModule ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = originModule
                                    , name = unqualifiedName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentNodes
                            |> listMapAndCombineOk
                                (\(Elm.Syntax.Node.Node _ argument) ->
                                    argument |> syntaxToType moduleOriginLookup
                                )
                        )

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [] ->
                    okTypeUnit

                [ Elm.Syntax.Node.Node _ inParens ] ->
                    inParens |> syntaxToType moduleOriginLookup

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1, Elm.Syntax.Node.Node _ syntaxPart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)
                        (syntaxPart2 |> syntaxToType moduleOriginLookup)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.TypeAnnotation.Record recordFields ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (recordFields
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariableName) (Elm.Syntax.Node.Node _ recordExtensionFields) ->
            case recordExtensionFields of
                [] ->
                    Err "record extension by 0 fields is invalid syntax"

                field0 :: field1Up ->
                    Result.map
                        (\fields ->
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = recordVariableName
                                    , fields = fields
                                    }
                                )
                        )
                        ((field0 :: field1Up)
                            |> listFoldlWhileOkFrom
                                FastDict.empty
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                                    Result.map
                                        (\fieldValueType ->
                                            soFar |> FastDict.insert fieldName fieldValueType
                                        )
                                        (fieldValue |> syntaxToType moduleOriginLookup)
                                )
                        )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation (Elm.Syntax.Node.Node _ syntaxInput) (Elm.Syntax.Node.Node _ syntaxOutput) ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (syntaxInput |> syntaxToType moduleOriginLookup)
                (syntaxOutput |> syntaxToType moduleOriginLookup)


qualifiedToString :
    { qualification : Elm.Syntax.ModuleName.ModuleName, name : String }
    -> String
qualifiedToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationUntilDot :: qualificationAfterDot ->
            ((qualificationUntilDot :: qualificationAfterDot)
                |> String.join "."
            )
                ++ "."
                ++ reference.name


typeSubstituteVariable :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { variable : TypeVariableFromContext
        , type_ : Type TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariable context replacement type_ =
    case replacement.type_ of
        TypeVariable argumentVariable ->
            Ok
                { type_ =
                    type_
                        |> typeMapVariables
                            (\variable ->
                                if typeVariableFromContextEquals variable replacement.variable then
                                    argumentVariable

                                else
                                    variable
                            )
                , substitutions = variableSubstitutionsNone
                }

        TypeNotVariable argumentNotVariable ->
            type_
                |> typeSubstituteVariableByNotVariable context
                    (FastDict.singleton replacement.variable argumentNotVariable)
                |> Result.map
                    (\substituted ->
                        { type_ = substituted.type_
                        , substitutions = substituted.substitutions
                        }
                    )


typeApplyVariableSubstitutions :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> Type TypeVariableFromContext
    -> Result String (Type TypeVariableFromContext)
typeApplyVariableSubstitutions context substitutions originalType =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ error
                        )

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables context
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            typeApplyVariableSubstitutions context
                                variableToTypeWithCondensedVariables
                                (originalType
                                    |> typeMapVariables
                                        (\originalVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalVariable
                                                |> Maybe.withDefault originalVariable
                                        )
                                )

        [] ->
            if substitutions.variableToType |> FastDict.isEmpty then
                Ok originalType

            else
                case
                    substitutions.variableToType
                        |> substitutionsVariableToTypeApplyOverItself context
                of
                    Err error ->
                        Err error

                    Ok variableToTypeSubstitutedOverItself ->
                        case
                            originalType
                                |> typeSubstituteVariableByNotVariable context
                                    variableToTypeSubstitutedOverItself
                        of
                            Err error ->
                                Err error

                            Ok typeWithVariableToTypeSubstitutionApplied ->
                                if typeWithVariableToTypeSubstitutionApplied.unchanged then
                                    Ok originalType

                                else
                                    typeApplyVariableSubstitutions context
                                        typeWithVariableToTypeSubstitutionApplied.substitutions
                                        typeWithVariableToTypeSubstitutionApplied.type_


typeSubstituteVariableByNotVariable :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { unchanged : Bool
            , type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariableByNotVariable context replacement type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable typeVariable ->
            case replacement |> FastDict.get typeVariable of
                Nothing ->
                    Ok
                        { unchanged = True
                        , type_ = type_
                        , substitutions = variableSubstitutionsNone
                        }

                Just replacementType ->
                    case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                        Nothing ->
                            Ok
                                { unchanged = False
                                , type_ = TypeNotVariable replacementType
                                , substitutions = variableSubstitutionsNone
                                }

                        Just constraint ->
                            case constraint of
                                TypeVariableConstraintNumber ->
                                    if
                                        replacementType
                                            |> typeNotVariableIsNumber context.declarationTypes
                                    then
                                        Ok
                                            { unchanged = False
                                            , type_ = TypeNotVariable replacementType
                                            , substitutions = variableSubstitutionsNone
                                            }

                                    else
                                        Err
                                            ("("
                                                ++ (context.range |> rangeToInfoString)
                                                ++ ") "
                                                ++ "cannot unify number type variable with types other than Int/Float, found: "
                                                ++ (replacementType |> typeNotVariableToInfoString)
                                            )

                                TypeVariableConstraintAppendable ->
                                    if
                                        replacementType
                                            |> typeNotVariableIsAppendable context.declarationTypes
                                    then
                                        Ok
                                            { unchanged = False
                                            , type_ = TypeNotVariable replacementType
                                            , substitutions = variableSubstitutionsNone
                                            }

                                    else
                                        Err
                                            ("("
                                                ++ (context.range |> rangeToInfoString)
                                                ++ ") "
                                                ++ "cannot unify appendable type variable with types other than String/List _"
                                            )

                                TypeVariableConstraintComparable ->
                                    if
                                        replacementType
                                            |> typeNotVariableIsComparable context.declarationTypes
                                    then
                                        Ok
                                            { unchanged = False
                                            , type_ = TypeNotVariable replacementType
                                            , substitutions = variableSubstitutionsNone
                                            }

                                    else
                                        Err
                                            ("("
                                                ++ (context.range |> rangeToInfoString)
                                                ++ ") "
                                                ++ "cannot unify comparable type variable with types other than Int/Float/String/Time.Posix/List of comparable/tuple of comparables/triple of comparable"
                                            )

                                TypeVariableConstraintCompappend ->
                                    if
                                        replacementType
                                            |> typeNotVariableIsCompappend context.declarationTypes
                                    then
                                        Ok
                                            { unchanged = False
                                            , type_ = TypeNotVariable replacementType
                                            , substitutions = variableSubstitutionsNone
                                            }

                                    else
                                        Err
                                            ("("
                                                ++ (context.range |> rangeToInfoString)
                                                ++ ") "
                                                ++ "cannot unify compappend type variable with types other than String/List of comparable"
                                            )

        TypeNotVariable typeNotVariable ->
            case
                typeNotVariable
                    |> typeNotVariableSubstituteVariableByNotVariable context
                        replacement
            of
                Err error ->
                    Err error

                Ok typeNotVariableSubstituted ->
                    Ok
                        { unchanged = typeNotVariableSubstituted.unchanged
                        , type_ = TypeNotVariable typeNotVariableSubstituted.type_
                        , substitutions = typeNotVariableSubstituted.substitutions
                        }


typeToInfoString : Type TypeVariableFromContext -> String
typeToInfoString type_ =
    case type_ of
        TypeVariable typeVariable ->
            typeVariable |> typeVariableFromContextToInfoString

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableToInfoString


typeVariableFromContextToInfoString : TypeVariableFromContext -> String
typeVariableFromContextToInfoString ( range, variable ) =
    variable ++ "(" ++ (range |> rangeFromAsComparable |> rangeToInfoString) ++ ")"


typeNotVariableToInfoString : TypeNotVariable TypeVariableFromContext -> String
typeNotVariableToInfoString typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typeToInfoString)
                ++ " -> "
                ++ (typeFunction.output |> typeToInfoString)
                ++ ")"

        TypeConstruct typeConstruct ->
            let
                typeReferenceAsString : String
                typeReferenceAsString =
                    qualifiedToString
                        { qualification = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
            in
            case typeConstruct.arguments of
                [] ->
                    typeReferenceAsString

                argument0 :: argument1Up ->
                    "("
                        ++ typeReferenceAsString
                        ++ (argument0
                                :: argument1Up
                                |> List.map (\argument -> " " ++ (argument |> typeToInfoString))
                                |> String.concat
                           )
                        ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ ", "
                ++ (parts.part2 |> typeToInfoString)
                ++ " )"

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension recordExtension ->
            "{ "
                ++ (recordExtension.recordVariable |> typeVariableFromContextToInfoString)
                ++ " | "
                ++ (recordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"


typeNotVariableSubstituteVariableByNotVariable :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { unchanged : Bool
            , type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableSubstituteVariableByNotVariable context replacement typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            Ok
                { unchanged = True
                , type_ = typeNotVariable
                , substitutions = variableSubstitutionsNone
                }

        TypeConstruct typeChoiceConstruct ->
            case typeChoiceConstruct.arguments of
                [] ->
                    Ok
                        { unchanged = True
                        , type_ = typeNotVariable
                        , substitutions = variableSubstitutionsNone
                        }

                argument0 :: argument1Up ->
                    Result.map
                        (\argumentsSubstituted ->
                            { unchanged = argumentsSubstituted.allUnchanged
                            , type_ =
                                if argumentsSubstituted.allUnchanged then
                                    typeNotVariable

                                else
                                    TypeConstruct
                                        { moduleOrigin = typeChoiceConstruct.moduleOrigin
                                        , name = typeChoiceConstruct.name
                                        , arguments = argumentsSubstituted.arguments
                                        }
                            , substitutions = argumentsSubstituted.substitutions
                            }
                        )
                        ((argument0 :: argument1Up)
                            |> listFoldrWhileOkFrom
                                { allUnchanged = True
                                , arguments = []
                                , substitutions = variableSubstitutionsNone
                                }
                                (\argument soFar ->
                                    Result.andThen
                                        (\argumentSubstituted ->
                                            if argumentSubstituted.unchanged then
                                                Ok
                                                    { allUnchanged = soFar.allUnchanged
                                                    , arguments =
                                                        argument :: soFar.arguments
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Result.map
                                                    (\substitutionsWithArgument ->
                                                        { allUnchanged = False
                                                        , arguments =
                                                            argumentSubstituted.type_
                                                                :: soFar.arguments
                                                        , substitutions = substitutionsWithArgument
                                                        }
                                                    )
                                                    (variableSubstitutionsMerge context
                                                        argumentSubstituted.substitutions
                                                        soFar.substitutions
                                                    )
                                        )
                                        (argument
                                            |> typeSubstituteVariableByNotVariable context
                                                replacement
                                        )
                                )
                        )

        TypeTuple typeTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsPart01 ->
                                { unchanged = False
                                , type_ =
                                    TypeTuple
                                        { part0 = part0Substituted.type_
                                        , part1 = part1Substituted.type_
                                        }
                                , substitutions = substitutionsPart01
                                }
                            )
                            (variableSubstitutionsMerge context
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (typeTuple.part0
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )
                (typeTuple.part1
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )

        TypeTriple typeTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsPart01 ->
                                { unchanged = False
                                , type_ =
                                    TypeTriple
                                        { part0 = part0Substituted.type_
                                        , part1 = part1Substituted.type_
                                        , part2 = part2Substituted.type_
                                        }
                                , substitutions = substitutionsPart01
                                }
                            )
                            (variableSubstitutionsMerge3 context
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (typeTriple.part0
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )
                (typeTriple.part1
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )
                (typeTriple.part2
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )

        TypeRecord typeRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    if fieldsSubstituted.allUnchanged then
                        { unchanged = True
                        , type_ = typeNotVariable
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = fieldsSubstituted.substitutions
                        , type_ = TypeRecord fieldsSubstituted.types
                        }
                )
                (typeRecordFields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmptyAllUnchangedTrue
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName fieldValue
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithValue ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithValue
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert fieldName valueSubstituted.type_
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable context
                                        replacement
                                )
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            Result.andThen
                (\fieldsSubstituted ->
                    case replacement |> FastDict.get typeRecordExtension.recordVariable of
                        Nothing ->
                            if fieldsSubstituted.allUnchanged then
                                Ok
                                    { unchanged = True
                                    , type_ = typeNotVariable
                                    , substitutions = variableSubstitutionsNone
                                    }

                            else
                                Ok
                                    { unchanged = False
                                    , substitutions = fieldsSubstituted.substitutions
                                    , type_ =
                                        TypeRecordExtension
                                            { recordVariable = typeRecordExtension.recordVariable
                                            , fields = fieldsSubstituted.types
                                            }
                                    }

                        Just recordVariableReplacementTypeNotVariable ->
                            case recordVariableReplacementTypeNotVariable of
                                TypeRecord replacementRecordFields ->
                                    Result.map
                                        (\fieldsMerged ->
                                            { unchanged = False
                                            , substitutions = fieldsMerged.substitutions
                                            , type_ = TypeRecord fieldsMerged.types
                                            }
                                        )
                                        (FastDict.merge
                                            (\name value soFarOrError ->
                                                Result.map
                                                    (\soFar ->
                                                        { substitutions = soFar.substitutions
                                                        , types = soFar.types |> FastDict.insert name value
                                                        }
                                                    )
                                                    soFarOrError
                                            )
                                            (\name valueSubstituted valueReplacement soFarOrError ->
                                                Result.andThen
                                                    (\soFar ->
                                                        Result.andThen
                                                            (\valueUnified ->
                                                                Result.map
                                                                    (\fullSubstitutions ->
                                                                        { substitutions = fullSubstitutions
                                                                        , types =
                                                                            soFar.types
                                                                                |> FastDict.insert name valueUnified.type_
                                                                        }
                                                                    )
                                                                    (variableSubstitutionsMerge context
                                                                        soFar.substitutions
                                                                        valueUnified.substitutions
                                                                    )
                                                            )
                                                            (typeUnify context
                                                                valueSubstituted
                                                                valueReplacement
                                                            )
                                                    )
                                                    soFarOrError
                                            )
                                            (\name value soFarOrError ->
                                                Result.map
                                                    (\soFar ->
                                                        { substitutions = soFar.substitutions
                                                        , types =
                                                            soFar.types
                                                                |> FastDict.insert name value
                                                        }
                                                    )
                                                    soFarOrError
                                            )
                                            fieldsSubstituted.types
                                            replacementRecordFields
                                            (Ok
                                                { substitutions = fieldsSubstituted.substitutions
                                                , types = FastDict.empty
                                                }
                                            )
                                        )

                                TypeRecordExtension replacementRecordExtension ->
                                    Result.map
                                        (\fieldsMerged ->
                                            { unchanged = False
                                            , substitutions = fieldsMerged.substitutions
                                            , type_ =
                                                TypeRecordExtension
                                                    { recordVariable = replacementRecordExtension.recordVariable
                                                    , fields = fieldsMerged.types
                                                    }
                                            }
                                        )
                                        (FastDict.merge
                                            (\name value soFarOrError ->
                                                Result.map
                                                    (\soFar ->
                                                        { substitutions = soFar.substitutions
                                                        , types = soFar.types |> FastDict.insert name value
                                                        }
                                                    )
                                                    soFarOrError
                                            )
                                            (\name valueSubstituted valueReplacement soFarOrError ->
                                                Result.andThen
                                                    (\soFar ->
                                                        Result.andThen
                                                            (\valueUnified ->
                                                                Result.map
                                                                    (\fullSubstitutions ->
                                                                        { substitutions = fullSubstitutions
                                                                        , types =
                                                                            soFar.types
                                                                                |> FastDict.insert name valueUnified.type_
                                                                        }
                                                                    )
                                                                    (variableSubstitutionsMerge context
                                                                        soFar.substitutions
                                                                        valueUnified.substitutions
                                                                    )
                                                            )
                                                            (typeUnify context
                                                                valueSubstituted
                                                                valueReplacement
                                                            )
                                                    )
                                                    soFarOrError
                                            )
                                            (\name value soFarOrError ->
                                                Result.map
                                                    (\soFar ->
                                                        { substitutions = soFar.substitutions
                                                        , types = soFar.types |> FastDict.insert name value
                                                        }
                                                    )
                                                    soFarOrError
                                            )
                                            fieldsSubstituted.types
                                            replacementRecordExtension.fields
                                            (Ok
                                                { substitutions = fieldsSubstituted.substitutions
                                                , types = FastDict.empty
                                                }
                                            )
                                        )

                                TypeUnit ->
                                    Err
                                        ("("
                                            ++ (context.range |> rangeToInfoString)
                                            ++ ") "
                                            ++ "cannot unify record extension type variable with types other than record/record extension"
                                        )

                                TypeConstruct _ ->
                                    Err
                                        ("("
                                            ++ (context.range |> rangeToInfoString)
                                            ++ ") "
                                            ++ "cannot unify record extension type variable with types other than record/record extension"
                                        )

                                TypeTuple _ ->
                                    Err
                                        ("("
                                            ++ (context.range |> rangeToInfoString)
                                            ++ ") "
                                            ++ "cannot unify record extension type variable with types other than record/record extension"
                                        )

                                TypeTriple _ ->
                                    Err
                                        ("("
                                            ++ (context.range |> rangeToInfoString)
                                            ++ ") "
                                            ++ "cannot unify record extension type variable with types other than record/record extension"
                                        )

                                TypeFunction _ ->
                                    Err
                                        ("("
                                            ++ (context.range |> rangeToInfoString)
                                            ++ ") "
                                            ++ "cannot unify record extension type variable with types other than record/record extension"
                                        )
                )
                (typeRecordExtension.fields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmptyAllUnchangedTrue
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName fieldValue
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithValue ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithValue
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert fieldName valueSubstituted.type_
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable context
                                        replacement
                                )
                        )
                )

        TypeFunction typeFunction ->
            resultAndThen2
                (\inputSubstituted outputSubstituted ->
                    if inputSubstituted.unchanged && outputSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsInputOutput ->
                                { unchanged = False
                                , type_ =
                                    TypeFunction
                                        { input = inputSubstituted.type_
                                        , output = outputSubstituted.type_
                                        }
                                , substitutions = substitutionsInputOutput
                                }
                            )
                            (variableSubstitutionsMerge context
                                inputSubstituted.substitutions
                                outputSubstituted.substitutions
                            )
                )
                (typeFunction.input
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )
                (typeFunction.output
                    |> typeSubstituteVariableByNotVariable context
                        replacement
                )


substitutionsNoneTypesDictEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , types : FastDict.Dict String (Type TypeVariableFromContext)
    }
substitutionsNoneTypesDictEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , types = FastDict.empty
    }


typeIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsNumber declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsNumber declarationTypes
                typeNotVariable


typeNotVariableIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsNumber declarationTypes type_ =
    case type_ of
        TypeConstruct typeConstruct ->
            case typeConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case typeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            typeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsNumber declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsAppendable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsAppendable declarationTypes
                typeNotVariable


typeNotVariableIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsAppendable declarationTypes type_ =
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsAppendable declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsComparable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    False

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    True

                Just TypeVariableConstraintNumber ->
                    True

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsComparable declarationTypes
                typeNotVariable


typeNotVariableIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsComparable declarationTypes typeNotVariable =
    -- IGNORE TCO
    case typeNotVariable of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "Basics" ] ->
                    case variableReplacementTypeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                [ "Time" ] ->
                    case variableReplacementTypeConstruct.name of
                        "Posix" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsComparable declarationTypes
                                deAliasedTypeConstruct

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeIsComparable declarationTypes)
                && (typeTuple.part1 |> typeIsComparable declarationTypes)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeIsComparable declarationTypes)
                && (typeTriple.part1 |> typeIsComparable declarationTypes)
                && (typeTriple.part2 |> typeIsComparable declarationTypes)

        TypeUnit ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsCompappend declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    False

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsCompappend declarationTypes
                typeNotVariable


typeNotVariableIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsCompappend declarationTypes type_ =
    -- IGNORE TCO
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsCompappend declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeConstructFullyExpandIfAlias :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { name : String
        , arguments : List (Type TypeVariableFromContext)
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        }
    -> Maybe (Type TypeVariableFromContext)
typeConstructFullyExpandIfAlias context typeConstructToExpand =
    case context.declarationTypes |> FastDict.get typeConstructToExpand.moduleOrigin of
        Nothing ->
            Nothing

        Just aOriginModuleTypes ->
            case aOriginModuleTypes.typeAliases |> FastDict.get typeConstructToExpand.name of
                Nothing ->
                    Nothing

                Just originAliasDeclaration ->
                    let
                        substitutionsToApplyToOriginAliasType :
                            { parameterToVariable : FastDict.Dict String TypeVariableFromContext
                            , parameterToTypeNotVariable : FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
                            }
                        substitutionsToApplyToOriginAliasType =
                            listFoldl2From
                                parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty
                                originAliasDeclaration.parameters
                                typeConstructToExpand.arguments
                                (\parameterName argument soFar ->
                                    case argument of
                                        TypeVariable argumentVariable ->
                                            { parameterToVariable =
                                                soFar.parameterToVariable
                                                    |> FastDict.insert parameterName argumentVariable
                                            , parameterToTypeNotVariable = soFar.parameterToTypeNotVariable
                                            }

                                        TypeNotVariable argumentTypeNotVariable ->
                                            { parameterToVariable = soFar.parameterToVariable
                                            , parameterToTypeNotVariable =
                                                soFar.parameterToTypeNotVariable
                                                    |> FastDict.insert
                                                        ( rangeAsComparableEmpty, parameterName )
                                                        argumentTypeNotVariable
                                            }
                                )

                        aliasTypeWithVariableArgumentsFilledIn : Type TypeVariableFromContext
                        aliasTypeWithVariableArgumentsFilledIn =
                            originAliasDeclaration.type_
                                |> typeMapVariables
                                    (\parameterName ->
                                        case
                                            substitutionsToApplyToOriginAliasType.parameterToVariable
                                                |> FastDict.get parameterName
                                        of
                                            Just variable ->
                                                variable

                                            Nothing ->
                                                ( rangeAsComparableEmpty, parameterName )
                                    )
                    in
                    if
                        substitutionsToApplyToOriginAliasType.parameterToTypeNotVariable
                            |> FastDict.isEmpty
                    then
                        Just aliasTypeWithVariableArgumentsFilledIn

                    else
                        case
                            aliasTypeWithVariableArgumentsFilledIn
                                |> typeSubstituteVariableByNotVariable context
                                    substitutionsToApplyToOriginAliasType.parameterToTypeNotVariable
                        of
                            Ok typeAliasWithSomeVariablesSubstitutedByTypes ->
                                Just typeAliasWithSomeVariablesSubstitutedByTypes.type_

                            Err _ ->
                                Nothing


parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty :
    { parameterToVariable : FastDict.Dict String TypeVariableFromContext
    , parameterToTypeNotVariable : FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    }
parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty =
    { parameterToVariable = FastDict.empty
    , parameterToTypeNotVariable = FastDict.empty
    }


rangeAsComparableEmpty : RangeAsComparable
rangeAsComparableEmpty =
    ( ( 0, 0 ), ( 0, 0 ) )


{-| All you need to turn a generic type with variables
into a concrete type with all the info we've inferred already.

While variable types in context get passed down,
variable substitutions get passed all the way to the top and only get processed there.

-}
type alias VariableSubstitutions =
    { equivalentVariables :
        List EquivalentVariableSet
    , variableToType :
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    }


type alias EquivalentVariableSet =
    { constraint : Maybe TypeVariableConstraint
    , overarchingRangeAsComparable : RangeAsComparable
    , variables : FastSetFast TypeVariableFromContext
    }


variableSubstitutionsNone : VariableSubstitutions
variableSubstitutionsNone =
    { equivalentVariables = []
    , variableToType = FastDict.empty
    }


variableSubstitutionsMerge :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge context a b =
    -- IGNORE TCO
    if a.variableToType |> FastDict.isEmpty then
        case a.equivalentVariables of
            [] ->
                Ok b

            _ :: _ ->
                Result.map
                    (\abEquivalentVariables ->
                        { variableToType = b.variableToType
                        , equivalentVariables = abEquivalentVariables
                        }
                    )
                    (equivalentVariableSetMerge
                        a.equivalentVariables
                        b.equivalentVariables
                    )

    else if b.variableToType |> FastDict.isEmpty then
        case b.equivalentVariables of
            [] ->
                Ok a

            _ :: _ ->
                Result.map
                    (\abEquivalentVariables ->
                        { variableToType = a.variableToType
                        , equivalentVariables = abEquivalentVariables
                        }
                    )
                    (equivalentVariableSetMerge
                        a.equivalentVariables
                        b.equivalentVariables
                    )

    else
        FastDict.merge
            (\variable aType soFarOrError ->
                Result.map
                    (\soFar ->
                        { variableToType =
                            soFar.variableToType
                                |> FastDict.insert variable aType
                        , equivalentVariables =
                            soFar.equivalentVariables
                        }
                    )
                    soFarOrError
            )
            (\variable aType bType soFarOrError ->
                Result.andThen
                    (\soFar ->
                        Result.andThen
                            (\abTypesUnified ->
                                Result.andThen
                                    (\substitutionsWithAB ->
                                        case abTypesUnified.type_ of
                                            TypeVariable abUnifiedVariable ->
                                                Result.map
                                                    (\equivalentVariables ->
                                                        { equivalentVariables = equivalentVariables
                                                        , variableToType =
                                                            substitutionsWithAB.variableToType
                                                        }
                                                    )
                                                    (substitutionsWithAB.equivalentVariables
                                                        |> equivalentVariablesMergeWithSetOf2
                                                            variable
                                                            abUnifiedVariable
                                                    )

                                            TypeNotVariable abUnifiedNotVariable ->
                                                Ok
                                                    { equivalentVariables = substitutionsWithAB.equivalentVariables
                                                    , variableToType =
                                                        substitutionsWithAB.variableToType
                                                            |> FastDict.insert variable abUnifiedNotVariable
                                                    }
                                    )
                                    (variableSubstitutionsMerge context
                                        soFar
                                        abTypesUnified.substitutions
                                    )
                            )
                            (typeNotVariableUnify context aType bType)
                    )
                    soFarOrError
            )
            (\variable bType soFarOrError ->
                Result.map
                    (\soFar ->
                        { variableToType =
                            soFar.variableToType
                                |> FastDict.insert variable bType
                        , equivalentVariables =
                            soFar.equivalentVariables
                        }
                    )
                    soFarOrError
            )
            a.variableToType
            b.variableToType
            (Result.map
                (\abEquivalentVariables ->
                    { variableToType = FastDict.empty
                    , equivalentVariables = abEquivalentVariables
                    }
                )
                (equivalentVariableSetMerge
                    a.equivalentVariables
                    b.equivalentVariables
                )
            )


variableSubstitutionsMerge3 :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge3 context a b c =
    variableSubstitutionsMerge context a b
        |> Result.andThen
            (\abSubstitutions ->
                variableSubstitutionsMerge context
                    abSubstitutions
                    c
            )


variableSubstitutionsMerge4 :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge4 context a b c d =
    variableSubstitutionsMerge3
        context
        a
        b
        c
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    context
                    abcSubstitutions
                    d
            )


equivalentVariablesMergeWithSetOf2 :
    TypeVariableFromContext
    -> TypeVariableFromContext
    -> List EquivalentVariableSet
    -> Result String (List EquivalentVariableSet)
equivalentVariablesMergeWithSetOf2 aEquivalentVariable bEquivalentVariable equivalentVariables =
    if typeVariableFromContextEquals aEquivalentVariable bEquivalentVariable then
        Ok equivalentVariables

    else
        equivalentVariablesMergeWithSetOf2Into []
            aEquivalentVariable
            bEquivalentVariable
            equivalentVariables
            equivalentVariables


equivalentVariablesMergeWithSetOf2Into :
    List EquivalentVariableSet
    -> TypeVariableFromContext
    -> TypeVariableFromContext
    -> List EquivalentVariableSet
    -> List EquivalentVariableSet
    -> Result String (List EquivalentVariableSet)
equivalentVariablesMergeWithSetOf2Into soFar aEquivalentVariable bEquivalentVariable equivalentVariables originalFullEquivalentVariables =
    case equivalentVariables of
        [] ->
            let
                ( aEquivalentVariableUseRangeAsComparable, aEquivalentVariableName ) =
                    aEquivalentVariable

                ( bEquivalentVariableUseRangeAsComparable, bEquivalentVariableName ) =
                    bEquivalentVariable
            in
            Result.map
                (\abConstraint ->
                    { variables =
                        FastDict.singleton aEquivalentVariable ()
                            |> FastDict.insert bEquivalentVariable ()
                    , constraint = abConstraint
                    , overarchingRangeAsComparable =
                        rangeAsComparableOverarching
                            aEquivalentVariableUseRangeAsComparable
                            bEquivalentVariableUseRangeAsComparable
                    }
                        :: soFar
                )
                (maybeTypeVariableConstraintMerge
                    (aEquivalentVariableName |> typeVariableConstraint)
                    (bEquivalentVariableName |> typeVariableConstraint)
                )

        equivalentVariablesSet0 :: equivalentVariablesSet1Up ->
            if equivalentVariablesSet0.variables |> FastDict.member aEquivalentVariable then
                let
                    ( bEquivalentVariableUseRangeAsComparable, bEquivalentVariableName ) =
                        bEquivalentVariable
                in
                Result.map
                    (\unifiedConstraint ->
                        { variables =
                            equivalentVariablesSet0.variables
                                |> FastDict.insert bEquivalentVariable ()
                        , constraint = unifiedConstraint
                        , overarchingRangeAsComparable =
                            rangeAsComparableOverarching
                                equivalentVariablesSet0.overarchingRangeAsComparable
                                bEquivalentVariableUseRangeAsComparable
                        }
                            :: listAppendFastButInReverseOrder
                                soFar
                                equivalentVariablesSet1Up
                    )
                    (maybeTypeVariableConstraintMerge
                        equivalentVariablesSet0.constraint
                        (bEquivalentVariableName |> typeVariableConstraint)
                    )

            else if equivalentVariablesSet0.variables |> FastDict.member bEquivalentVariable then
                let
                    ( aEquivalentVariableUseRangeAsComparable, aEquivalentVariableName ) =
                        aEquivalentVariable
                in
                Result.map
                    (\unifiedConstraint ->
                        { variables =
                            equivalentVariablesSet0.variables
                                |> FastDict.insert aEquivalentVariable ()
                        , constraint = unifiedConstraint
                        , overarchingRangeAsComparable =
                            rangeAsComparableOverarching
                                equivalentVariablesSet0.overarchingRangeAsComparable
                                aEquivalentVariableUseRangeAsComparable
                        }
                            :: listAppendFastButInReverseOrder
                                soFar
                                equivalentVariablesSet1Up
                    )
                    (maybeTypeVariableConstraintMerge
                        equivalentVariablesSet0.constraint
                        (aEquivalentVariableName |> typeVariableConstraint)
                    )

            else
                equivalentVariablesMergeWithSetOf2Into
                    (equivalentVariablesSet0 :: soFar)
                    aEquivalentVariable
                    bEquivalentVariable
                    equivalentVariablesSet1Up
                    originalFullEquivalentVariables


listAppendFastButInReverseOrder : List a -> List a -> List a
listAppendFastButInReverseOrder aList bList =
    case aList of
        [] ->
            bList

        aHead :: aTail ->
            listAppendFastButInReverseOrder aTail (aHead :: bList)


equivalentVariableSetMerge :
    List EquivalentVariableSet
    -> List EquivalentVariableSet
    -> Result String (List EquivalentVariableSet)
equivalentVariableSetMerge a b =
    case a of
        [] ->
            Ok b

        _ :: _ ->
            case b of
                [] ->
                    Ok a

                _ :: _ ->
                    Result.map
                        (\mergedIntoA ->
                            listAppendFastButInReverseOrder
                                mergedIntoA.sets
                                mergedIntoA.bRemaining
                        )
                        (a
                            |> listFoldlWhileOkFrom
                                { sets = [], bRemaining = b }
                                (\aEquivalentVariableSet soFar ->
                                    case
                                        soFar.bRemaining
                                            |> listMapAndFirstJustAndRemainingAnyOrder
                                                (\bEquivalentVariableSet ->
                                                    if
                                                        fastSetShareElements
                                                            aEquivalentVariableSet.variables
                                                            bEquivalentVariableSet.variables
                                                    then
                                                        Just bEquivalentVariableSet

                                                    else
                                                        Nothing
                                                )
                                    of
                                        Nothing ->
                                            Ok
                                                { sets = aEquivalentVariableSet :: soFar.sets
                                                , bRemaining = soFar.bRemaining
                                                }

                                        Just bEquivalentVariableSetAndRemaining ->
                                            Result.map
                                                (\unifiedConstraint ->
                                                    { sets =
                                                        { variables =
                                                            FastDict.union
                                                                aEquivalentVariableSet.variables
                                                                bEquivalentVariableSetAndRemaining.value.variables
                                                        , constraint = unifiedConstraint
                                                        , overarchingRangeAsComparable =
                                                            rangeAsComparableOverarching
                                                                aEquivalentVariableSet.overarchingRangeAsComparable
                                                                bEquivalentVariableSetAndRemaining.value.overarchingRangeAsComparable
                                                        }
                                                            :: soFar.sets
                                                    , bRemaining = bEquivalentVariableSetAndRemaining.remaining
                                                    }
                                                )
                                                (maybeTypeVariableConstraintMerge
                                                    aEquivalentVariableSet.constraint
                                                    bEquivalentVariableSetAndRemaining.value.constraint
                                                )
                                )
                        )


fastSetShareElements : FastSetFast comparable -> FastSetFast comparable -> Bool
fastSetShareElements a b =
    a |> fastSetFastAny (\aKey -> b |> FastDict.member aKey)


listMapAndFirstJustAndRemainingAnyOrder :
    (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAnyOrder elementToMaybe list =
    listMapAndFirstJustAndRemainingAndOrderWithBefore [] elementToMaybe list


listMapAndFirstJustAndRemainingAndOrderWithBefore :
    List a
    -> (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAndOrderWithBefore elementsBeforeReverse elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybe of
                Just headValue ->
                    Just
                        { value = headValue
                        , remaining =
                            listAppendFastButInReverseOrder
                                elementsBeforeReverse
                                tail
                        }

                Nothing ->
                    listMapAndFirstJustAndRemainingAndOrderWithBefore
                        (head :: elementsBeforeReverse)
                        elementToMaybe
                        tail


listFilledMapAndTypesUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> (a -> Type TypeVariableFromContext)
    -> ( a, List a )
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
listFilledMapAndTypesUnify context elementToType ( head, tail ) =
    tail
        |> listFoldlWhileOkFrom
            { type_ = head |> elementToType
            , substitutions = variableSubstitutionsNone
            }
            (\element soFar ->
                Result.andThen
                    (\soFarTypeUnifiedWithElement ->
                        Result.map
                            (\substitutionsSoFarWithElement ->
                                { type_ = soFarTypeUnifiedWithElement.type_
                                , substitutions = substitutionsSoFarWithElement
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                soFarTypeUnifiedWithElement.substitutions
                            )
                    )
                    (typeUnify context
                        soFar.type_
                        (element |> elementToType)
                    )
            )


typeUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnify context a b =
    case a of
        TypeNotVariable aTypeNotVariable ->
            case b of
                TypeVariable bVariableName ->
                    Result.map
                        (\substitutions ->
                            { type_ = a
                            , substitutions = substitutions
                            }
                        )
                        (variableSubstitutionsFromVariableToTypeNotVariableOrError
                            context.declarationTypes
                            bVariableName
                            aTypeNotVariable
                        )

                TypeNotVariable bTypeNotVariable ->
                    typeNotVariableUnify context
                        aTypeNotVariable
                        bTypeNotVariable

        TypeVariable aVariable ->
            case b of
                TypeVariable bVariable ->
                    Result.map
                        (\abEquivalentVariablesSubstitutions ->
                            { type_ = a
                            , substitutions =
                                abEquivalentVariablesSubstitutions
                            }
                        )
                        (variableSubstitutionsFrom2EquivalentVariables
                            aVariable
                            bVariable
                        )

                TypeNotVariable bTypeNotVariable ->
                    Result.map
                        (\substitutions ->
                            { type_ = b
                            , substitutions = substitutions
                            }
                        )
                        (variableSubstitutionsFromVariableToTypeNotVariableOrError
                            context.declarationTypes
                            aVariable
                            bTypeNotVariable
                        )


typeNotVariableUnifyWithType :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnifyWithType context aTypeNotVariable b =
    case b of
        TypeVariable bVariableName ->
            Result.map
                (\substitutions ->
                    { type_ = TypeNotVariable aTypeNotVariable
                    , substitutions = substitutions
                    }
                )
                (variableSubstitutionsFromVariableToTypeNotVariableOrError
                    context.declarationTypes
                    bVariableName
                    aTypeNotVariable
                )

        TypeNotVariable bTypeNotVariable ->
            typeNotVariableUnify context
                aTypeNotVariable
                bTypeNotVariable


typeUnifyWithTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Type TypeVariableFromContext
    ->
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnifyWithTypeConstruct context a bTypeConstruct =
    case a of
        TypeNotVariable aTypeNotVariable ->
            typeNotVariableUnifyWithTypeConstruct
                context
                aTypeNotVariable
                bTypeConstruct

        TypeVariable aVariable ->
            let
                bTypeNotVariable : TypeNotVariable TypeVariableFromContext
                bTypeNotVariable =
                    TypeConstruct bTypeConstruct
            in
            Result.map
                (\substitutions ->
                    { type_ = TypeNotVariable bTypeNotVariable
                    , substitutions = substitutions
                    }
                )
                (variableSubstitutionsFromVariableToTypeNotVariableOrError
                    context.declarationTypes
                    aVariable
                    bTypeNotVariable
                )


typeNotVariableUnifyWithTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable TypeVariableFromContext
    ->
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnifyWithTypeConstruct context aTypeNotVariable bTypeConstruct =
    case aTypeNotVariable of
        TypeConstruct aTypeConstruct ->
            if
                (bTypeConstruct.moduleOrigin == aTypeConstruct.moduleOrigin)
                    && (bTypeConstruct.name == aTypeConstruct.name)
            then
                Result.map
                    (\argumentsABUnified ->
                        { type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = bTypeConstruct.moduleOrigin
                                    , name = bTypeConstruct.name
                                    , arguments =
                                        argumentsABUnified.argumentsReverse
                                            |> List.reverse
                                    }
                                )
                        , substitutions = argumentsABUnified.substitutions
                        }
                    )
                    (listFoldl2WhileOkFrom
                        argumentsReverseListEmptySubstitutionsNone
                        bTypeConstruct.arguments
                        aTypeConstruct.arguments
                        (\aArgument bArgument soFar ->
                            Result.andThen
                                (\argumentTypeUnifiedAndSubstitutions ->
                                    Result.map
                                        (\substitutionsWithArgument ->
                                            { argumentsReverse =
                                                argumentTypeUnifiedAndSubstitutions.type_
                                                    :: soFar.argumentsReverse
                                            , substitutions =
                                                substitutionsWithArgument
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            argumentTypeUnifiedAndSubstitutions.substitutions
                                        )
                                )
                                (typeUnify context aArgument bArgument)
                        )
                    )

            else
                case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                    Just result ->
                        result

                    Nothing ->
                        case typeUnifyWithTryToExpandTypeConstruct context aTypeConstruct (TypeConstruct bTypeConstruct) of
                            Just result ->
                                result

                            Nothing ->
                                Err
                                    ("("
                                        ++ (context.range |> rangeToInfoString)
                                        ++ ") "
                                        ++ "choice type "
                                        ++ qualifiedToString
                                            { qualification = bTypeConstruct.moduleOrigin
                                            , name = bTypeConstruct.name
                                            }
                                        ++ " cannot be unified be with a choice type with a different name: "
                                        ++ (TypeConstruct aTypeConstruct |> typeNotVariableToInfoString)
                                    )

        TypeUnit ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeTuple _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeTriple _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeRecord _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeRecordExtension _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeFunction _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )


variableSubstitutionsFromVariableToTypeNotVariableOrError :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    -> Result String VariableSubstitutions
variableSubstitutionsFromVariableToTypeNotVariableOrError declarationTypes replacementVariable replacementTypeNotVariable =
    if replacementTypeNotVariable |> typeNotVariableContainsVariable replacementVariable then
        if replacementTypeNotVariable |> typeNotVariableIsEquivalentToTypeVariable declarationTypes then
            -- is ok when type is an identity type alias
            okVariableSubstitutionsNone

        else
            Err
                ("cannot unify the variable "
                    ++ (replacementVariable |> typeVariableFromContextToInfoString)
                    ++ " with the type "
                    ++ (replacementTypeNotVariable |> typeNotVariableToInfoString)
                    ++ " because that type contains the type variable itself."
                )

    else
        Ok
            { equivalentVariables = []
            , variableToType =
                FastDict.singleton replacementVariable
                    replacementTypeNotVariable
            }


okVariableSubstitutionsNone : Result error_ VariableSubstitutions
okVariableSubstitutionsNone =
    Ok variableSubstitutionsNone


typeNotVariableUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnify context a bNotVariable =
    case a of
        TypeUnit ->
            case bNotVariable of
                TypeUnit ->
                    okTypeUnitSubstitutionsNone

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "unit (`()`) cannot be unified with types other than unit"
                                )

                TypeTuple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeTriple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

        TypeConstruct aTypeConstruct ->
            typeNotVariableUnifyWithTypeConstruct context
                bNotVariable
                aTypeConstruct

        TypeTuple aTuple ->
            case bNotVariable of
                TypeTuple bTuple ->
                    resultAndThen2
                        (\part0ABUnified part1ABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0ABUnified.type_
                                                , part1 = part1ABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge context
                                    part0ABUnified.substitutions
                                    part1ABUnified.substitutions
                                )
                        )
                        (typeUnify context aTuple.part0 bTuple.part0)
                        (typeUnify context aTuple.part1 bTuple.part1)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                                )

                TypeTriple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

        TypeTriple aTriple ->
            case bNotVariable of
                TypeTriple bTriple ->
                    resultAndThen3
                        (\part0ABUnified part1ABUnified part2ABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0ABUnified.type_
                                                , part1 = part1ABUnified.type_
                                                , part2 = part2ABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge3 context
                                    part0ABUnified.substitutions
                                    part1ABUnified.substitutions
                                    part2ABUnified.substitutions
                                )
                        )
                        (typeUnify context aTriple.part0 bTriple.part0)
                        (typeUnify context aTriple.part1 bTriple.part1)
                        (typeUnify context aTriple.part1 bTriple.part1)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                                )

                TypeTuple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

        TypeRecord aRecord ->
            case bNotVariable of
                TypeRecord bRecord ->
                    typeRecordUnify context aRecord bRecord

                TypeRecordExtension bRecordExtension ->
                    typeRecordExtensionUnifyWithRecord context
                        bRecordExtension
                        aRecord

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                        )

                TypeTriple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                        )

                TypeFunction bTypeFunction ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                        )

        TypeRecordExtension aRecordExtension ->
            case bNotVariable of
                TypeRecord bRecord ->
                    typeRecordExtensionUnifyWithRecord context
                        aRecordExtension
                        bRecord

                TypeRecordExtension bRecordExtension ->
                    typeRecordExtensionUnifyWithRecordExtension context
                        aRecordExtension
                        bRecordExtension

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                        )

                TypeTriple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                        )

                TypeFunction bTypeFunction ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                        )

        TypeFunction aFunction ->
            case bNotVariable of
                TypeFunction bFunction ->
                    resultAndThen2
                        (\inputABUnified outputABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = inputABUnified.type_
                                                , output = outputABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge context
                                    inputABUnified.substitutions
                                    outputABUnified.substitutions
                                )
                        )
                        (typeUnify context aFunction.input bFunction.input)
                        (typeUnify context aFunction.output bFunction.output)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bTypeTuple ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeTuple bTypeTuple |> typeNotVariableToInfoString)
                        )

                TypeTriple bTypeTriple ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeTriple bTypeTriple |> typeNotVariableToInfoString)
                        )

                TypeRecord bTypeRecord ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeRecord bTypeRecord |> typeNotVariableToInfoString)
                        )

                TypeRecordExtension bTypeRecordExtension ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeRecordExtension bTypeRecordExtension |> typeNotVariableToInfoString)
                        )


argumentsReverseListEmptySubstitutionsNone :
    { argumentsReverse : List argument_
    , substitutions : VariableSubstitutions
    }
argumentsReverseListEmptySubstitutionsNone =
    { argumentsReverse = []
    , substitutions = variableSubstitutionsNone
    }


okTypeUnitSubstitutionsNone : Result error_ { type_ : Type TypeVariableFromContext, substitutions : VariableSubstitutions }
okTypeUnitSubstitutionsNone =
    Ok
        { type_ = typeUnit
        , substitutions = variableSubstitutionsNone
        }


typeUnifyWithTryToExpandTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type TypeVariableFromContext)
        }
    -> TypeNotVariable TypeVariableFromContext
    ->
        Maybe
            (Result
                String
                { substitutions : VariableSubstitutions
                , type_ : Type TypeVariableFromContext
                }
            )
typeUnifyWithTryToExpandTypeConstruct context aTypeConstructToExpand b =
    case context.declarationTypes |> FastDict.get aTypeConstructToExpand.moduleOrigin of
        Nothing ->
            Just
                (Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "could not find declaration types in the origin module of the type construct "
                        ++ qualifiedToString
                            { qualification = aTypeConstructToExpand.moduleOrigin
                            , name = aTypeConstructToExpand.name
                            }
                    )
                )

        Just aOriginModuleTypes ->
            case aOriginModuleTypes.typeAliases |> FastDict.get aTypeConstructToExpand.name of
                Nothing ->
                    Nothing

                Just aOriginAliasDeclaration ->
                    let
                        prefix : String
                        prefix =
                            "parameter"
                                ++ (aTypeConstructToExpand.moduleOrigin |> String.concat)
                                ++ aTypeConstructToExpand.name
                    in
                    Result.andThen
                        (\constructedAliasedType ->
                            Result.andThen
                                (\constructedAliasedTypeUnifiedWithB ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { type_ = constructedAliasedTypeUnifiedWithB.type_
                                            , substitutions = fullSubstitutions
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            constructedAliasedTypeUnifiedWithB.substitutions
                                            constructedAliasedType.substitutions
                                        )
                                )
                                (typeNotVariableUnifyWithType context
                                    b
                                    constructedAliasedType.type_
                                )
                        )
                        (listFoldl2WhileOkFrom
                            { type_ =
                                aOriginAliasDeclaration.type_
                                    |> typeMapVariables
                                        (\aliasVariable ->
                                            ( context.range |> rangeToAsComparable
                                            , prefix ++ (aliasVariable |> stringFirstCharToUpper)
                                            )
                                        )
                            , substitutions = variableSubstitutionsNone
                            }
                            aOriginAliasDeclaration.parameters
                            aTypeConstructToExpand.arguments
                            (\parameterName argument constructedAliasedTypeSoFar ->
                                Result.andThen
                                    (\afterSubstitution ->
                                        Result.map
                                            (\substitutionsSoFarAndAfterSubstitution ->
                                                { type_ = afterSubstitution.type_
                                                , substitutions = substitutionsSoFarAndAfterSubstitution
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                constructedAliasedTypeSoFar.substitutions
                                                afterSubstitution.substitutions
                                            )
                                    )
                                    (constructedAliasedTypeSoFar.type_
                                        |> typeSubstituteVariable context
                                            { variable =
                                                ( context.range |> rangeToAsComparable
                                                , prefix ++ (parameterName |> stringFirstCharToUpper)
                                                )
                                            , type_ = argument
                                            }
                                    )
                            )
                        )
                        |> Just


typeRecordUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordUnify context aFields bFields =
    Result.map
        (\fieldsUnified ->
            { type_ =
                TypeNotVariable
                    (TypeRecord fieldsUnified.fieldsUnified)
            , substitutions = fieldsUnified.substitutions
            }
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            aFields
            bFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecord :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecord context recordExtension recordFields =
    Result.andThen
        (\fieldsUnified ->
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeNotVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
                (variableSubstitutionsMerge context
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            recordExtension.recordVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record extension with the field `"
                        ++ name
                        ++ "` cannot be unified with a record that does not have this field. The record extension is `"
                        ++ (TypeRecordExtension recordExtension |> typeNotVariableToInfoString)
                        ++ "` and the record is `"
                        ++ (TypeRecord recordFields |> typeNotVariableToInfoString)
                        ++ "`"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            recordExtension.fields
            recordFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecordExtension :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecordExtension context aRecordExtension bRecordExtension =
    Result.andThen
        (\fieldsUnified ->
            let
                ( aRecordExtensionRecordVariableUsesRangeAsComparable, aRecordExtensionRecordVariableName ) =
                    aRecordExtension.recordVariable

                ( bRecordExtensionRecordVariableUsesRangeAsComparable, _ ) =
                    bRecordExtension.recordVariable

                newBaseVariable : TypeVariableFromContext
                newBaseVariable =
                    ( rangeAsComparableOverarching
                        aRecordExtensionRecordVariableUsesRangeAsComparable
                        bRecordExtensionRecordVariableUsesRangeAsComparable
                    , aRecordExtensionRecordVariableName
                    )

                bVariableReplacementFields : FastDict.Dict String (Type TypeVariableFromContext)
                bVariableReplacementFields =
                    FastDict.diff
                        aRecordExtension.fields
                        bRecordExtension.fields

                aVariableReplacementFields : FastDict.Dict String (Type TypeVariableFromContext)
                aVariableReplacementFields =
                    FastDict.diff
                        bRecordExtension.fields
                        aRecordExtension.fields
            in
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeNotVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields = fieldsUnified.fieldsUnified
                                }
                            )
                    }
                )
                (resultAndThen2
                    (\aRecordVariableSubstitutions bRecordVariableSubstitutions ->
                        variableSubstitutionsMerge3 context
                            fieldsUnified.substitutions
                            aRecordVariableSubstitutions
                            bRecordVariableSubstitutions
                    )
                    (variableSubstitutionsFromVariableToType
                        aRecordExtension.recordVariable
                        (if aVariableReplacementFields |> FastDict.isEmpty then
                            TypeVariable newBaseVariable

                         else
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields = aVariableReplacementFields
                                    }
                                )
                        )
                    )
                    (variableSubstitutionsFromVariableToType
                        bRecordExtension.recordVariable
                        (if bVariableReplacementFields |> FastDict.isEmpty then
                            TypeVariable newBaseVariable

                         else
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields = bVariableReplacementFields
                                    }
                                )
                        )
                    )
                )
        )
        (FastDict.merge
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            aRecordExtension.fields
            bRecordExtension.fields
            okFieldsUnifiedEmptySubstitutionsNone
        )


okFieldsUnifiedEmptySubstitutionsNone :
    Result
        error_
        { fieldsUnified : FastDict.Dict String (Type TypeVariableFromContext)
        , substitutions : VariableSubstitutions
        }
okFieldsUnifiedEmptySubstitutionsNone =
    Ok
        { fieldsUnified = FastDict.empty
        , substitutions = variableSubstitutionsNone
        }


{-| A part in the syntax tree with an attached

  - [range](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Range#Range) in the source
  - global [`Type`](#Type): concretely inferred,
    influenced by other branches and value/function (let) declaration type annotations

-}
type alias TypedNode value type_ =
    { range : Elm.Syntax.Range.Range
    , value : value
    , type_ : type_
    }


{-| Like [`Elm.Syntax.Expression.Expression`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Expression)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Expression type_
    = ExpressionUnit
    | ExpressionInteger
        { base : Base10Or16
        , value : Int
        }
    | ExpressionFloat Float
    | ExpressionString String
    | ExpressionChar Char
    | ExpressionReference
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    | ExpressionOperatorFunction
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , symbol : String
        }
    | ExpressionRecordAccessFunction String
    | ExpressionNegation (TypedNode (Expression type_) type_)
    | ExpressionParenthesized (TypedNode (Expression type_) type_)
    | ExpressionTuple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        }
    | ExpressionTriple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        , part2 : TypedNode (Expression type_) type_
        }
    | ExpressionRecordAccess
        { record : TypedNode (Expression type_) type_
        , fieldNameRange : Elm.Syntax.Range.Range
        , fieldName : String
        }
    | ExpressionInfixOperation
        { operator :
            { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
            , symbol : String
            , type_ : type_
            }
        , left : TypedNode (Expression type_) type_
        , right : TypedNode (Expression type_) type_
        }
    | ExpressionIfThenElse
        { condition : TypedNode (Expression type_) type_
        , onTrue : TypedNode (Expression type_) type_
        , onFalse : TypedNode (Expression type_) type_
        }
    | ExpressionList (List (TypedNode (Expression type_) type_))
    | ExpressionCall
        { called : TypedNode (Expression type_) type_
        , argument0 : TypedNode (Expression type_) type_
        , argument1Up : List (TypedNode (Expression type_) type_)
        }
    | ExpressionRecord
        (List
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        )
    | ExpressionRecordUpdate
        { recordVariable :
            TypedNode
                { moduleOrigin :
                    -- `[]` for current module
                    Elm.Syntax.ModuleName.ModuleName
                , name : String
                }
                type_
        , field0 :
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        , field1Up :
            List
                { range : Elm.Syntax.Range.Range
                , name : String
                , nameRange : Elm.Syntax.Range.Range
                , value : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLambda
        { parameter0 : TypedNode (Pattern type_) type_
        , parameter1Up : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionCaseOf
        { matchedExpression : TypedNode (Expression type_) type_
        , case0 :
            { pattern : TypedNode (Pattern type_) type_
            , result : TypedNode (Expression type_) type_
            }
        , case1Up :
            List
                { pattern : TypedNode (Pattern type_) type_
                , result : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLetIn
        { declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration type_
            }
        , declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration type_
                }
        , result : TypedNode (Expression type_) type_
        }


{-| Like [`Elm.Syntax.Expression.LetDeclaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#LetDeclaration)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type LetDeclaration type_
    = LetDestructuring
        { pattern : TypedNode (Pattern type_) type_
        , expression : TypedNode (Expression type_) type_
        }
    | LetValueOrFunctionDeclaration
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType :
                    -- variables names in here might not correspond
                    -- with those in .type_
                    Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        , type_ : type_
        }


{-| Like [`Elm.Syntax.Pattern.Pattern`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern#Pattern)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Pattern type_
    = PatternIgnored
    | PatternVariable String
    | PatternParenthesized (TypedNode (Pattern type_) type_)
    | PatternAs
        { pattern : TypedNode (Pattern type_) type_
        , variable : TypedNode String type_
        }
    | PatternUnit
    | PatternChar Char
    | PatternString String
    | PatternInt { base : Base10Or16, value : Int }
    | PatternTuple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        }
    | PatternTriple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        , part2 : TypedNode (Pattern type_) type_
        }
    | PatternRecord (List (TypedNode String type_))
    | PatternListCons
        { head : TypedNode (Pattern type_) type_
        , tail : TypedNode (Pattern type_) type_
        }
    | PatternListExact (List (TypedNode (Pattern type_) type_))
    | PatternVariant
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        , values : List (TypedNode (Pattern type_) type_)
        }


{-| Either decimal or hexadecimal.
Used by [`PatternInt`](#Pattern) and [`ExpressionInteger`](#Expression)
-}
type Base10Or16
    = Base10
    | Base16


typeBasicsFloat : Type variable_
typeBasicsFloat =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Float"
            , arguments = []
            }
        )


typeBasicsBool : Type variable_
typeBasicsBool =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Bool"
            , arguments = []
            }
        )


typeConstructBasicsBool :
    { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
    , name : String
    , arguments : List (Type variable_)
    }
typeConstructBasicsBool =
    { moduleOrigin = [ "Basics" ]
    , name = "Bool"
    , arguments = []
    }


typeBasicsInt : Type variable_
typeBasicsInt =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Int"
            , arguments = []
            }
        )


typeStringString : Type variable_
typeStringString =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "String" ]
            , name = "String"
            , arguments = []
            }
        )


typeCharChar : Type variable_
typeCharChar =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Char" ]
            , name = "Char"
            , arguments = []
            }
        )


typeListList : Type variable -> Type variable
typeListList a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameList
            , name = "List"
            , arguments = [ a ]
            }
        )


typeParserParser : Type variable -> Type variable
typeParserParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameParser
            , name = "Parser"
            , arguments = [ a ]
            }
        )


typeParserAdvancedParser : Type variable -> Type variable -> Type variable -> Type variable
typeParserAdvancedParser context problem value =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameParserAdvanced
            , name = "Parser"
            , arguments = [ context, problem, value ]
            }
        )


typeUrlParserParser : Type variable -> Type variable -> Type variable
typeUrlParserParser a b =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameUrlParser
            , name = "Parser"
            , arguments = [ a, b ]
            }
        )


typeUrlParserQueryParser : Type variable -> Type variable
typeUrlParserQueryParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameUrlParserQuery
            , name = "Parser"
            , arguments = [ a ]
            }
        )


patternTypedNodeIntroducedVariables :
    TypedNode (Pattern type_) type_
    -> FastDict.Dict String type_
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            FastDict.empty

        PatternIgnored ->
            FastDict.empty

        PatternInt _ ->
            FastDict.empty

        PatternString _ ->
            FastDict.empty

        PatternChar _ ->
            FastDict.empty

        PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        PatternRecord fieldVariables ->
            fieldVariables
                |> listMapToFastDict
                    (\fieldVariable ->
                        { key = fieldVariable.value, value = fieldVariable.type_ }
                    )

        PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern |> patternTypedNodeIntroducedVariables)

        PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        PatternListCons listCons ->
            FastDict.union
                (listCons.head |> patternTypedNodeIntroducedVariables)
                (listCons.tail |> patternTypedNodeIntroducedVariables)

        PatternTuple parts ->
            FastDict.union
                (parts.part0 |> patternTypedNodeIntroducedVariables)
                (parts.part1 |> patternTypedNodeIntroducedVariables)

        PatternTriple parts ->
            (parts.part0 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part1 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part2 |> patternTypedNodeIntroducedVariables)

        PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables

        PatternVariant variant ->
            variant.values
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables


patternTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypeInfer context (Elm.Syntax.Node.Node fullRange pattern) =
    -- IGNORE TCO
    case pattern of
        Elm.Syntax.Pattern.FloatPattern _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "float patterns are invalid syntax"
                )

        Elm.Syntax.Pattern.AllPattern ->
            Ok
                { range = fullRange
                , value = PatternIgnored
                , type_ = TypeVariable ( fullRange |> rangeToAsComparable, "ignored" )
                }

        Elm.Syntax.Pattern.UnitPattern ->
            Ok
                { range = fullRange
                , value = PatternUnit
                , type_ = typeUnit
                }

        Elm.Syntax.Pattern.CharPattern charValue ->
            Ok
                { range = fullRange
                , value = PatternChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Pattern.IntPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base10, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.HexPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base16, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.StringPattern stringValue ->
            Ok
                { range = fullRange
                , value = PatternString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Pattern.VarPattern variableName ->
            Ok
                { range = fullRange
                , value = PatternVariable variableName
                , type_ = TypeVariable ( fullRange |> rangeToAsComparable, variableName )
                }

        Elm.Syntax.Pattern.ParenthesizedPattern parenthesizedInParens ->
            Result.map
                (\inParens ->
                    { range = fullRange
                    , value = PatternParenthesized inParens
                    , type_ = inParens.type_
                    }
                )
                (parenthesizedInParens
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.AsPattern innerPatternNode (Elm.Syntax.Node.Node variableNameRange variableName) ->
            Result.map
                (\inner ->
                    { range = fullRange
                    , value =
                        PatternAs
                            { pattern = inner
                            , variable =
                                { value = variableName
                                , range = variableNameRange
                                , type_ = inner.type_
                                }
                            }
                    , type_ = inner.type_
                    }
                )
                (innerPatternNode
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.TuplePattern parts ->
            case parts of
                [] ->
                    -- should be handled by UnitPattern
                    Ok
                        { range = fullRange
                        , value = PatternUnit
                        , type_ = typeUnit
                        }

                [ parenthesizedInParens ] ->
                    -- should be handled by ParenthesizedPattern
                    Result.map
                        (\inParens ->
                            { range = fullRange
                            , value = PatternParenthesized inParens
                            , type_ = inParens.type_
                            }
                        )
                        (parenthesizedInParens
                            |> patternTypeInfer context
                        )

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            { range = fullRange
                            , value =
                                PatternTuple
                                    { part0 = part0
                                    , part1 = part1
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)

                [ tuplePart0, tuplePart1, tuplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            { range = fullRange
                            , value =
                                PatternTriple
                                    { part0 = part0
                                    , part1 = part1
                                    , part2 = part2
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        , part2 = part2.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)
                        (tuplePart2 |> patternTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "too many tuple parts"
                        )

        Elm.Syntax.Pattern.RecordPattern recordFields ->
            let
                fieldTypedNodes : List (TypedNode String (Type TypeVariableFromContext))
                fieldTypedNodes =
                    recordFields
                        |> List.map
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) ->
                                { range = fieldRange
                                , value = fieldName
                                , type_ =
                                    TypeVariable
                                        ( fieldRange |> rangeToAsComparable
                                        , fieldName
                                        )
                                }
                            )
            in
            Ok
                { range = fullRange
                , value = PatternRecord fieldTypedNodes
                , type_ =
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable =
                                ( fullRange |> rangeToAsComparable, "record" )
                            , fields =
                                fieldTypedNodes
                                    |> listMapToFastDict
                                        (\fieldVariable ->
                                            { key = fieldVariable.value
                                            , value = fieldVariable.type_
                                            }
                                        )
                            }
                        )
                }

        Elm.Syntax.Pattern.UnConsPattern headNode tailNode ->
            resultAndThen2
                (\headInferred tailInferred ->
                    Result.andThen
                        (\fullListTypeUnified ->
                            Result.map2
                                (\headAfterUnification tailAfterUnification ->
                                    { range = fullRange
                                    , value =
                                        PatternListCons
                                            { head = headAfterUnification
                                            , tail = tailAfterUnification
                                            }
                                    , type_ = fullListTypeUnified.type_
                                    }
                                )
                                (headInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                                (tailInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                        )
                        (typeUnifyWithTypeConstruct
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                            tailInferred.type_
                            { moduleOrigin = moduleNameList
                            , name = "List"
                            , arguments = [ headInferred.type_ ]
                            }
                        )
                )
                (headNode |> patternTypeInfer context)
                (tailNode |> patternTypeInfer context)

        Elm.Syntax.Pattern.ListPattern elementNodes ->
            case elementNodes of
                [] ->
                    Ok
                        { range = fullRange
                        , value = patternListExactEmpty
                        , type_ =
                            typeListList
                                (TypeVariable ( fullRange |> rangeToAsComparable, "element" ))
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailInferredNodes ->
                            Result.andThen
                                (\unifiedElementType ->
                                    Result.map2
                                        (\headInferredAfterUnification tailInferredAfterUnification ->
                                            { range = fullRange
                                            , value =
                                                PatternListExact
                                                    (headInferredAfterUnification :: tailInferredAfterUnification)
                                            , type_ =
                                                typeListList unifiedElementType.type_
                                            }
                                        )
                                        (headInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                unifiedElementType.substitutions
                                        )
                                        (tailInferredNodes
                                            |> listFoldrWhileOkFrom []
                                                (\tailElementInferred tailAfterUnificationSoFar ->
                                                    Result.map
                                                        (\tailElementAfterUnification ->
                                                            tailElementAfterUnification
                                                                :: tailAfterUnificationSoFar
                                                        )
                                                        (tailElementInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                unifiedElementType.substitutions
                                                        )
                                                )
                                        )
                                )
                                (( headInferred, tailInferredNodes )
                                    |> listFilledMapAndTypesUnify
                                        { declarationTypes = context.declarationTypes
                                        , range = fullRange
                                        }
                                        .type_
                                )
                        )
                        (head |> patternTypeInfer context)
                        (tail
                            |> listFoldrWhileOkFrom
                                []
                                (\elementNode soFar ->
                                    Result.map
                                        (\elementInferred ->
                                            elementInferred :: soFar
                                        )
                                        (elementNode |> patternTypeInfer context)
                                )
                        )

        Elm.Syntax.Pattern.NamedPattern qualified values ->
            let
                moduleOriginInfoOrError :
                    Result
                        String
                        { name : Elm.Syntax.ModuleName.ModuleName
                        , declarationTypes : ModuleTypes
                        }
                moduleOriginInfoOrError =
                    case context.moduleOriginLookup.references |> FastDict.get ( qualified.moduleName, qualified.name ) of
                        Nothing ->
                            Err
                                ("("
                                    ++ (fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no module origin found for the pattern variant "
                                    ++ qualifiedToString
                                        { qualification = qualified.moduleName
                                        , name = qualified.name
                                        }
                                )

                        Just moduleOrigin ->
                            case context.declarationTypes |> FastDict.get moduleOrigin of
                                Nothing ->
                                    Err
                                        ("("
                                            ++ (fullRange |> rangeToInfoString)
                                            ++ ") "
                                            ++ "no declaration types found at the module origin of the variant reference "
                                            ++ qualifiedToString
                                                { qualification = moduleOrigin
                                                , name = qualified.name
                                                }
                                        )

                                Just moduleOriginDeclarationTypes ->
                                    Ok
                                        { name = moduleOrigin
                                        , declarationTypes = moduleOriginDeclarationTypes
                                        }
            in
            case moduleOriginInfoOrError of
                Err error ->
                    Err error

                Ok moduleOriginInfo ->
                    case
                        moduleOriginInfo.declarationTypes.choiceTypes
                            |> fastDictMapAndSmallestJust
                                (\choiceTypeName choiceTypeInfo ->
                                    choiceTypeInfo.variants
                                        |> FastDict.get qualified.name
                                        |> Maybe.map
                                            (\variantParameters ->
                                                { variantParameters = variantParameters
                                                , choiceTypeName = choiceTypeName
                                                , choiceTypeParameters = choiceTypeInfo.parameters
                                                }
                                            )
                                )
                    of
                        Nothing ->
                            Err
                                ("("
                                    ++ (fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no choice type found at the module origin with the variant reference "
                                    ++ qualifiedToString
                                        { qualification = moduleOriginInfo.name
                                        , name = qualified.name
                                        }
                                )

                        Just variant ->
                            patternVariantTypeInfer context
                                { fullRange = fullRange
                                , qualification = qualified.moduleName
                                , moduleOrigin = moduleOriginInfo.name
                                , name = qualified.name
                                , variantValueTypes = variant.variantParameters
                                , choiceTypeName = variant.choiceTypeName
                                , choiceTypeParameters = variant.choiceTypeParameters
                                , values = values
                                }


patternListExactEmpty : Pattern type_
patternListExactEmpty =
    PatternListExact []


patternVariantTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , choiceTypeName : String
        , choiceTypeParameters : List String
        , variantValueTypes : List (Type String)
        , values : List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
        }
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternVariantTypeInfer context patternVariant =
    Result.map
        (\valuesAndResultTypeUnified ->
            { range = patternVariant.fullRange
            , value =
                PatternVariant
                    { moduleOrigin = patternVariant.moduleOrigin
                    , qualification = patternVariant.qualification
                    , name = patternVariant.name
                    , values =
                        valuesAndResultTypeUnified.valuesReverse
                            |> List.reverse
                    }
            , type_ = valuesAndResultTypeUnified.resultType
            }
        )
        (listFoldl2WhileOkFrom
            { valuesReverse = []
            , resultType =
                TypeNotVariable
                    (TypeConstruct
                        { moduleOrigin = patternVariant.moduleOrigin
                        , name = patternVariant.choiceTypeName
                        , arguments =
                            patternVariant.choiceTypeParameters
                                |> List.map
                                    (\parameter ->
                                        TypeVariable
                                            ( patternVariant.fullRange |> rangeToAsComparable
                                            , parameter
                                            )
                                    )
                        }
                    )
            }
            patternVariant.variantValueTypes
            patternVariant.values
            (\typeInVariant argumentPattern soFar ->
                Result.andThen
                    (\valueInferred ->
                        let
                            typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                            typeContext =
                                { declarationTypes = context.declarationTypes
                                , range = patternVariant.fullRange
                                }
                        in
                        Result.andThen
                            (\valueTypeUnified ->
                                Result.map2
                                    (\resultTypeAfterUnification valueInferredAfterUnification ->
                                        { resultType =
                                            resultTypeAfterUnification
                                        , valuesReverse =
                                            valueInferredAfterUnification
                                                :: soFar.valuesReverse
                                        }
                                    )
                                    (soFar.resultType
                                        |> typeApplyVariableSubstitutions
                                            typeContext
                                            valueTypeUnified.substitutions
                                    )
                                    (valueInferred
                                        |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                            valueTypeUnified.substitutions
                                    )
                            )
                            (typeUnify typeContext
                                valueInferred.type_
                                (typeInVariant
                                    |> typeMapVariables
                                        (\variableName ->
                                            ( patternVariant.fullRange |> rangeToAsComparable
                                            , variableName
                                            )
                                        )
                                )
                            )
                    )
                    (argumentPattern |> patternTypeInfer context)
            )
        )


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


expressionTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionTypeInfer context (Elm.Syntax.Node.Node fullRange expression) =
    -- IGNORE TCO
    case expression of
        Elm.Syntax.Expression.UnitExpr ->
            Ok
                { range = fullRange
                , value = ExpressionUnit
                , type_ = typeUnit
                }

        Elm.Syntax.Expression.Integer intValue ->
            Ok
                { range = fullRange
                , value = ExpressionInteger { base = Base10, value = intValue }
                , type_ = TypeVariable ( fullRange |> rangeToAsComparable, "number" )
                }

        Elm.Syntax.Expression.Hex intValue ->
            Ok
                { range = fullRange
                , value = ExpressionInteger { base = Base16, value = intValue }
                , type_ = TypeVariable ( fullRange |> rangeToAsComparable, "number" )
                }

        Elm.Syntax.Expression.Floatable floatValue ->
            Ok
                { range = fullRange
                , value = ExpressionFloat floatValue
                , type_ = typeBasicsFloat
                }

        Elm.Syntax.Expression.Literal stringValue ->
            Ok
                { range = fullRange
                , value = ExpressionString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Expression.CharLiteral charValue ->
            Ok
                { range = fullRange
                , value = ExpressionChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Expression.PrefixOperator operator ->
            Result.map
                (\operatorInferred ->
                    { range = fullRange
                    , value =
                        ExpressionOperatorFunction
                            { symbol = operator
                            , moduleOrigin = operatorInferred.moduleOrigin
                            }
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input = operatorInferred.leftType
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = operatorInferred.rightType
                                            , output = operatorInferred.resultType
                                            }
                                        )
                                }
                            )
                    }
                )
                (operatorFunctionType
                    { moduleOriginLookup = context.moduleOriginLookup
                    , range = fullRange
                    }
                    operator
                )

        Elm.Syntax.Expression.FunctionOrValue qualification name ->
            Result.map
                (\inferred ->
                    { type_ = inferred.type_
                    , range = fullRange
                    , value = ExpressionReference inferred.value
                    }
                )
                (expressionReferenceTypeInfer context
                    { fullRange = fullRange
                    , qualification = qualification
                    , name = name
                    }
                )

        Elm.Syntax.Expression.RecordAccessFunction dotFieldName ->
            let
                fieldName : String
                fieldName =
                    dotFieldName |> String.dropLeft 1

                fieldValueType : Type TypeVariableFromContext
                fieldValueType =
                    TypeVariable
                        ( { start =
                                { row = fullRange.start.row
                                , column = fullRange.start.column + 1
                                }
                          , end = fullRange.end
                          }
                            |> rangeToAsComparable
                        , fieldName
                        )
            in
            Ok
                { range = fullRange
                , value =
                    ExpressionRecordAccessFunction fieldName
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeRecordExtension
                                        { recordVariable =
                                            ( fullRange |> rangeToAsComparable
                                            , "record"
                                            )
                                        , fields =
                                            FastDict.singleton fieldName
                                                fieldValueType
                                        }
                                    )
                            , output = fieldValueType
                            }
                        )
                }

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            Result.map
                (\inParensInferred ->
                    { range = fullRange
                    , value = ExpressionParenthesized inParensInferred
                    , type_ = inParensInferred.type_
                    }
                )
                (inParens
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.Negation negated ->
            Result.andThen
                (\negatedInferred ->
                    Result.andThen
                        (\substitutionsFromUnifyingNegatedWithNumber ->
                            { range = fullRange
                            , value = ExpressionNegation negatedInferred
                            , type_ = negatedInferred.type_
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    substitutionsFromUnifyingNegatedWithNumber
                        )
                        (variableSubstitutionsFromVariableToType
                            ( fullRange |> rangeToAsComparable, "number" )
                            negatedInferred.type_
                        )
                )
                (negated |> expressionTypeInfer context)

        Elm.Syntax.Expression.RecordAccess recordNode fieldNameNode ->
            Result.andThen
                (\accessedRecordInferred ->
                    let
                        (Elm.Syntax.Node.Node fieldRange fieldName) =
                            fieldNameNode

                        introducedFieldValueTypeVariable : Type TypeVariableFromContext
                        introducedFieldValueTypeVariable =
                            TypeVariable
                                ( fieldRange |> rangeToAsComparable
                                , fieldName
                                )
                    in
                    Result.andThen
                        (\recordWithAccessedFieldUnified ->
                            { range = fullRange
                            , value =
                                ExpressionRecordAccess
                                    { record = accessedRecordInferred
                                    , fieldName = fieldName
                                    , fieldNameRange =
                                        fieldNameNode |> Elm.Syntax.Node.range
                                    }
                            , type_ = introducedFieldValueTypeVariable
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    recordWithAccessedFieldUnified.substitutions
                        )
                        (typeNotVariableUnifyWithType
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                            (TypeRecordExtension
                                { recordVariable =
                                    ( fullRange |> rangeToAsComparable
                                    , "record"
                                    )
                                , fields =
                                    FastDict.singleton fieldName
                                        introducedFieldValueTypeVariable
                                }
                            )
                            accessedRecordInferred.type_
                        )
                )
                (recordNode |> expressionTypeInfer context)

        Elm.Syntax.Expression.OperatorApplication operator _ left right ->
            expressionInfixOperationTypeInfer context
                { fullRange = fullRange
                , operator = operator
                , left = left
                , right = right
                }

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            resultAndThen3
                (\conditionInferred onTrueInferred onFalseInferred ->
                    let
                        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                        typeContext =
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                    in
                    resultAndThen2
                        (\conditionTypeInferredUnifiedWithBool onTrueOnFalseTypesUnified ->
                            Result.andThen
                                (\fullUnificationSubstitutions ->
                                    { range = fullRange
                                    , value =
                                        ExpressionIfThenElse
                                            { condition = conditionInferred
                                            , onTrue = onTrueInferred
                                            , onFalse = onFalseInferred
                                            }
                                    , type_ = onTrueInferred.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            fullUnificationSubstitutions
                                )
                                (variableSubstitutionsMerge typeContext
                                    conditionTypeInferredUnifiedWithBool.substitutions
                                    onTrueOnFalseTypesUnified.substitutions
                                )
                        )
                        (typeUnifyWithTypeConstruct typeContext
                            conditionInferred.type_
                            typeConstructBasicsBool
                        )
                        (typeUnify typeContext
                            onTrueInferred.type_
                            onFalseInferred.type_
                        )
                )
                (condition |> expressionTypeInfer context)
                (onTrue |> expressionTypeInfer context)
                (onFalse |> expressionTypeInfer context)

        Elm.Syntax.Expression.TupledExpression tupleParts ->
            case tupleParts of
                [] ->
                    -- should be handled by UnitExpr
                    Ok
                        { range = fullRange
                        , value = ExpressionUnit
                        , type_ = typeUnit
                        }

                [ inParens ] ->
                    -- should be handled by ParenthesizedExpression
                    Result.map
                        (\inParensInferred ->
                            { range = fullRange
                            , value = ExpressionParenthesized inParensInferred
                            , type_ = inParensInferred.type_
                            }
                        )
                        (inParens
                            |> expressionTypeInfer context
                        )

                [ part0, part1 ] ->
                    Result.map2
                        (\part0Inferred part1Inferred ->
                            { range = fullRange
                            , value =
                                ExpressionTuple
                                    { part0 = part0Inferred
                                    , part1 = part1Inferred
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0Inferred.type_
                                        , part1 = part1Inferred.type_
                                        }
                                    )
                            }
                        )
                        (part0 |> expressionTypeInfer context)
                        (part1 |> expressionTypeInfer context)

                [ part0, part1, part2 ] ->
                    Result.map3
                        (\part0Inferred part1Inferred part2Inferred ->
                            { range = fullRange
                            , value =
                                ExpressionTriple
                                    { part0 = part0Inferred
                                    , part1 = part1Inferred
                                    , part2 = part2Inferred
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0Inferred.type_
                                        , part1 = part1Inferred.type_
                                        , part2 = part2Inferred.type_
                                        }
                                    )
                            }
                        )
                        (part0 |> expressionTypeInfer context)
                        (part1 |> expressionTypeInfer context)
                        (part2 |> expressionTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "too many tuple parts"
                        )

        Elm.Syntax.Expression.ListExpr elements ->
            case elements of
                [] ->
                    Ok
                        { range = fullRange
                        , value = expressionListEmpty
                        , type_ =
                            typeListList
                                (TypeVariable ( fullRange |> rangeToAsComparable, "element" ))
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailElementsInferred ->
                            Result.andThen
                                (\elementTypeUnified ->
                                    { range = fullRange
                                    , value =
                                        ExpressionList
                                            (headInferred
                                                :: tailElementsInferred
                                            )
                                    , type_ = typeListList headInferred.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            elementTypeUnified.substitutions
                                )
                                (listFilledMapAndTypesUnify
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                                    .type_
                                    ( headInferred, tailElementsInferred )
                                )
                        )
                        (head |> expressionTypeInfer context)
                        (tail
                            |> listFoldrWhileOkFrom
                                []
                                (\elementNode soFar ->
                                    Result.map
                                        (\elementInferred ->
                                            elementInferred :: soFar
                                        )
                                        (elementNode |> expressionTypeInfer context)
                                )
                        )

        Elm.Syntax.Expression.Application application ->
            case application of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "empty application is invalid syntax"
                        )

                [ subExpression ] ->
                    -- never produced by elm-syntax
                    subExpression |> expressionTypeInfer context

                called :: argument0 :: argument1Up ->
                    resultAndThen3
                        (\calledInferred argument0Inferred argument1UpInferred ->
                            let
                                introducedResultTypeVariable : Type TypeVariableFromContext
                                introducedResultTypeVariable =
                                    TypeVariable
                                        ( fullRange |> rangeToAsComparable, "callResult" )
                            in
                            Result.andThen
                                (\callTypeUnified ->
                                    { range = fullRange
                                    , value =
                                        ExpressionCall
                                            { called = calledInferred
                                            , argument0 = argument0Inferred
                                            , argument1Up = argument1UpInferred
                                            }
                                    , type_ = introducedResultTypeVariable
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            callTypeUnified.substitutions
                                )
                                (typeUnify
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = argument0Inferred.type_
                                            , output =
                                                argument1UpInferred
                                                    |> List.foldr
                                                        (\argumentInferred output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentInferred.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        introducedResultTypeVariable
                                            }
                                        )
                                    )
                                    calledInferred.type_
                                )
                        )
                        (called |> expressionTypeInfer context)
                        (argument0 |> expressionTypeInfer context)
                        (argument1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\argumentNode soFar ->
                                    Result.map
                                        (\argumentInferred ->
                                            argumentInferred :: soFar
                                        )
                                        (argumentNode |> expressionTypeInfer context)
                                )
                        )

        Elm.Syntax.Expression.RecordExpr fields ->
            Result.map
                (\fieldsInferred ->
                    { range = fullRange
                    , value =
                        ExpressionRecord
                            fieldsInferred
                    , type_ =
                        TypeNotVariable
                            (TypeRecord
                                (fieldsInferred
                                    |> List.foldl
                                        (\field soFar ->
                                            soFar
                                                |> FastDict.insert field.name
                                                    field.value.type_
                                        )
                                        FastDict.empty
                                )
                            )
                    }
                )
                (fields
                    |> listFoldrWhileOkFrom
                        []
                        (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node fieldNameRange fieldName, fieldValueNode )) soFar ->
                            Result.map
                                (\fieldValueInferred ->
                                    { range = fieldRange
                                    , name = fieldName
                                    , nameRange = fieldNameRange
                                    , value = fieldValueInferred
                                    }
                                        :: soFar
                                )
                                (fieldValueNode |> expressionTypeInfer context)
                        )
                )

        Elm.Syntax.Expression.RecordUpdateExpression (Elm.Syntax.Node.Node recordVariableRange recordVariable) fields ->
            case fields of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "record update without fields is invalid syntax"
                        )

                (Elm.Syntax.Node.Node field0Range ( Elm.Syntax.Node.Node field0NameRange field0Name, field0ValueNode )) :: field1Up ->
                    resultAndThen3
                        (\recordVariableInferred field0Inferred field1UpInferred ->
                            Result.andThen
                                (\recordVariableUnifiedWithUpdate ->
                                    { range = fullRange
                                    , value =
                                        ExpressionRecordUpdate
                                            { recordVariable =
                                                { range = recordVariableInferred.range
                                                , value =
                                                    { moduleOrigin =
                                                        recordVariableInferred.value.moduleOrigin
                                                    , name = recordVariableInferred.value.name
                                                    }
                                                , type_ = recordVariableInferred.type_
                                                }
                                            , field0 = field0Inferred
                                            , field1Up = field1UpInferred
                                            }
                                    , type_ = recordVariableInferred.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            recordVariableUnifiedWithUpdate.substitutions
                                )
                                (typeUnify
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                                    recordVariableInferred.type_
                                    (TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable =
                                                ( fullRange |> rangeToAsComparable, recordVariableInferred.value.name )
                                            , fields =
                                                field1UpInferred
                                                    |> List.foldl
                                                        (\fieldInferred soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldInferred.name
                                                                    fieldInferred.value.type_
                                                        )
                                                        (FastDict.singleton
                                                            field0Inferred.name
                                                            field0Inferred.value.type_
                                                        )
                                            }
                                        )
                                    )
                                )
                        )
                        ({ fullRange = recordVariableRange
                         , qualification = []
                         , name = recordVariable
                         }
                            |> expressionReferenceTypeInfer context
                        )
                        (Result.map
                            (\valueInferred ->
                                { range = field0Range
                                , name = field0Name
                                , nameRange = field0NameRange
                                , value = valueInferred
                                }
                            )
                            (field0ValueNode |> expressionTypeInfer context)
                        )
                        (field1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node nameRange name, valueNode )) soFar ->
                                    Result.map
                                        (\fieldValueInferred ->
                                            { range = fieldRange
                                            , name = name
                                            , nameRange = nameRange
                                            , value = fieldValueInferred
                                            }
                                                :: soFar
                                        )
                                        (valueNode |> expressionTypeInfer context)
                                )
                        )

        Elm.Syntax.Expression.LambdaExpression lambda ->
            case lambda.args of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "lambda without parameter patterns is invalid syntax"
                        )

                parameter0 :: parameter1Up ->
                    resultAndThen2
                        (\parameter0Inferred parameter1UpInferred ->
                            Result.andThen
                                (\resultInferred ->
                                    Result.andThen
                                        (\parameterPatternVariablesAndUsesUnificationSubstitutions ->
                                            { range = fullRange
                                            , value =
                                                ExpressionLambda
                                                    { parameter0 = parameter0Inferred
                                                    , parameter1Up = parameter1UpInferred
                                                    , result = resultInferred
                                                    }
                                            , type_ =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = parameter0Inferred.type_
                                                        , output =
                                                            parameter1UpInferred
                                                                |> List.foldr
                                                                    (\argumentTypedNode output ->
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input = argumentTypedNode.type_
                                                                                , output = output
                                                                                }
                                                                            )
                                                                    )
                                                                    resultInferred.type_
                                                        }
                                                    )
                                            }
                                                |> expressionTypedNodeApplyVariableSubstitutions
                                                    context.declarationTypes
                                                    parameterPatternVariablesAndUsesUnificationSubstitutions
                                        )
                                        (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                            { declarationTypes = context.declarationTypes
                                            , range = fullRange
                                            }
                                            ((parameter0Inferred :: parameter1UpInferred)
                                                |> listMapToFastDictsAndUnify
                                                    patternTypedNodeIntroducedVariables
                                            )
                                            resultInferred
                                        )
                                )
                                (lambda.expression
                                    |> expressionTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                (List.foldl
                                                    (\parameter soFar ->
                                                        FastDict.union soFar
                                                            (parameter |> patternTypedNodeIntroducedVariables)
                                                    )
                                                    (parameter0Inferred |> patternTypedNodeIntroducedVariables)
                                                    parameter1UpInferred
                                                )
                                        }
                                )
                        )
                        (parameter0
                            |> patternTypeInfer
                                { moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (parameter1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\pattern soFar ->
                                    Result.map
                                        (\patternInferred ->
                                            patternInferred :: soFar
                                        )
                                        (pattern
                                            |> patternTypeInfer
                                                { declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            case caseOf.cases of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "case-of without case branches is invalid syntax"
                        )

                case0 :: case1Up ->
                    resultAndThen3
                        (\matchedInferred case0Inferred case1UpInferred ->
                            let
                                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                                typeContext =
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                            in
                            Result.andThen
                                (\unifiedTypes ->
                                    { range = fullRange
                                    , value =
                                        ExpressionCaseOf
                                            { matchedExpression = matchedInferred
                                            , case0 = case0Inferred
                                            , case1Up = case1UpInferred
                                            }
                                    , type_ = case0Inferred.result.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            unifiedTypes.substitutions
                                )
                                (case1UpInferred
                                    |> listFoldlWhileOkFromResult
                                        (Result.map
                                            (\matchedExpressionCase0PatternUnifiedType ->
                                                { resultType = case0Inferred.result.type_
                                                , matchedType = matchedExpressionCase0PatternUnifiedType.type_
                                                , substitutions = matchedExpressionCase0PatternUnifiedType.substitutions
                                                }
                                            )
                                            (typeUnify typeContext
                                                matchedInferred.type_
                                                case0Inferred.pattern.type_
                                            )
                                        )
                                        (\caseInferred soFar ->
                                            resultAndThen2
                                                (\matchedTypeUnifiedWithCasePattern resultTypeUnifiedWithCaseResult ->
                                                    Result.map
                                                        (\substitutionsWithCase ->
                                                            { substitutions = substitutionsWithCase
                                                            , matchedType = matchedTypeUnifiedWithCasePattern.type_
                                                            , resultType = resultTypeUnifiedWithCaseResult.type_
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge3
                                                            typeContext
                                                            soFar.substitutions
                                                            matchedTypeUnifiedWithCasePattern.substitutions
                                                            resultTypeUnifiedWithCaseResult.substitutions
                                                        )
                                                )
                                                (typeUnify typeContext
                                                    soFar.matchedType
                                                    caseInferred.pattern.type_
                                                )
                                                (typeUnify typeContext
                                                    soFar.resultType
                                                    caseInferred.result.type_
                                                )
                                        )
                                )
                        )
                        (caseOf.expression |> expressionTypeInfer context)
                        (case0
                            |> expressionCaseTypeInfer context
                        )
                        (case1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\case_ soFar ->
                                    Result.map
                                        (\caseInferred ->
                                            caseInferred :: soFar
                                        )
                                        (case_
                                            |> expressionCaseTypeInfer context
                                        )
                                )
                        )

        Elm.Syntax.Expression.LetExpression letIn ->
            case letIn.declarations of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "let-in without declarations is invalid syntax"
                        )

                letDeclaration0Node :: letDeclaration1Up ->
                    expressionLetInTypeInfer context
                        { declaration0 = letDeclaration0Node
                        , declaration1Up = letDeclaration1Up
                        , expression = letIn.expression
                        , fullRange = fullRange
                        }

        Elm.Syntax.Expression.Operator _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "Elm.Syntax.Expression.Operator is not valid syntax"
                )

        Elm.Syntax.Expression.GLSLExpression _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "glsl shader expressions not supported"
                )


expressionLetInTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    }
    ->
        { declaration0 : Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
        , declaration1Up : List (Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration)
        , fullRange : Elm.Syntax.Range.Range
        , expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionLetInTypeInfer context syntaxExpressionLetIn =
    Result.andThen
        (\acrossLetInIncludingContextSoFar ->
            resultAndThen3
                (\declaration0Inferred declaration1UpInferred resultInferred ->
                    let
                        letInTypedNodeInferred :
                            TypedNode
                                (Expression (Type TypeVariableFromContext))
                                (Type TypeVariableFromContext)
                        letInTypedNodeInferred =
                            { range = syntaxExpressionLetIn.fullRange
                            , type_ = resultInferred.type_
                            , value =
                                ExpressionLetIn
                                    { declaration0 = declaration0Inferred
                                    , declaration1Up =
                                        declaration1UpInferred
                                    , result = resultInferred
                                    }
                            }

                        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                        typeContext =
                            { declarationTypes = context.declarationTypes
                            , range = syntaxExpressionLetIn.fullRange
                            }
                    in
                    Result.andThen
                        (\fullSubstitutions ->
                            letInTypedNodeInferred
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    fullSubstitutions
                        )
                        (resultAndThen2
                            (\destructuringUseUnificationSubstitutions declarationUseUnificationSubstitutions ->
                                variableSubstitutionsMerge
                                    typeContext
                                    destructuringUseUnificationSubstitutions
                                    declarationUseUnificationSubstitutions
                            )
                            (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                typeContext
                                ((declaration0Inferred :: declaration1UpInferred)
                                    |> listMapToFastDictsAndUnify
                                        (\declarationInferred ->
                                            case declarationInferred.declaration of
                                                LetDestructuring letDestructuring ->
                                                    letDestructuring.pattern
                                                        |> patternTypedNodeIntroducedVariables

                                                LetValueOrFunctionDeclaration _ ->
                                                    FastDict.empty
                                        )
                                )
                                letInTypedNodeInferred
                            )
                            (substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression
                                typeContext
                                ((declaration0Inferred :: declaration1UpInferred)
                                    |> listMapToFastDictsAndUnify
                                        (\declarationInferred ->
                                            case declarationInferred.declaration of
                                                LetDestructuring _ ->
                                                    FastDict.empty

                                                LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
                                                    case letValueOrFunctionDeclaration.signature of
                                                        Just _ ->
                                                            FastDict.empty

                                                        Nothing ->
                                                            FastDict.singleton
                                                                letValueOrFunctionDeclaration.name
                                                                { range = declarationInferred.range
                                                                , type_ = letValueOrFunctionDeclaration.type_
                                                                }
                                        )
                                )
                                letInTypedNodeInferred
                            )
                        )
                )
                (syntaxExpressionLetIn.declaration0
                    |> letDeclarationTypeInfer
                        { locallyIntroducedExpressionVariables =
                            acrossLetInIncludingContextSoFar.introducedExpressionVariables
                        , locallyIntroducedDeclarationTypes =
                            acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , declarationTypes = context.declarationTypes
                        }
                )
                (syntaxExpressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        []
                        (\letDeclarationNode soFar ->
                            Result.map
                                (\letDeclarationInferred ->
                                    letDeclarationInferred :: soFar
                                )
                                (letDeclarationNode
                                    |> letDeclarationTypeInfer
                                        { locallyIntroducedExpressionVariables =
                                            acrossLetInIncludingContextSoFar.introducedExpressionVariables
                                        , locallyIntroducedDeclarationTypes =
                                            acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , declarationTypes = context.declarationTypes
                                        }
                                )
                        )
                )
                (syntaxExpressionLetIn.expression
                    |> expressionTypeInfer
                        { locallyIntroducedExpressionVariables =
                            acrossLetInIncludingContextSoFar.introducedExpressionVariables
                        , moduleOriginLookup = context.moduleOriginLookup
                        , declarationTypes = context.declarationTypes
                        , locallyIntroducedDeclarationTypes =
                            acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                        }
                )
        )
        ((syntaxExpressionLetIn.declaration0 :: syntaxExpressionLetIn.declaration1Up)
            |> listFoldlWhileOkFrom
                { introducedExpressionVariables =
                    context.locallyIntroducedExpressionVariables
                , introducedDeclarationTypes =
                    context.locallyIntroducedDeclarationTypes
                }
                (\(Elm.Syntax.Node.Node letDeclarationRange letDeclaration) soFar ->
                    case letDeclaration of
                        Elm.Syntax.Expression.LetDestructuring patternNode _ ->
                            Result.map
                                (\patternInferred ->
                                    { introducedDeclarationTypes =
                                        soFar.introducedDeclarationTypes
                                    , introducedExpressionVariables =
                                        FastDict.union soFar.introducedExpressionVariables
                                            (patternInferred |> patternTypedNodeIntroducedVariables)
                                    }
                                )
                                (patternNode
                                    |> patternTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        }
                                )

                        Elm.Syntax.Expression.LetFunction letValueOrFunctionDeclaration ->
                            let
                                (Elm.Syntax.Node.Node _ name) =
                                    letValueOrFunctionDeclaration.declaration
                                        |> Elm.Syntax.Node.value
                                        |> .name

                                letDeclarationRangeAsComparable : RangeAsComparable
                                letDeclarationRangeAsComparable =
                                    letDeclarationRange |> rangeToAsComparable
                            in
                            case letValueOrFunctionDeclaration.signature of
                                Nothing ->
                                    Ok
                                        { introducedExpressionVariables =
                                            soFar.introducedExpressionVariables
                                        , introducedDeclarationTypes =
                                            soFar.introducedDeclarationTypes
                                                |> FastDict.insert name
                                                    { range = letDeclarationRange
                                                    , type_ =
                                                        TypeVariable
                                                            ( letDeclarationRangeAsComparable
                                                            , name
                                                            )
                                                    }
                                        }

                                Just (Elm.Syntax.Node.Node _ signature) ->
                                    Result.map
                                        (\type_ ->
                                            { introducedExpressionVariables =
                                                soFar.introducedExpressionVariables
                                            , introducedDeclarationTypes =
                                                soFar.introducedDeclarationTypes
                                                    |> FastDict.insert name
                                                        { range = letDeclarationRange
                                                        , type_ =
                                                            type_
                                                                |> typeMapVariables
                                                                    (\variable ->
                                                                        ( letDeclarationRangeAsComparable
                                                                        , variable
                                                                        )
                                                                    )
                                                        }
                                            }
                                        )
                                        (signature.typeAnnotation
                                            |> Elm.Syntax.Node.value
                                            |> syntaxToType context.moduleOriginLookup
                                        )
                )
        )


substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    -> Result String VariableSubstitutions
substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression context introducedVariables expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedVariables
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\variableName usesInLambdaResult soFar ->
                case introducedVariables |> FastDict.get variableName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just variableParameterType ->
                        Result.andThen
                            (\variableUsesAndParameterUnified ->
                                variableSubstitutionsMerge context
                                    soFar
                                    variableUsesAndParameterUnified.substitutions
                            )
                            (listFilledMapAndTypesUnify context
                                Basics.identity
                                ( variableParameterType
                                , usesInLambdaResult |> FastDict.values
                                )
                            )
            )


substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    -> Result String VariableSubstitutions
substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression context introducedDeclarations expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedDeclarations
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\declarationName usesInLambdaResult soFar ->
                case introducedDeclarations |> FastDict.get declarationName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just inferredDeclarationType ->
                        usesInLambdaResult
                            |> fastDictFoldlWhileOkFrom
                                soFar
                                (\useRangeAsComparable useType soFarWithUses ->
                                    let
                                        newDeclarationTypeInstanceForUse : Type TypeVariableFromContext
                                        newDeclarationTypeInstanceForUse =
                                            inferredDeclarationType.type_
                                                |> typeMapVariables
                                                    (\inferredDeclarationTypeVariable ->
                                                        let
                                                            ( inferredDeclarationTypeVariableUsesRangeAsComparable, inferredDeclarationTypeVariableName ) =
                                                                inferredDeclarationTypeVariable
                                                        in
                                                        if
                                                            inferredDeclarationType.range
                                                                |> rangeIncludesRangeAsComparable
                                                                    inferredDeclarationTypeVariableUsesRangeAsComparable
                                                        then
                                                            ( useRangeAsComparable
                                                            , inferredDeclarationTypeVariableName
                                                            )

                                                        else
                                                            inferredDeclarationTypeVariable
                                                    )
                                    in
                                    Result.andThen
                                        (\useUnifiedWithNewLetTypeInstance ->
                                            -- we need to check if the partialTpeNewInstance
                                            -- is actually more strict then the already existing use type.
                                            -- If we don't, this would run indefinitely: E.g.
                                            -- a : number
                                            -- b = round a
                                            -- where a is already known as Float
                                            -- when it is unified with the let `number`
                                            if
                                                typesAreEquallyStrict
                                                    (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                    (useType |> typeContainedVariables)
                                            then
                                                Result.map
                                                    (\mergedEquivalentVariables ->
                                                        { equivalentVariables =
                                                            mergedEquivalentVariables
                                                        , variableToType = soFarWithUses.variableToType
                                                        }
                                                    )
                                                    (equivalentVariableSetMerge
                                                        soFarWithUses.equivalentVariables
                                                        useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables
                                                    )

                                            else
                                                variableSubstitutionsMerge context
                                                    soFarWithUses
                                                    useUnifiedWithNewLetTypeInstance.substitutions
                                        )
                                        (typeUnify context
                                            useType
                                            newDeclarationTypeInstanceForUse
                                        )
                                )
            )


substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    -> Result String VariableSubstitutions
substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression context introducedDeclarations expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedDeclarations
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\declarationName usesInLambdaResult soFar ->
                case introducedDeclarations |> FastDict.get declarationName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just inferredDeclarationType ->
                        usesInLambdaResult
                            |> fastDictFoldlWhileOkFrom
                                soFar
                                (\useRangeAsComparable useType soFarWithUses ->
                                    let
                                        newDeclarationTypeInstanceForUse : Type TypeVariableFromContext
                                        newDeclarationTypeInstanceForUse =
                                            inferredDeclarationType.type_
                                                |> typeMapVariables
                                                    (\inferredDeclarationTypeVariable ->
                                                        let
                                                            ( _, inferredDeclarationTypeVariableName ) =
                                                                inferredDeclarationTypeVariable
                                                        in
                                                        ( useRangeAsComparable
                                                        , inferredDeclarationTypeVariableName
                                                        )
                                                    )
                                    in
                                    Result.andThen
                                        (\useUnifiedWithNewLetTypeInstance ->
                                            -- we need to check if the partialTpeNewInstance
                                            -- is actually more strict then the already existing use type.
                                            -- If we don't, this would run indefinitely: E.g.
                                            -- a : number
                                            -- b = round a
                                            -- where a is already known as Float
                                            -- when it is unified with the let `number`
                                            if
                                                typesAreEquallyStrict
                                                    (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                    (useType |> typeContainedVariables)
                                            then
                                                Result.map
                                                    (\mergedEquivalentVariables ->
                                                        { equivalentVariables = mergedEquivalentVariables
                                                        , variableToType = soFarWithUses.variableToType
                                                        }
                                                    )
                                                    (equivalentVariableSetMerge
                                                        soFarWithUses.equivalentVariables
                                                        useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables
                                                    )

                                            else
                                                variableSubstitutionsMerge context
                                                    soFarWithUses
                                                    useUnifiedWithNewLetTypeInstance.substitutions
                                        )
                                        (typeUnify context
                                            useType
                                            newDeclarationTypeInstanceForUse
                                        )
                                )
            )


typeUnit : Type type_
typeUnit =
    TypeNotVariable TypeUnit


expressionListEmpty : Expression type_
expressionListEmpty =
    ExpressionList []


expressionCaseTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        ( Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
        , Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        )
    ->
        Result
            String
            { pattern :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , result :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionCaseTypeInfer context ( syntaxCasePattern, syntaxCaseResult ) =
    Result.andThen
        (\patternInferred ->
            Result.andThen
                (\resultInferred ->
                    Result.andThen
                        (\substitutionsFromUnifyingPatternVariablesWithUses ->
                            Result.map2
                                (\patternInferredSubstituted resultInferredSubstituted ->
                                    { pattern = patternInferredSubstituted
                                    , result = resultInferredSubstituted
                                    }
                                )
                                (patternInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        substitutionsFromUnifyingPatternVariablesWithUses
                                )
                                (resultInferred
                                    |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        substitutionsFromUnifyingPatternVariablesWithUses
                                )
                        )
                        (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                            { declarationTypes = context.declarationTypes
                            , range =
                                { start = syntaxCasePattern |> Elm.Syntax.Node.range |> .start
                                , end = syntaxCaseResult |> Elm.Syntax.Node.range |> .end
                                }
                            }
                            (patternInferred |> patternTypedNodeIntroducedVariables)
                            resultInferred
                        )
                )
                (syntaxCaseResult
                    |> expressionTypeInfer
                        { declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , locallyIntroducedDeclarationTypes =
                            context.locallyIntroducedDeclarationTypes
                        , locallyIntroducedExpressionVariables =
                            FastDict.union context.locallyIntroducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                )
        )
        (syntaxCasePattern
            |> patternTypeInfer
                { declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


expressionReferenceTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    ->
        Result
            String
            (TypedNode
                { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                , qualification : Elm.Syntax.ModuleName.ModuleName
                , name : String
                }
                (Type TypeVariableFromContext)
            )
expressionReferenceTypeInfer context expressionReference =
    let
        useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration :
            Maybe
                (TypedNode
                    { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                    , qualification : Elm.Syntax.ModuleName.ModuleName
                    , name : String
                    }
                    (Type TypeVariableFromContext)
                )
        useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration =
            case expressionReference.qualification of
                _ :: _ ->
                    Nothing

                [] ->
                    case
                        context.locallyIntroducedExpressionVariables
                            |> FastDict.get expressionReference.name
                    of
                        Just locallyIntroducedExpressionVariableType ->
                            Just
                                { range = expressionReference.fullRange
                                , value =
                                    { qualification = []
                                    , moduleOrigin = []
                                    , name = expressionReference.name
                                    }
                                , type_ = locallyIntroducedExpressionVariableType
                                }

                        Nothing ->
                            case
                                context.locallyIntroducedDeclarationTypes
                                    |> FastDict.get expressionReference.name
                            of
                                Nothing ->
                                    Nothing

                                Just locallyIntroducedDeclarationType ->
                                    let
                                        locallyIntroducedDeclarationTypeWithContext : Type TypeVariableFromContext
                                        locallyIntroducedDeclarationTypeWithContext =
                                            locallyIntroducedDeclarationType.type_
                                                |> typeMapVariables
                                                    (\partiallyInferredTypeVariable ->
                                                        let
                                                            ( partiallyInferredTypeVariableRangeAsComparable, partiallyInferredTypeVariableName ) =
                                                                partiallyInferredTypeVariable
                                                        in
                                                        if
                                                            locallyIntroducedDeclarationType.range
                                                                |> rangeIncludesRangeAsComparable
                                                                    partiallyInferredTypeVariableRangeAsComparable
                                                        then
                                                            ( expressionReference.fullRange |> rangeToAsComparable
                                                            , partiallyInferredTypeVariableName
                                                            )

                                                        else
                                                            partiallyInferredTypeVariable
                                                    )
                                    in
                                    Just
                                        { range = expressionReference.fullRange
                                        , value =
                                            { qualification = []
                                            , moduleOrigin = []
                                            , name = expressionReference.name
                                            }
                                        , type_ = locallyIntroducedDeclarationTypeWithContext
                                        }
    in
    case useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration of
        Just inferred ->
            Ok inferred

        Nothing ->
            case
                context.moduleOriginLookup.references
                    |> FastDict.get ( expressionReference.qualification, expressionReference.name )
            of
                Nothing ->
                    Err
                        ("("
                            ++ (expressionReference.fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ " could not determine the module where the reference "
                            ++ qualifiedToString
                                { qualification = expressionReference.qualification
                                , name = expressionReference.name
                                }
                            ++ " was originally declared in. I'm likely missing import information or don't know of some locally declared things."
                        )

                Just moduleOrigin ->
                    case context.declarationTypes |> FastDict.get moduleOrigin of
                        Nothing ->
                            Err
                                ("("
                                    ++ (expressionReference.fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no declaration types found for the reference "
                                    ++ qualifiedToString
                                        { qualification = expressionReference.qualification
                                        , name = expressionReference.name
                                        }
                                    ++ ". I looked for some in the module "
                                    ++ (moduleOrigin |> moduleNameToString)
                                )

                        Just originModuleDeclarationTypes ->
                            case
                                originModuleDeclarationTypes.signatures
                                    |> FastDict.get expressionReference.name
                            of
                                Just signatureType ->
                                    let
                                        signatureTypeWithContext : Type TypeVariableFromContext
                                        signatureTypeWithContext =
                                            signatureType
                                                |> typeMapVariables
                                                    (\variableName ->
                                                        ( expressionReference.fullRange |> rangeToAsComparable
                                                        , variableName
                                                        )
                                                    )
                                    in
                                    Ok
                                        { range = expressionReference.fullRange
                                        , value =
                                            { qualification = expressionReference.qualification
                                            , moduleOrigin = moduleOrigin
                                            , name = expressionReference.name
                                            }
                                        , type_ = signatureTypeWithContext
                                        }

                                Nothing ->
                                    case
                                        originModuleDeclarationTypes.choiceTypes
                                            |> fastDictMapAndSmallestJust
                                                (\choiceTypeName choiceTypeInfo ->
                                                    choiceTypeInfo.variants
                                                        |> FastDict.get expressionReference.name
                                                        |> Maybe.map
                                                            (\variantValues ->
                                                                { variantValues = variantValues
                                                                , choiceTypeName = choiceTypeName
                                                                , choiceTypeParameters = choiceTypeInfo.parameters
                                                                }
                                                            )
                                                )
                                    of
                                        Just variant ->
                                            let
                                                resultType : Type TypeVariableFromContext
                                                resultType =
                                                    TypeNotVariable
                                                        (TypeConstruct
                                                            { moduleOrigin = moduleOrigin
                                                            , name = variant.choiceTypeName
                                                            , arguments =
                                                                variant.choiceTypeParameters
                                                                    |> List.map
                                                                        (\parameter ->
                                                                            TypeVariable
                                                                                ( expressionReference.fullRange |> rangeToAsComparable
                                                                                , parameter
                                                                                )
                                                                        )
                                                            }
                                                        )

                                                fullType : Type TypeVariableFromContext
                                                fullType =
                                                    variant.variantValues
                                                        |> List.foldr
                                                            (\argument output ->
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            argument
                                                                                |> typeMapVariables
                                                                                    (\variableName ->
                                                                                        ( expressionReference.fullRange |> rangeToAsComparable
                                                                                        , variableName
                                                                                        )
                                                                                    )
                                                                        , output = output
                                                                        }
                                                                    )
                                                            )
                                                            resultType
                                            in
                                            Ok
                                                { range = expressionReference.fullRange
                                                , value =
                                                    { qualification = expressionReference.qualification
                                                    , moduleOrigin = moduleOrigin
                                                    , name = expressionReference.name
                                                    }
                                                , type_ = fullType
                                                }

                                        Nothing ->
                                            case originModuleDeclarationTypes.typeAliases |> FastDict.get expressionReference.name of
                                                Nothing ->
                                                    Err
                                                        ("("
                                                            ++ (expressionReference.fullRange |> rangeToInfoString)
                                                            ++ ") "
                                                            ++ "no value/function/port/variant/record type alias constructor found in the origin module of the reference "
                                                            ++ qualifiedToString
                                                                { qualification = moduleOrigin, name = expressionReference.name }
                                                        )

                                                Just originTypeAliasDeclaration ->
                                                    case ( originTypeAliasDeclaration.recordFieldOrder, originTypeAliasDeclaration.type_ ) of
                                                        ( Just fieldOrder, TypeNotVariable (TypeRecord fields) ) ->
                                                            let
                                                                type_ : Type TypeVariableFromContext
                                                                type_ =
                                                                    fieldOrder
                                                                        |> List.foldr
                                                                            (\fieldName outputTypeSoFar ->
                                                                                case fields |> FastDict.get fieldName of
                                                                                    Nothing ->
                                                                                        outputTypeSoFar

                                                                                    Just fieldValueType ->
                                                                                        TypeNotVariable
                                                                                            (TypeFunction
                                                                                                { input =
                                                                                                    fieldValueType
                                                                                                        |> typeMapVariables
                                                                                                            (\name ->
                                                                                                                ( expressionReference.fullRange |> rangeToAsComparable
                                                                                                                , name
                                                                                                                )
                                                                                                            )
                                                                                                , output = outputTypeSoFar
                                                                                                }
                                                                                            )
                                                                            )
                                                                            (TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin = moduleOrigin
                                                                                    , name = expressionReference.name
                                                                                    , arguments =
                                                                                        originTypeAliasDeclaration.parameters
                                                                                            |> List.map
                                                                                                (\parameterName ->
                                                                                                    TypeVariable
                                                                                                        ( expressionReference.fullRange |> rangeToAsComparable
                                                                                                        , parameterName
                                                                                                        )
                                                                                                )
                                                                                    }
                                                                                )
                                                                            )
                                                            in
                                                            Ok
                                                                { range = expressionReference.fullRange
                                                                , value =
                                                                    { qualification = expressionReference.qualification
                                                                    , moduleOrigin = moduleOrigin
                                                                    , name = expressionReference.name
                                                                    }
                                                                , type_ = type_
                                                                }

                                                        _ ->
                                                            Err
                                                                ("("
                                                                    ++ (expressionReference.fullRange |> rangeToInfoString)
                                                                    ++ ") "
                                                                    ++ "I found a type alias with the same name as the reference "
                                                                    ++ qualifiedToString
                                                                        { qualification = moduleOrigin
                                                                        , name = expressionReference.name
                                                                        }
                                                                    ++ ", so I thought you are constructing a record. However, I was unable to determine which arguments correspond to which fields"
                                                                )


type alias RangeAsComparable =
    ( -- start
      LocationAsComparable
    , -- end
      LocationAsComparable
    )


type alias LocationAsComparable =
    ( -- row
      Int
    , -- column
      Int
    )


rangeToAsComparable : Elm.Syntax.Range.Range -> RangeAsComparable
rangeToAsComparable range =
    ( range.start |> locationToAsComparable
    , range.end |> locationToAsComparable
    )


locationToAsComparable : Elm.Syntax.Range.Location -> LocationAsComparable
locationToAsComparable location =
    ( location.row, location.column )


rangeFromAsComparable : RangeAsComparable -> Elm.Syntax.Range.Range
rangeFromAsComparable ( rangeStart, rangeEnd ) =
    { start = rangeStart |> locationFromAsComparable
    , end = rangeEnd |> locationFromAsComparable
    }


locationFromAsComparable : LocationAsComparable -> Elm.Syntax.Range.Location
locationFromAsComparable ( locationRow, locationColumn ) =
    { row = locationRow, column = locationColumn }


rangeIncludesRangeAsComparable : RangeAsComparable -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRangeAsComparable startToCheckForAsComparable baseRange =
    let
        ( ( toCheckForInnerStartRow, toCheckForInnerStartColumn ), toCheckForInnerEndAsComparable ) =
            startToCheckForAsComparable
    in
    if
        (baseRange.start.row < toCheckForInnerStartRow)
            || ((baseRange.start.row - toCheckForInnerStartRow == 0)
                    && (baseRange.start.column <= toCheckForInnerStartColumn)
               )
    then
        let
            ( toCheckForInnerEndRow, toCheckForInnerEndColumn ) =
                toCheckForInnerEndAsComparable
        in
        (baseRange.end.row > toCheckForInnerEndRow)
            || ((baseRange.end.row - toCheckForInnerEndRow == 0)
                    && (baseRange.end.column >= toCheckForInnerEndColumn)
               )

    else
        False


rangeAsComparableOverarching : RangeAsComparable -> RangeAsComparable -> RangeAsComparable
rangeAsComparableOverarching ( aStartAsComparable, aEndAsComparable ) ( bStartAsComparable, bEndAsComparable ) =
    ( locationAsComparableMin aStartAsComparable bStartAsComparable
    , locationAsComparableMax aEndAsComparable bEndAsComparable
    )


locationAsComparableMin : LocationAsComparable -> LocationAsComparable -> LocationAsComparable
locationAsComparableMin aLocationAsComparable bLocationAsComparable =
    let
        ( aRow, aColumn ) =
            aLocationAsComparable

        ( bRow, bColumn ) =
            bLocationAsComparable
    in
    if aRow < bRow then
        aLocationAsComparable

    else if bRow < aRow then
        bLocationAsComparable

    else
        ( aRow, Basics.min aColumn bColumn )


locationAsComparableMax : LocationAsComparable -> LocationAsComparable -> LocationAsComparable
locationAsComparableMax aLocationAsComparable bLocationAsComparable =
    let
        ( aRow, aColumn ) =
            aLocationAsComparable

        ( bRow, bColumn ) =
            bLocationAsComparable
    in
    if aRow > bRow then
        aLocationAsComparable

    else if bRow > aRow then
        bLocationAsComparable

    else
        ( aRow, Basics.max aColumn bColumn )


letDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
    ->
        Result
            String
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration (Type TypeVariableFromContext)
            }
letDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letDeclaration) =
    case letDeclaration of
        Elm.Syntax.Expression.LetDestructuring letDestructuringPattern letDestructuringExpression ->
            resultAndThen2
                (\patternInferred expressionInferred ->
                    Result.andThen
                        (\patternExpressionUnified ->
                            Result.map2
                                (\patternWithUnificationSubstitutionsApplied expressionWithUnificationSubstitutionsApplied ->
                                    { range = letDeclarationRange
                                    , declaration =
                                        LetDestructuring
                                            { pattern = patternWithUnificationSubstitutionsApplied
                                            , expression = expressionWithUnificationSubstitutionsApplied
                                            }
                                    }
                                )
                                (patternInferred
                                    |> patternTypedNodeApplyVariableSubstitutions
                                        context.declarationTypes
                                        patternExpressionUnified.substitutions
                                )
                                (expressionInferred
                                    |> expressionTypedNodeApplyVariableSubstitutions
                                        context.declarationTypes
                                        patternExpressionUnified.substitutions
                                )
                        )
                        (typeUnify
                            { declarationTypes = context.declarationTypes
                            , range = letDeclarationRange
                            }
                            patternInferred.type_
                            expressionInferred.type_
                        )
                )
                (letDestructuringPattern
                    |> patternTypeInfer
                        { declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        }
                )
                (letDestructuringExpression
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.LetFunction letValueOrFunction ->
            letFunctionOrValueDeclarationTypeInfer context
                (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction)


letFunctionOrValueDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Function
    ->
        Result
            String
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration (Type TypeVariableFromContext)
            }
letFunctionOrValueDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction) =
    let
        implementation : Elm.Syntax.Expression.FunctionImplementation
        implementation =
            letValueOrFunction.declaration |> Elm.Syntax.Node.value
    in
    Result.andThen
        (\parametersInferred ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = context.declarationTypes
                    , range = letDeclarationRange
                    }

                name : String
                name =
                    implementation.name |> Elm.Syntax.Node.value
            in
            case letValueOrFunction.signature of
                Nothing ->
                    Result.andThen
                        (\resultInferred ->
                            Result.andThen
                                (\substitutionsFromUnifyingParameterVariablesWithUses ->
                                    Result.map2
                                        (\parametersSubstituted resultSubstituted ->
                                            { range = letDeclarationRange
                                            , declaration =
                                                LetValueOrFunctionDeclaration
                                                    { signature = Nothing
                                                    , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                    , name = name
                                                    , parameters = parametersSubstituted
                                                    , result = resultSubstituted
                                                    , type_ =
                                                        parametersSubstituted
                                                            |> List.foldr
                                                                (\parameter outputTypeSoFar ->
                                                                    TypeNotVariable
                                                                        (TypeFunction
                                                                            { input = parameter.type_
                                                                            , output = outputTypeSoFar
                                                                            }
                                                                        )
                                                                )
                                                                resultSubstituted.type_
                                                    }
                                            }
                                        )
                                        (parametersInferred.nodes
                                            |> listFoldrWhileOkFrom []
                                                (\parameterInferred soFar ->
                                                    Result.map
                                                        (\parameterSubstituted ->
                                                            parameterSubstituted :: soFar
                                                        )
                                                        (parameterInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                substitutionsFromUnifyingParameterVariablesWithUses
                                                        )
                                                )
                                        )
                                        (resultInferred
                                            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                substitutionsFromUnifyingParameterVariablesWithUses
                                        )
                                )
                                (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                    typeContext
                                    parametersInferred.introducedExpressionVariables
                                    resultInferred
                                )
                        )
                        (implementation.expression
                            |> expressionTypeInfer
                                { declarationTypes = context.declarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , locallyIntroducedDeclarationTypes =
                                    context.locallyIntroducedDeclarationTypes
                                        |> -- elm declarations do not allow "polymorphic recursion"
                                           -- https://github.com/elm/compiler/issues/2275
                                           -- so instead of putting it in partiallyInferredDeclarationTypes
                                           -- we treat it as an introduced variable (sharing the same type variables)
                                           FastDict.remove name
                                , locallyIntroducedExpressionVariables =
                                    FastDict.union
                                        parametersInferred.introducedExpressionVariables
                                        context.locallyIntroducedExpressionVariables
                                        |> FastDict.insert name
                                            (TypeVariable
                                                ( letValueOrFunction
                                                    |> syntaxValueOrFunctionDeclarationRange
                                                    |> rangeToAsComparable
                                                , name
                                                )
                                            )
                                }
                        )

                Just (Elm.Syntax.Node.Node signatureRange letValueOrFunctionSignature) ->
                    Result.andThen
                        (\annotationAsType ->
                            let
                                annotationAsTypeWithContext : Type TypeVariableFromContext
                                annotationAsTypeWithContext =
                                    annotationAsType
                                        |> typeMapVariables
                                            (\variable ->
                                                ( letValueOrFunction
                                                    |> syntaxValueOrFunctionDeclarationRange
                                                    |> rangeToAsComparable
                                                , variable
                                                )
                                            )
                            in
                            Result.andThen
                                (\resultInferred ->
                                    Result.andThen
                                        (\typeUnifiedWithAnnotation ->
                                            Result.andThen
                                                (\substitutionsFromUnifyingParameterVariablesWithUses ->
                                                    Result.andThen
                                                        (\fullSubstitutions ->
                                                            Result.map3
                                                                (\parametersSubstituted resultSubstituted typeSubstituted ->
                                                                    { range = letDeclarationRange
                                                                    , declaration =
                                                                        LetValueOrFunctionDeclaration
                                                                            { signature =
                                                                                Just
                                                                                    { range = signatureRange
                                                                                    , nameRange =
                                                                                        letValueOrFunctionSignature.name |> Elm.Syntax.Node.range
                                                                                    , annotationType =
                                                                                        letValueOrFunctionSignature.typeAnnotation
                                                                                            |> Elm.Syntax.Node.value
                                                                                    , annotationTypeRange =
                                                                                        letValueOrFunctionSignature.typeAnnotation
                                                                                            |> Elm.Syntax.Node.range
                                                                                    }
                                                                            , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                            , name = name
                                                                            , parameters = parametersSubstituted
                                                                            , result = resultSubstituted
                                                                            , type_ = typeSubstituted
                                                                            }
                                                                    }
                                                                )
                                                                (parametersInferred.nodes
                                                                    |> listFoldrWhileOkFrom []
                                                                        (\parameter soFar ->
                                                                            Result.map
                                                                                (\parameterInferredSubstituted ->
                                                                                    parameterInferredSubstituted :: soFar
                                                                                )
                                                                                (parameter
                                                                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                                        fullSubstitutions
                                                                                )
                                                                        )
                                                                )
                                                                (resultInferred
                                                                    |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                        fullSubstitutions
                                                                )
                                                                (typeUnifiedWithAnnotation.type_
                                                                    |> typeApplyVariableSubstitutions
                                                                        typeContext
                                                                        fullSubstitutions
                                                                )
                                                        )
                                                        (variableSubstitutionsMerge
                                                            typeContext
                                                            substitutionsFromUnifyingParameterVariablesWithUses
                                                            typeUnifiedWithAnnotation.substitutions
                                                        )
                                                )
                                                (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                    typeContext
                                                    parametersInferred.introducedExpressionVariables
                                                    resultInferred
                                                )
                                        )
                                        (typeUnify typeContext
                                            annotationAsTypeWithContext
                                            (parametersInferred.nodes
                                                |> List.foldr
                                                    (\parameterTypedNode outputSoFar ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = parameterTypedNode.type_
                                                                , output = outputSoFar
                                                                }
                                                            )
                                                    )
                                                    resultInferred.type_
                                            )
                                        )
                                )
                                (implementation.expression
                                    |> expressionTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                                |> -- elm declarations do not allow "polymorphic recursion"
                                                   -- https://github.com/elm/compiler/issues/2275
                                                   -- so instead of putting it in partiallyInferredDeclarationTypes
                                                   -- we treat it as an introduced variable (sharing the same type variables)
                                                   FastDict.remove name
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                parametersInferred.introducedExpressionVariables
                                                |> FastDict.insert name
                                                    annotationAsTypeWithContext
                                        }
                                )
                        )
                        (letValueOrFunctionSignature.typeAnnotation
                            |> Elm.Syntax.Node.value
                            |> syntaxToType context.moduleOriginLookup
                        )
        )
        (implementation.arguments
            |> parameterPatternsTypeInfer
                { declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


moduleNameToString : Elm.Syntax.ModuleName.ModuleName -> String
moduleNameToString moduleName =
    moduleName |> String.join "."


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


expressionInfixOperationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , operator : String
        , left : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        , right : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionInfixOperationTypeInfer context infixOperation =
    resultAndThen3
        (\operatorAsFunctionType leftInferred rightInferred ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = context.declarationTypes
                    , range = infixOperation.fullRange
                    }
            in
            resultAndThen2
                (\unifiedLeftType unifiedRightType ->
                    Result.andThen
                        (\leftRightAndUnificationSubstitutions ->
                            { range = infixOperation.fullRange
                            , value =
                                ExpressionInfixOperation
                                    { operator =
                                        { type_ =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = leftInferred.type_
                                                    , output =
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = rightInferred.type_
                                                                , output = operatorAsFunctionType.resultType
                                                                }
                                                            )
                                                    }
                                                )
                                        , moduleOrigin = operatorAsFunctionType.moduleOrigin
                                        , symbol = infixOperation.operator
                                        }
                                    , left = leftInferred
                                    , right = rightInferred
                                    }
                            , type_ = operatorAsFunctionType.resultType
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    leftRightAndUnificationSubstitutions
                        )
                        (variableSubstitutionsMerge
                            typeContext
                            unifiedLeftType.substitutions
                            unifiedRightType.substitutions
                        )
                )
                (typeUnify typeContext
                    operatorAsFunctionType.leftType
                    leftInferred.type_
                )
                (typeUnify typeContext
                    operatorAsFunctionType.rightType
                    rightInferred.type_
                )
        )
        (operatorFunctionType
            { moduleOriginLookup = context.moduleOriginLookup
            , range =
                infixOperationApproximateOperatorRange
                    { operator = infixOperation.operator
                    , leftEnd = infixOperation.left |> Elm.Syntax.Node.range |> .end
                    , rightStart = infixOperation.right |> Elm.Syntax.Node.range |> .start
                    }
            }
            infixOperation.operator
        )
        (infixOperation.left |> expressionTypeInfer context)
        (infixOperation.right |> expressionTypeInfer context)


{-| elm-syntax should include this info (and will in v8)
This is just some stupid approximation to give better error messages
-}
infixOperationApproximateOperatorRange :
    { operator : String
    , leftEnd : Elm.Syntax.Range.Location
    , rightStart : Elm.Syntax.Range.Location
    }
    -> Elm.Syntax.Range.Range
infixOperationApproximateOperatorRange infixOperation =
    let
        operatorLength : Int
        operatorLength =
            infixOperation.operator |> String.length
    in
    if infixOperation.leftEnd.row - infixOperation.rightStart.row == 0 then
        if (infixOperation.leftEnd.column + operatorLength) - infixOperation.rightStart.column == 0 then
            -- x+y
            { start =
                { row = infixOperation.rightStart.row
                , column = infixOperation.leftEnd.column
                }
            , end =
                { row = infixOperation.rightStart.row
                , column = infixOperation.rightStart.column
                }
            }

        else
            -- assume
            -- x + y
            { start =
                { row = infixOperation.rightStart.row
                , column =
                    infixOperation.rightStart.column
                        - 1
                        - operatorLength
                }
            , end =
                { row = infixOperation.rightStart.row
                , column =
                    infixOperation.rightStart.column - 1
                }
            }

    else
        -- assume
        -- x
        --     + y
        { start =
            { row = infixOperation.rightStart.row
            , column =
                infixOperation.rightStart.column
                    - 1
                    - operatorLength
            }
        , end =
            { row = infixOperation.rightStart.row
            , column =
                infixOperation.rightStart.column - 1
            }
        }


operatorFunctionType :
    { range : Elm.Syntax.Range.Range
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> String
    ->
        Result
            String
            { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
            , leftType : Type TypeVariableFromContext
            , rightType : Type TypeVariableFromContext
            , resultType : Type TypeVariableFromContext
            }
operatorFunctionType context operator =
    case operator of
        "|>" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = a
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , resultType = b
                }

        "<|" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , rightType = a
                , resultType = b
                }

        ">>" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( rangeAsComparable, "c" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = b
                            , output = c
                            }
                        )
                , resultType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = c
                            }
                        )
                }

        "<<" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( rangeAsComparable, "c" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = b
                            , output = c
                            }
                        )
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , resultType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = c
                            }
                        )
                }

        "++" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                appendable : Type TypeVariableFromContext
                appendable =
                    TypeVariable ( rangeAsComparable, "appendable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = appendable
                , rightType = appendable
                , resultType = appendable
                }

        "==" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.range |> rangeToAsComparable, "equatable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = equatable
                , rightType = equatable
                , resultType = typeBasicsBool
                }

        "/=" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.range |> rangeToAsComparable, "equatable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = equatable
                , rightType = equatable
                , resultType = typeBasicsBool
                }

        "::" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.range |> rangeToAsComparable, "element" )
            in
            Ok
                { moduleOrigin = moduleNameList
                , leftType = a
                , rightType = typeListList a
                , resultType = typeListList a
                }

        "*" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.range |> rangeToAsComparable, "number" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "+" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.range |> rangeToAsComparable, "number" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "-" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.range |> rangeToAsComparable, "number" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "/" ->
            okFdivOperatorInfo

        "^" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.range |> rangeToAsComparable, "number" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "<=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.range |> rangeToAsComparable, "comparable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        ">=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.range |> rangeToAsComparable, "comparable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        ">" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.range |> rangeToAsComparable, "comparable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        "<" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.range |> rangeToAsComparable, "comparable" )
            in
            Ok
                { moduleOrigin = moduleNameBasics
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        "//" ->
            okIdivOperatorInfo

        "&&" ->
            okAndOperatorInfo

        "||" ->
            okOrOperatorInfo

        "|." ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable
            in
            Ok
                (if context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( rangeAsComparable, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( rangeAsComparable, "problem" )

                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( rangeAsComparable, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( rangeAsComparable, "ignore" )
                    in
                    { moduleOrigin = moduleNameParserAdvanced
                    , leftType = typeParserAdvancedParser varContext problem keep
                    , rightType = typeParserAdvancedParser varContext problem ignore
                    , resultType = typeParserAdvancedParser varContext problem keep
                    }

                 else
                    let
                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( rangeAsComparable, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( rangeAsComparable, "ignore" )
                    in
                    { moduleOrigin = moduleNameParser
                    , leftType = typeParserParser keep
                    , rightType = typeParserParser ignore
                    , resultType = typeParserParser keep
                    }
                )

        "|=" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable
            in
            Ok
                (if context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( rangeAsComparable, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( rangeAsComparable, "problem" )

                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( rangeAsComparable, "a" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( rangeAsComparable, "b" )
                    in
                    { moduleOrigin = moduleNameParserAdvanced
                    , leftType =
                        typeParserAdvancedParser
                            varContext
                            problem
                            (TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                            )
                    , rightType = typeParserAdvancedParser varContext problem a
                    , resultType = typeParserAdvancedParser varContext problem b
                    }

                 else
                    let
                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( rangeAsComparable, "a" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( rangeAsComparable, "b" )
                    in
                    { moduleOrigin = moduleNameParser
                    , leftType =
                        typeParserParser
                            (TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                            )
                    , rightType = typeParserParser a
                    , resultType = typeParserParser b
                    }
                )

        "</>" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( rangeAsComparable, "c" )
            in
            Ok
                { moduleOrigin = moduleNameUrlParser
                , leftType = typeUrlParserParser a b
                , rightType = typeUrlParserParser b c
                , resultType = typeUrlParserParser a c
                }

        "<?>" ->
            let
                rangeAsComparable : RangeAsComparable
                rangeAsComparable =
                    context.range |> rangeToAsComparable

                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( rangeAsComparable, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( rangeAsComparable, "b" )

                query : Type TypeVariableFromContext
                query =
                    TypeVariable ( rangeAsComparable, "query" )
            in
            Ok
                { moduleOrigin = moduleNameUrlParser
                , leftType =
                    typeUrlParserParser
                        a
                        (TypeNotVariable
                            (TypeFunction
                                { input = query
                                , output = b
                                }
                            )
                        )
                , rightType = typeUrlParserQueryParser query
                , resultType = typeUrlParserParser a b
                }

        unknownOperator ->
            Err
                ("("
                    ++ (context.range |> rangeToInfoString)
                    ++ ") "
                    ++ "unknown operator ("
                    ++ unknownOperator
                    ++ ")"
                )


okIdivOperatorInfo :
    Result
        error_
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , leftType : Type variable
        , rightType : Type variable
        , resultType : Type variable
        }
okIdivOperatorInfo =
    Ok
        { moduleOrigin = moduleNameBasics
        , leftType = typeBasicsInt
        , rightType = typeBasicsInt
        , resultType = typeBasicsInt
        }


okFdivOperatorInfo :
    Result
        error_
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , leftType : Type variable
        , rightType : Type variable
        , resultType : Type variable
        }
okFdivOperatorInfo =
    Ok
        { moduleOrigin = moduleNameBasics
        , leftType = typeBasicsFloat
        , rightType = typeBasicsFloat
        , resultType = typeBasicsFloat
        }


okOrOperatorInfo :
    Result
        error_
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , leftType : Type variable
        , rightType : Type variable
        , resultType : Type variable
        }
okOrOperatorInfo =
    Ok
        { moduleOrigin = moduleNameBasics
        , leftType = typeBasicsBool
        , rightType = typeBasicsBool
        , resultType = typeBasicsBool
        }


okAndOperatorInfo :
    Result
        error_
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , leftType : Type variable
        , rightType : Type variable
        , resultType : Type variable
        }
okAndOperatorInfo =
    Ok
        { moduleOrigin = moduleNameBasics
        , leftType = typeBasicsBool
        , rightType = typeBasicsBool
        , resultType = typeBasicsBool
        }


moduleNameBasics : Elm.Syntax.ModuleName.ModuleName
moduleNameBasics =
    [ "Basics" ]


moduleNameList : Elm.Syntax.ModuleName.ModuleName
moduleNameList =
    [ "List" ]


moduleNameParserAdvanced : Elm.Syntax.ModuleName.ModuleName
moduleNameParserAdvanced =
    [ "Parser", "Advanced" ]


moduleNameParser : Elm.Syntax.ModuleName.ModuleName
moduleNameParser =
    [ "Parser" ]


moduleNameUrlParserQuery : Elm.Syntax.ModuleName.ModuleName
moduleNameUrlParserQuery =
    [ "Url", "Parser", "Query" ]


moduleNameUrlParser : Elm.Syntax.ModuleName.ModuleName
moduleNameUrlParser =
    [ "Url", "Parser" ]


{-| Infer types of
value/[`Elm.Syntax.Expression.Function`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Function) declarations
in a module.

    import Elm.Syntax.Node
    import Elm.Syntax.Expression
    import ElmSyntaxTypeInfer


    [ { declaration =
            Elm.Syntax.Node.empty
                { name = Elm.Syntax.Node.empty "hello"
                , expression =
                    Elm.Syntax.Node.empty
                        (Elm.Syntax.Expression.Literal "world")
                , arguments = []
                }
      , signature = Nothing
      , documentation = Nothing
      }
    ]
        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
            { importedTypes = ElmSyntaxTypeInfer.elmCoreTypes
            , moduleOriginLookup = exampleModuleOriginLookup
            , otherModuleDeclaredTypes =
                []
                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                        exampleModuleOriginLookup
                    |> .types
            }
    -->
    Ok
        (FastDict.singleton "hello"
            { type_ =
                ElmSyntaxTypeInfer.TypeNotVariable
                    (ElmSyntaxTypeInfer.TypeConstruct
                        { moduleOrigin = [ "String" ], name = "String", arguments = [] }
                    )
            ...
            }
        )


    exampleModuleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
    exampleModuleOriginLookup =
        []
            |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                ElmSyntaxTypeInfer.elmCoreTypes

See [`ModuleTypes`](#ModuleTypes) and [`ModuleOriginLookup`](#ModuleOriginLookup)

Warning! Always first verify that provided type alias declarations aren't (mutually) recursive.
Otherwise this function might never terminate.

-}
valueAndFunctionDeclarations :
    { importedTypes :
        FastDict.Dict
            Elm.Syntax.ModuleName.ModuleName
            ModuleTypes
    , moduleOriginLookup : ModuleOriginLookup
    , otherModuleDeclaredTypes : ModuleTypes
    }
    -> List Elm.Syntax.Expression.Function
    ->
        Result
            String
            (FastDict.Dict
                String
                { parameters :
                    List (TypedNode (Pattern (Type String)) (Type String))
                , result : TypedNode (Expression (Type String)) (Type String)
                , type_ : Type String
                , nameRange : Elm.Syntax.Range.Range
                , documentation :
                    Maybe
                        { content : String
                        , range : Elm.Syntax.Range.Range
                        }
                , signature :
                    Maybe
                        { range : Elm.Syntax.Range.Range
                        , nameRange : Elm.Syntax.Range.Range
                        , annotationTypeRange : Elm.Syntax.Range.Range
                        , -- variables names in here might not correspond
                          -- with those in .type_
                          annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                        }
                }
            )
valueAndFunctionDeclarations typesAndOriginLookup syntaxValueAndFunctionDeclarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            { keepOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced
            , ignoreOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced
            , typeConstructs =
                typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                    |> FastDict.foldl
                        (\choiceTypeName _ soFar ->
                            soFar
                                |> FastDict.insert ( [], choiceTypeName )
                                    []
                        )
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> FastDict.foldl
                                (\typeAliasName _ soFar ->
                                    soFar
                                        |> FastDict.insert ( [], typeAliasName )
                                            []
                                )
                                typesAndOriginLookup.moduleOriginLookup.typeConstructs
                        )
            , references =
                typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                    |> FastDict.foldl
                        (\_ info soFar ->
                            info.variants
                                |> FastDict.foldl
                                    (\variantName _ soFarWithVariantNames ->
                                        soFarWithVariantNames
                                            |> FastDict.insert ( [], variantName )
                                                []
                                    )
                                    soFar
                        )
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> FastDict.foldl
                                (\typeAliasName info soFar ->
                                    case info.recordFieldOrder of
                                        Nothing ->
                                            soFar

                                        Just _ ->
                                            soFar |> FastDict.insert ( [], typeAliasName ) []
                                )
                                (typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                                    |> FastDict.foldl
                                        (\signatureName _ soFar ->
                                            soFar
                                                |> FastDict.insert ( [], signatureName )
                                                    []
                                        )
                                        (syntaxValueAndFunctionDeclarations
                                            |> List.foldl
                                                (\valueOrFunctionDeclaration soFar ->
                                                    soFar
                                                        |> FastDict.insert
                                                            ( []
                                                            , valueOrFunctionDeclaration.declaration
                                                                |> Elm.Syntax.Node.value
                                                                |> .name
                                                                |> Elm.Syntax.Node.value
                                                            )
                                                            []
                                                )
                                                typesAndOriginLookup.moduleOriginLookup.references
                                        )
                                )
                        )
            }

        acrossValueAndFunctionDeclarationsToInfer :
            { partiallyInferredDeclarationTypes :
                FastDict.Dict
                    String
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            , annotated : FastDict.Dict String (Type String)
            }
        acrossValueAndFunctionDeclarationsToInfer =
            syntaxValueAndFunctionDeclarations
                |> List.foldl
                    (\syntaxValueOrFunctionDeclaration soFar ->
                        let
                            name : String
                            name =
                                syntaxValueOrFunctionDeclaration.declaration
                                    |> Elm.Syntax.Node.value
                                    |> .name
                                    |> Elm.Syntax.Node.value
                        in
                        case syntaxValueOrFunctionDeclaration.signature of
                            Nothing ->
                                let
                                    declarationRange : Elm.Syntax.Range.Range
                                    declarationRange =
                                        syntaxValueOrFunctionDeclaration
                                            |> syntaxValueOrFunctionDeclarationRange
                                in
                                { annotated = soFar.annotated
                                , partiallyInferredDeclarationTypes =
                                    soFar.partiallyInferredDeclarationTypes
                                        |> FastDict.insert name
                                            { type_ =
                                                TypeVariable
                                                    ( declarationRange |> rangeToAsComparable
                                                    , name
                                                    )
                                            , range = declarationRange
                                            }
                                }

                            Just (Elm.Syntax.Node.Node _ signature) ->
                                case
                                    signature.typeAnnotation
                                        |> Elm.Syntax.Node.value
                                        |> syntaxToType moduleOriginLookup
                                of
                                    Err _ ->
                                        -- error will be reported later
                                        soFar

                                    Ok type_ ->
                                        { partiallyInferredDeclarationTypes =
                                            soFar.partiallyInferredDeclarationTypes
                                        , annotated =
                                            soFar.annotated
                                                |> FastDict.insert name type_
                                        }
                    )
                    partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty

        declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        declarationTypes =
            typesAndOriginLookup.importedTypes
                |> FastDict.map
                    (\moduleName moduleDeclarationTypes ->
                        moduleDeclarationTypes
                            |> moduleTypesSetLocalTypesToOrigin moduleName
                    )
                |> FastDict.insert []
                    { signatures =
                        FastDict.union
                            typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                            acrossValueAndFunctionDeclarationsToInfer.annotated
                    , typeAliases = typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                    , choiceTypes = typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                    }

        parameterPatternsContext :
            { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
            , moduleOriginLookup : ModuleOriginLookup
            }
        parameterPatternsContext =
            { declarationTypes = declarationTypes
            , moduleOriginLookup = moduleOriginLookup
            }
    in
    syntaxValueAndFunctionDeclarations
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\valueOrFunctionDeclarationToInfer soFar ->
                let
                    implementation : Elm.Syntax.Expression.FunctionImplementation
                    implementation =
                        valueOrFunctionDeclarationToInfer.declaration
                            |> Elm.Syntax.Node.value

                    name : String
                    name =
                        implementation.name |> Elm.Syntax.Node.value
                in
                Result.andThen
                    (\parametersInferred ->
                        let
                            valueOrFunctionDeclarationToInferRange : Elm.Syntax.Range.Range
                            valueOrFunctionDeclarationToInferRange =
                                valueOrFunctionDeclarationToInfer
                                    |> syntaxValueOrFunctionDeclarationRange

                            maybeDocumentationAndRange : Maybe { range : Elm.Syntax.Range.Range, content : String }
                            maybeDocumentationAndRange =
                                case valueOrFunctionDeclarationToInfer.documentation of
                                    Nothing ->
                                        Nothing

                                    Just (Elm.Syntax.Node.Node documentationRange documentationContent) ->
                                        Just
                                            { range = documentationRange
                                            , content = documentationContent
                                            }

                            typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                            typeContext =
                                { declarationTypes = declarationTypes
                                , range = valueOrFunctionDeclarationToInferRange
                                }
                        in
                        case valueOrFunctionDeclarationToInfer.signature of
                            Nothing ->
                                Result.andThen
                                    (\resultInferred ->
                                        Result.andThen
                                            (\parameterPatternVariablesAndUsesUnificationSubstitutions ->
                                                Result.map2
                                                    (\resultSubstituted parametersSubstituted ->
                                                        let
                                                            inferredFullType : Type TypeVariableFromContext
                                                            inferredFullType =
                                                                parametersSubstituted
                                                                    |> List.foldr
                                                                        (\parameterTypedNode typeSoFar ->
                                                                            TypeNotVariable
                                                                                (TypeFunction
                                                                                    { input = parameterTypedNode.type_
                                                                                    , output = typeSoFar
                                                                                    }
                                                                                )
                                                                        )
                                                                        resultInferred.type_
                                                        in
                                                        soFar
                                                            |> FastDict.insert name
                                                                { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                , documentation = maybeDocumentationAndRange
                                                                , signature = Nothing
                                                                , result = resultSubstituted
                                                                , type_ = inferredFullType
                                                                , parameters = parametersSubstituted
                                                                }
                                                    )
                                                    (resultInferred
                                                        |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                            parameterPatternVariablesAndUsesUnificationSubstitutions
                                                    )
                                                    (parametersInferred.nodes
                                                        |> listFoldrWhileOkFrom []
                                                            (\parameterInferred parametersSubstitutedSoFar ->
                                                                Result.map
                                                                    (\parameterSubstituted ->
                                                                        parameterSubstituted :: parametersSubstitutedSoFar
                                                                    )
                                                                    (parameterInferred
                                                                        |> patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                                            parameterPatternVariablesAndUsesUnificationSubstitutions
                                                                    )
                                                            )
                                                    )
                                            )
                                            (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                typeContext
                                                (parametersInferred.nodes
                                                    |> listMapToFastDictsAndUnify
                                                        patternTypedNodeIntroducedVariables
                                                )
                                                resultInferred
                                            )
                                    )
                                    (implementation.expression
                                        |> expressionTypeInfer
                                            { declarationTypes = declarationTypes
                                            , locallyIntroducedExpressionVariables =
                                                -- elm declarations do not allow "polymorphic recursion"
                                                -- https://github.com/elm/compiler/issues/2275
                                                -- so instead of putting it in partiallyInferredDeclarationTypes
                                                -- we treat it as an introduced variable (sharing the same type variables)
                                                parametersInferred.introducedExpressionVariables
                                                    |> FastDict.insert name
                                                        (TypeVariable
                                                            ( valueOrFunctionDeclarationToInferRange
                                                                |> rangeToAsComparable
                                                            , name
                                                            )
                                                        )
                                            , locallyIntroducedDeclarationTypes =
                                                acrossValueAndFunctionDeclarationsToInfer.partiallyInferredDeclarationTypes
                                                    |> FastDict.remove name
                                            , moduleOriginLookup = moduleOriginLookup
                                            }
                                    )

                            Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                case
                                    acrossValueAndFunctionDeclarationsToInfer.annotated
                                        |> FastDict.get name
                                of
                                    Nothing ->
                                        Err
                                            ("bug in elm-syntax-type-infer: failed to retrieve annotation type for "
                                                ++ name
                                            )

                                    Just annotationType ->
                                        Result.andThen
                                            (\resultInferred ->
                                                let
                                                    inferredFullType : Type TypeVariableFromContext
                                                    inferredFullType =
                                                        parametersInferred.nodes
                                                            |> List.foldr
                                                                (\parameterTypedNode typeSoFar ->
                                                                    TypeNotVariable
                                                                        (TypeFunction
                                                                            { input = parameterTypedNode.type_
                                                                            , output = typeSoFar
                                                                            }
                                                                        )
                                                                )
                                                                resultInferred.type_

                                                    fullType : Type TypeVariableFromContext
                                                    fullType =
                                                        annotationType
                                                            |> typeMapVariables
                                                                (\variable ->
                                                                    ( valueOrFunctionDeclarationToInferRange
                                                                        |> rangeToAsComparable
                                                                    , variable
                                                                    )
                                                                )
                                                in
                                                resultAndThen2
                                                    (\inferredDeclarationTypeUnifiedWithAnnotation substitutionsFromUnifyingParameterVariablesWithUses ->
                                                        Result.andThen
                                                            (\fullSubstitutions ->
                                                                Result.map3
                                                                    (\typeSubstituted resultSubstituted parametersSubstituted ->
                                                                        soFar
                                                                            |> FastDict.insert name
                                                                                { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                                , documentation = maybeDocumentationAndRange
                                                                                , signature =
                                                                                    Just
                                                                                        { range = signatureRange
                                                                                        , nameRange = signature.name |> Elm.Syntax.Node.range
                                                                                        , annotationType = signature.typeAnnotation |> Elm.Syntax.Node.value
                                                                                        , annotationTypeRange = signature.typeAnnotation |> Elm.Syntax.Node.range
                                                                                        }
                                                                                , result = resultSubstituted
                                                                                , type_ = typeSubstituted
                                                                                , parameters = parametersSubstituted
                                                                                }
                                                                    )
                                                                    (fullType
                                                                        |> typeApplyVariableSubstitutions
                                                                            typeContext
                                                                            fullSubstitutions
                                                                    )
                                                                    (resultInferred
                                                                        |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                                            fullSubstitutions
                                                                    )
                                                                    (parametersInferred.nodes
                                                                        |> listFoldrWhileOkFrom []
                                                                            (\parameterInferred parametersSubstitutedSoFar ->
                                                                                Result.map
                                                                                    (\parameterSubstituted ->
                                                                                        parameterSubstituted :: parametersSubstitutedSoFar
                                                                                    )
                                                                                    (parameterInferred
                                                                                        |> patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                                                            fullSubstitutions
                                                                                    )
                                                                            )
                                                                    )
                                                            )
                                                            (variableSubstitutionsMerge
                                                                typeContext
                                                                substitutionsFromUnifyingParameterVariablesWithUses
                                                                inferredDeclarationTypeUnifiedWithAnnotation.substitutions
                                                            )
                                                    )
                                                    (typeUnify typeContext
                                                        fullType
                                                        inferredFullType
                                                    )
                                                    (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                        typeContext
                                                        parametersInferred.introducedExpressionVariables
                                                        resultInferred
                                                    )
                                            )
                                            (implementation.expression
                                                |> expressionTypeInfer
                                                    { declarationTypes = declarationTypes
                                                    , locallyIntroducedExpressionVariables =
                                                        parametersInferred.nodes
                                                            |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                                    , locallyIntroducedDeclarationTypes =
                                                        acrossValueAndFunctionDeclarationsToInfer.partiallyInferredDeclarationTypes
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    }
                                            )
                    )
                    (implementation.arguments
                        |> parameterPatternsTypeInfer
                            parameterPatternsContext
                    )
                    |> Result.mapError
                        (\inferError ->
                            "inferring the value/function declaration "
                                ++ name
                                ++ ": "
                                ++ inferError
                        )
            )
        |> Result.andThen
            (\declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations ->
                let
                    unannotatedDeclarationTypes :
                        FastDict.Dict
                            String
                            { range : Elm.Syntax.Range.Range
                            , type_ : Type TypeVariableFromContext
                            }
                    unannotatedDeclarationTypes =
                        declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                            |> FastDict.foldl
                                (\declarationName declaration soFar ->
                                    case declaration.signature of
                                        Just _ ->
                                            soFar

                                        Nothing ->
                                            soFar
                                                |> FastDict.insert declarationName
                                                    { type_ = declaration.type_
                                                    , range =
                                                        declaration
                                                            |> valueOrFunctionDeclarationInfoRange
                                                    }
                                )
                                FastDict.empty
                in
                -- TODO optimization: if declaration is annotated, apply subs directly
                Result.andThen
                    (\substitutionsForInstanceUnifyingUnannotatedDeclarationTypesWithUses ->
                        declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                            |> valueAndFunctionDeclarationsApplyVariableSubstitutions
                                declarationTypes
                                substitutionsForInstanceUnifyingUnannotatedDeclarationTypesWithUses
                    )
                    (declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                        |> fastDictFoldlWhileOkFrom
                            variableSubstitutionsNone
                            (\_ declarationInfo soFar ->
                                Result.andThen
                                    (\resultSubstitutions ->
                                        variableSubstitutionsMerge
                                            { declarationTypes = declarationTypes
                                            , range = everywhereRange
                                            }
                                            soFar
                                            resultSubstitutions
                                    )
                                    (declarationInfo.result
                                        |> substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression
                                            { declarationTypes = declarationTypes
                                            , range = declarationInfo |> valueOrFunctionDeclarationInfoRange
                                            }
                                            unannotatedDeclarationTypes
                                    )
                            )
                    )
            )
        |> Result.map
            (\fullySubstitutedDeclarationsTypedWithContext ->
                fullySubstitutedDeclarationsTypedWithContext
                    |> FastDict.map
                        (\_ declaration ->
                            declaration |> declarationValueOrFunctionInfoDisambiguateTypeVariables
                        )
            )


syntaxValueOrFunctionDeclarationRange : Elm.Syntax.Expression.Function -> Elm.Syntax.Range.Range
syntaxValueOrFunctionDeclarationRange syntaxValueOrFunctionDeclaration =
    { start =
        case syntaxValueOrFunctionDeclaration.documentation of
            Just (Elm.Syntax.Node.Node documentationRange _) ->
                documentationRange.start

            Nothing ->
                case syntaxValueOrFunctionDeclaration.signature of
                    Just (Elm.Syntax.Node.Node signatureRange _) ->
                        signatureRange.start

                    Nothing ->
                        syntaxValueOrFunctionDeclaration.declaration
                            |> Elm.Syntax.Node.range
                            |> .start
    , end =
        syntaxValueOrFunctionDeclaration.declaration
            |> Elm.Syntax.Node.range
            |> .end
    }


valueAndFunctionDeclarationsApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            (FastDict.Dict
                String
                (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            )
valueAndFunctionDeclarationsApplyVariableSubstitutions declarationTypes substitutionsToApply valueAndFunctionDeclarationsSoFar =
    let
        everywhereTypeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
        everywhereTypeContext =
            { declarationTypes = declarationTypes
            , range = everywhereRange
            }
    in
    case substitutionsToApply.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableCondenseLookup ->
                    let
                        variableToCondensedIfNecessary : TypeVariableFromContext -> TypeVariableFromContext
                        variableToCondensedIfNecessary variable =
                            variableCondenseLookup
                                |> FastDict.get variable
                                |> Maybe.withDefault
                                    variable

                        valueAndFunctionDeclarationsCondensed :
                            FastDict.Dict
                                String
                                (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
                        valueAndFunctionDeclarationsCondensed =
                            valueAndFunctionDeclarationsSoFar
                                |> FastDict.map
                                    (\_ declarationValueOrFunctionToCondenseVariablesIn ->
                                        declarationValueOrFunctionToCondenseVariablesIn
                                            |> declarationValueOrFunctionInfoMapTypeVariables
                                                variableToCondensedIfNecessary
                                    )

                        newSubstitutionsOrError : Result String VariableSubstitutions
                        newSubstitutionsOrError =
                            Result.andThen
                                (\variableSubstitutionsCondensed ->
                                    let
                                        moduleLevelPartiallyInferredDeclarations :
                                            FastDict.Dict
                                                String
                                                { range : Elm.Syntax.Range.Range
                                                , type_ : Type TypeVariableFromContext
                                                }
                                        moduleLevelPartiallyInferredDeclarations =
                                            valueAndFunctionDeclarationsSoFar
                                                |> valueAndFunctionDeclarationsGetPartiallyInferred

                                        allUnannotatedInferredDeclarationsUsesAfterCondensing :
                                            FastDict.Dict
                                                String
                                                (FastDict.Dict
                                                    RangeAsComparable
                                                    (Type TypeVariableFromContext)
                                                )
                                        allUnannotatedInferredDeclarationsUsesAfterCondensing =
                                            valueAndFunctionDeclarationsCondensed
                                                |> valueAndFunctionDeclarationsUsesOfLocalReferences
                                                    moduleLevelPartiallyInferredDeclarations

                                        unannotatedDeclarationsAndUsesThatGotMoreStrictAfterSubstitution :
                                            List
                                                { uses :
                                                    FastDict.Dict
                                                        RangeAsComparable
                                                        (Type TypeVariableFromContext)
                                                , moreStrictInferredDeclarationType : Type TypeVariableFromContext
                                                }
                                        unannotatedDeclarationsAndUsesThatGotMoreStrictAfterSubstitution =
                                            allUnannotatedInferredDeclarationsUsesAfterCondensing
                                                |> FastDict.foldl
                                                    (\unannotatedInferredDeclarationName uses partialTypeVariableAmongEquivalentVariablesSoFar ->
                                                        case moduleLevelPartiallyInferredDeclarations |> FastDict.get unannotatedInferredDeclarationName of
                                                            Nothing ->
                                                                partialTypeVariableAmongEquivalentVariablesSoFar

                                                            Just inferredDeclarationBeforeCondensing ->
                                                                case valueAndFunctionDeclarationsCondensed |> FastDict.get unannotatedInferredDeclarationName of
                                                                    Nothing ->
                                                                        partialTypeVariableAmongEquivalentVariablesSoFar

                                                                    Just inferredDeclarationCondensed ->
                                                                        let
                                                                            unannotatedInferredDeclarationTypeBeforeCondensingContainedVariables : FastSetFast TypeVariableFromContext
                                                                            unannotatedInferredDeclarationTypeBeforeCondensingContainedVariables =
                                                                                inferredDeclarationBeforeCondensing.type_
                                                                                    |> typeContainedVariables
                                                                        in
                                                                        if
                                                                            unannotatedInferredDeclarationTypeBeforeCondensingContainedVariables
                                                                                |> fastSetFastAny
                                                                                    (\variableBeforeCondensing ->
                                                                                        variableCondenseLookup |> FastDict.member variableBeforeCondensing
                                                                                    )
                                                                        then
                                                                            let
                                                                                unannotatedInferredDeclarationTypeCondensedContainedVariables : FastSetFast TypeVariableFromContext
                                                                                unannotatedInferredDeclarationTypeCondensedContainedVariables =
                                                                                    inferredDeclarationCondensed.type_
                                                                                        |> typeContainedVariables
                                                                            in
                                                                            -- if we don't check whether the condensed type
                                                                            -- is _actually_ more strict, we could end up in an endless loop
                                                                            -- if partially declared types cross-influence each other.
                                                                            if
                                                                                typesAreEquallyStrict
                                                                                    unannotatedInferredDeclarationTypeBeforeCondensingContainedVariables
                                                                                    unannotatedInferredDeclarationTypeCondensedContainedVariables
                                                                            then
                                                                                partialTypeVariableAmongEquivalentVariablesSoFar

                                                                            else
                                                                                { moreStrictInferredDeclarationType =
                                                                                    inferredDeclarationCondensed.type_
                                                                                , uses = uses
                                                                                }
                                                                                    :: partialTypeVariableAmongEquivalentVariablesSoFar

                                                                        else
                                                                            partialTypeVariableAmongEquivalentVariablesSoFar
                                                    )
                                                    []
                                    in
                                    unannotatedDeclarationsAndUsesThatGotMoreStrictAfterSubstitution
                                        |> listFoldlWhileOkFrom
                                            variableSubstitutionsCondensed
                                            (\partialTypeVariableAmongEquivalentVariables substitutionsWithPartialUsesUpdatedSoFar ->
                                                partialTypeVariableAmongEquivalentVariables.uses
                                                    |> fastDictFoldlWhileOkFrom
                                                        substitutionsWithPartialUsesUpdatedSoFar
                                                        (\useRangeAsComparable useType unificationSubstitutionsSoFar ->
                                                            let
                                                                partialTypeNewInstance : Type TypeVariableFromContext
                                                                partialTypeNewInstance =
                                                                    partialTypeVariableAmongEquivalentVariables.moreStrictInferredDeclarationType
                                                                        |> typeMapVariables
                                                                            (\( _, variableName ) ->
                                                                                ( useRangeAsComparable
                                                                                , variableName
                                                                                )
                                                                            )
                                                            in
                                                            Result.andThen
                                                                (\unified ->
                                                                    variableSubstitutionsMerge
                                                                        everywhereTypeContext
                                                                        unificationSubstitutionsSoFar
                                                                        unified.substitutions
                                                                )
                                                                (typeUnify everywhereTypeContext
                                                                    partialTypeNewInstance
                                                                    useType
                                                                )
                                                        )
                                            )
                                )
                                (substitutionsToApply.variableToType
                                    |> variableToTypeSubstitutionsCondenseVariables
                                        everywhereTypeContext
                                        variableCondenseLookup
                                )
                    in
                    case newSubstitutionsOrError of
                        Err error ->
                            Err error

                        Ok newSubstitutions ->
                            valueAndFunctionDeclarationsApplyVariableSubstitutions
                                declarationTypes
                                newSubstitutions
                                valueAndFunctionDeclarationsCondensed

        [] ->
            if substitutionsToApply.variableToType |> FastDict.isEmpty then
                Ok valueAndFunctionDeclarationsSoFar

            else
                case
                    substitutionsToApply.variableToType
                        |> substitutionsVariableToTypeApplyOverItself everywhereTypeContext
                of
                    Err error ->
                        Err error

                    Ok variableToTypeSubstitutedOverItself ->
                        case
                            valueAndFunctionDeclarationsSoFar
                                |> valueAndFunctionDeclarationsSubstituteVariableByNotVariable
                                    declarationTypes
                                    variableToTypeSubstitutedOverItself
                        of
                            Err error ->
                                Err error

                            Ok valueAndFunctionDeclarationsSubstituted ->
                                let
                                    moduleLevelPartiallyInferredDeclarations :
                                        FastDict.Dict
                                            String
                                            { range : Elm.Syntax.Range.Range
                                            , type_ : Type TypeVariableFromContext
                                            }
                                    moduleLevelPartiallyInferredDeclarations =
                                        valueAndFunctionDeclarationsSoFar
                                            |> valueAndFunctionDeclarationsGetPartiallyInferred

                                    allPartiallyInferredDeclarationsAndUsesAfterSubstitution :
                                        FastDict.Dict
                                            String
                                            (FastDict.Dict
                                                RangeAsComparable
                                                (Type TypeVariableFromContext)
                                            )
                                    allPartiallyInferredDeclarationsAndUsesAfterSubstitution =
                                        valueAndFunctionDeclarationsSubstituted.declarations
                                            |> valueAndFunctionDeclarationsUsesOfLocalReferences
                                                moduleLevelPartiallyInferredDeclarations

                                    substitutionsOfPartiallyInferredDeclarationUses :
                                        List
                                            { uses :
                                                FastDict.Dict
                                                    RangeAsComparable
                                                    (Type TypeVariableFromContext)
                                            , partiallyInferredDeclarationType : Type TypeVariableFromContext
                                            }
                                    substitutionsOfPartiallyInferredDeclarationUses =
                                        allPartiallyInferredDeclarationsAndUsesAfterSubstitution
                                            |> FastDict.foldl
                                                (\unannotatedInferredDeclarationName uses soFar ->
                                                    case valueAndFunctionDeclarationsSubstituted.declarations |> FastDict.get unannotatedInferredDeclarationName of
                                                        Nothing ->
                                                            soFar

                                                        Just inferredDeclarationAfterSubstituting ->
                                                            if
                                                                valueAndFunctionDeclarationsSubstituted.unchangedDeclarations
                                                                    |> FastDict.member unannotatedInferredDeclarationName
                                                            then
                                                                { uses = uses
                                                                , partiallyInferredDeclarationType =
                                                                    inferredDeclarationAfterSubstituting.type_
                                                                }
                                                                    :: soFar

                                                            else
                                                                soFar
                                                )
                                                []

                                    updatePartiallyInferredSubstitutionsOrError : Result String VariableSubstitutions
                                    updatePartiallyInferredSubstitutionsOrError =
                                        substitutionsOfPartiallyInferredDeclarationUses
                                            |> listFoldlWhileOkFrom
                                                variableSubstitutionsNone
                                                (\substitutionOfPartiallyInferredDeclaration substitutionsSoFar ->
                                                    substitutionOfPartiallyInferredDeclaration.uses
                                                        |> fastDictFoldlWhileOkFrom
                                                            substitutionsSoFar
                                                            (\useRangeAsComparable useType unificationSubstitutionsWithUsesSoFar ->
                                                                let
                                                                    partialTypeNewInstance : Type TypeVariableFromContext
                                                                    partialTypeNewInstance =
                                                                        substitutionOfPartiallyInferredDeclaration.partiallyInferredDeclarationType
                                                                            |> typeMapVariables
                                                                                (\( _, variableName ) ->
                                                                                    ( useRangeAsComparable
                                                                                    , variableName
                                                                                    )
                                                                                )
                                                                in
                                                                Result.andThen
                                                                    (\unified ->
                                                                        variableSubstitutionsMerge
                                                                            everywhereTypeContext
                                                                            unificationSubstitutionsWithUsesSoFar
                                                                            unified.substitutions
                                                                    )
                                                                    (typeUnify
                                                                        everywhereTypeContext
                                                                        partialTypeNewInstance
                                                                        useType
                                                                    )
                                                            )
                                                )
                                in
                                case updatePartiallyInferredSubstitutionsOrError of
                                    Err error ->
                                        Err error

                                    Ok updatePartiallyInferredSubstitutions ->
                                        case
                                            variableSubstitutionsMerge
                                                everywhereTypeContext
                                                valueAndFunctionDeclarationsSubstituted.substitutions
                                                updatePartiallyInferredSubstitutions
                                        of
                                            Err error ->
                                                Err error

                                            Ok substitutionsAfterSubstitution ->
                                                valueAndFunctionDeclarationsApplyVariableSubstitutions
                                                    declarationTypes
                                                    substitutionsAfterSubstitution
                                                    valueAndFunctionDeclarationsSubstituted.declarations


partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty :
    { partiallyInferredDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type TypeVariableFromContext
            , range : Elm.Syntax.Range.Range
            }
    , annotated : FastDict.Dict String (Type String)
    }
partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty =
    { partiallyInferredDeclarationTypes = FastDict.empty
    , annotated = FastDict.empty
    }


moduleTypesSetLocalTypesToOrigin : Elm.Syntax.ModuleName.ModuleName -> ModuleTypes -> ModuleTypes
moduleTypesSetLocalTypesToOrigin moduleOrigin moduleTypes =
    { signatures =
        moduleTypes.signatures
            |> FastDict.map
                (\_ type_ ->
                    type_ |> typeSetLocalToOrigin moduleOrigin
                )
    , typeAliases =
        moduleTypes.typeAliases
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , recordFieldOrder = typeAlias.recordFieldOrder
                    , type_ =
                        typeAlias.type_
                            |> typeSetLocalToOrigin moduleOrigin
                    }
                )
    , choiceTypes =
        moduleTypes.choiceTypes
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , variants =
                        typeAlias.variants
                            |> FastDict.map
                                (\_ values ->
                                    values
                                        |> List.map
                                            (\type_ ->
                                                type_ |> typeSetLocalToOrigin moduleOrigin
                                            )
                                )
                    }
                )
    }


typeSetLocalToOrigin : Elm.Syntax.ModuleName.ModuleName -> Type variable -> Type variable
typeSetLocalToOrigin moduleOrigin type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariable variable

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariableSetLocalToOrigin moduleOrigin typeNotVariable)


typeNotVariableSetLocalToOrigin :
    Elm.Syntax.ModuleName.ModuleName
    -> TypeNotVariable variable
    -> TypeNotVariable variable
typeNotVariableSetLocalToOrigin moduleOrigin typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            TypeConstruct
                { name = typeConstruct.name
                , moduleOrigin =
                    case typeConstruct.moduleOrigin of
                        [] ->
                            moduleOrigin

                        moduleOriginPart0 :: moduleOriginPart1Up ->
                            moduleOriginPart0 :: moduleOriginPart1Up
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }

        TypeUnit ->
            TypeUnit

        TypeFunction parts ->
            TypeFunction
                { input =
                    parts.input
                        |> typeSetLocalToOrigin moduleOrigin
                , output =
                    parts.output
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTuple parts ->
            TypeTuple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTriple parts ->
            TypeTriple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                , part2 =
                    parts.part2
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeRecord fields ->
            TypeRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue
                                |> typeSetLocalToOrigin moduleOrigin
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable = typeRecordExtension.recordVariable
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }


variableSubstitutionsFromVariableToType :
    TypeVariableFromContext
    -> Type TypeVariableFromContext
    -> Result String VariableSubstitutions
variableSubstitutionsFromVariableToType variableToReplace replacementType =
    case replacementType of
        TypeNotVariable replacementTypeNotVariable ->
            -- TODO use variableSubstitutionsFromVariableToTypeNotVariableOrError
            -- to detect self-referential substitution
            Ok
                { variableToType =
                    FastDict.singleton variableToReplace
                        replacementTypeNotVariable
                , equivalentVariables = []
                }

        TypeVariable replacementVariable ->
            variableSubstitutionsFrom2EquivalentVariables
                variableToReplace
                replacementVariable


variableSubstitutionsFrom2EquivalentVariables :
    TypeVariableFromContext
    -> TypeVariableFromContext
    -> Result String VariableSubstitutions
variableSubstitutionsFrom2EquivalentVariables aVariable bVariable =
    if typeVariableFromContextEquals aVariable bVariable then
        okVariableSubstitutionsNone

    else
        let
            ( aVariableUseRangeAsComparable, aVariableName ) =
                aVariable

            ( bVariableUseRangeAsComparable, bVariableName ) =
                bVariable
        in
        Result.map
            (\abConstraint ->
                { variableToType = FastDict.empty
                , equivalentVariables =
                    [ { variables =
                            FastDict.singleton aVariable ()
                                |> FastDict.insert bVariable ()
                      , constraint = abConstraint
                      , overarchingRangeAsComparable =
                            rangeAsComparableOverarching
                                aVariableUseRangeAsComparable
                                bVariableUseRangeAsComparable
                      }
                    ]
                }
            )
            (maybeTypeVariableConstraintMerge
                (aVariableName |> typeVariableConstraint)
                (bVariableName |> typeVariableConstraint)
            )


type alias ValueOrFunctionDeclarationInfo type_ =
    { nameRange : Elm.Syntax.Range.Range
    , documentation :
        Maybe
            { content : String
            , range : Elm.Syntax.Range.Range
            }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , -- variables names in here might not correspond
              -- with those in .type_
              annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters :
        List (TypedNode (Pattern type_) type_)
    , result : TypedNode (Expression type_) type_
    , type_ : type_
    }


type alias ModuleLevelDeclarationTypesAvailableInModule =
    FastDict.Dict
        -- `[]` means declared in the same module
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes


declarationValueOrFunctionInfoDisambiguateTypeVariables :
    ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    -> ValueOrFunctionDeclarationInfo (Type String)
declarationValueOrFunctionInfoDisambiguateTypeVariables declarationValueOrFunctionInfo =
    let
        globalTypeVariableDisambiguationLookup : FastDict.Dict TypeVariableFromContext String
        globalTypeVariableDisambiguationLookup =
            typeVariablesFromContextToDisambiguationLookup
                (declarationValueOrFunctionInfo
                    |> valueOrFunctionDeclarationInfoContainedTypeVariables
                )
    in
    declarationValueOrFunctionInfo
        |> declarationValueOrFunctionInfoMapTypeVariables
            (\variable ->
                globalTypeVariableDisambiguationLookup
                    |> FastDict.get variable
                    |> Maybe.withDefault
                        "thisIsABugInDisambiguationPleaseReportToElmSyntaxTypeInfer"
            )


valueOrFunctionDeclarationInfoContainedTypeVariables :
    ValueOrFunctionDeclarationInfo (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
valueOrFunctionDeclarationInfoContainedTypeVariables declarationValueOrFunction =
    declarationValueOrFunction.parameters
        |> listMapToFastSetFastsAndUnify
            patternTypedNodeContainedTypeVariables
        |> FastDict.union
            (declarationValueOrFunction.type_
                |> typeContainedVariables
            )
        |> FastDict.union
            (declarationValueOrFunction.result
                |> expressionTypedNodeContainedTypeVariables
            )


patternTypedNodeContainedTypeVariables :
    TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
patternTypedNodeContainedTypeVariables patternTypedNode =
    FastDict.union
        (patternTypedNode.type_
            |> typeContainedVariables
        )
        (patternTypedNode.value
            |> patternContainedTypeVariables
        )


patternContainedTypeVariables :
    Pattern (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
patternContainedTypeVariables pattern =
    case pattern of
        PatternIgnored ->
            FastDict.empty

        PatternUnit ->
            FastDict.empty

        PatternChar _ ->
            FastDict.empty

        PatternString _ ->
            FastDict.empty

        PatternInt _ ->
            FastDict.empty

        PatternVariable _ ->
            FastDict.empty

        PatternParenthesized inParens ->
            patternTypedNodeContainedTypeVariables
                inParens

        PatternAs patternAs ->
            FastDict.union
                (patternAs.variable.type_
                    |> typeContainedVariables
                )
                (patternAs.pattern
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTuple parts ->
            FastDict.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTriple parts ->
            parts.part0
                |> patternTypedNodeContainedTypeVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> patternTypedNodeContainedTypeVariables
                    )

        PatternListCons patternListCons ->
            FastDict.union
                (patternListCons.head
                    |> patternTypedNodeContainedTypeVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternListExact elements ->
            elements
                |> listMapToFastSetFastsAndUnify
                    patternTypedNodeContainedTypeVariables

        PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastSetFastsAndUnify
                    patternTypedNodeContainedTypeVariables

        PatternRecord fields ->
            fields
                |> listMapToFastSetFastsAndUnify
                    (\fieldTypedNode ->
                        fieldTypedNode.type_
                            |> typeContainedVariables
                    )


listMapToFastSetFastsAndUnify : (a -> FastSetFast comparable) -> List a -> FastSetFast comparable
listMapToFastSetFastsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar
                    (element |> elementToSet)
            )
            FastDict.empty


listMapToFastDictsAndUnify :
    (a -> FastDict.Dict comparable value)
    -> List a
    -> FastDict.Dict comparable value
listMapToFastDictsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar
                    (element |> elementToSet)
            )
            FastDict.empty


valueAndFunctionDeclarationsUsesOfLocalReferences :
    FastDict.Dict String whatever_
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        FastDict.Dict
            String
            (FastDict.Dict
                RangeAsComparable
                (Type TypeVariableFromContext)
            )
valueAndFunctionDeclarationsUsesOfLocalReferences localReferencesToCollect inferredValueAndFunctionDeclarations =
    inferredValueAndFunctionDeclarations
        |> FastDict.foldl
            (\_ declarationValueOrFunction usesSoFar ->
                collectedLocalReferenceUsesMerge
                    usesSoFar
                    (declarationValueOrFunction.result
                        |> expressionTypedNodeUsesOfLocalReferences
                            localReferencesToCollect
                    )
            )
            FastDict.empty


expressionTypedNodeUsesOfLocalReferences :
    FastDict.Dict String whatever_
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        FastDict.Dict
            String
            (FastDict.Dict
                RangeAsComparable
                (Type TypeVariableFromContext)
            )
expressionTypedNodeUsesOfLocalReferences localReferencesToCollect expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            FastDict.empty

        ExpressionInteger _ ->
            FastDict.empty

        ExpressionFloat _ ->
            FastDict.empty

        ExpressionString _ ->
            FastDict.empty

        ExpressionChar _ ->
            FastDict.empty

        ExpressionReference reference ->
            case reference.moduleOrigin of
                _ :: _ ->
                    FastDict.empty

                [] ->
                    if localReferencesToCollect |> FastDict.member reference.name then
                        FastDict.singleton reference.name
                            (FastDict.singleton
                                (expressionTypedNode.range |> rangeToAsComparable)
                                expressionTypedNode.type_
                            )

                    else
                        FastDict.empty

        ExpressionOperatorFunction _ ->
            FastDict.empty

        ExpressionRecordAccessFunction _ ->
            FastDict.empty

        ExpressionNegation negated ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            collectedLocalReferenceUsesMerge
                (expressionInfixOperation.left
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )

        ExpressionTuple parts ->
            collectedLocalReferenceUsesMerge
                (parts.part0
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (parts.part1
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )

        ExpressionTriple parts ->
            parts.part0
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                |> collectedLocalReferenceUsesMerge
                    (parts.part1
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                |> collectedLocalReferenceUsesMerge
                    (parts.part2
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )

        ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                |> collectedLocalReferenceUsesMerge
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                |> collectedLocalReferenceUsesMerge
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )

        ExpressionList elements ->
            elements
                |> List.foldl
                    (\element soFar ->
                        collectedLocalReferenceUsesMerge
                            soFar
                            (element |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect)
                    )
                    FastDict.empty

        ExpressionRecord fields ->
            fields
                |> List.foldl
                    (\field soFar ->
                        collectedLocalReferenceUsesMerge
                            soFar
                            (field.value
                                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                            )
                    )
                    FastDict.empty

        ExpressionCall expressionCall ->
            expressionCall.called
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                |> collectedLocalReferenceUsesMerge
                    (expressionCall.argument1Up
                        |> List.foldl
                            (\argument soFar ->
                                collectedLocalReferenceUsesMerge
                                    soFar
                                    (argument
                                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                    )
                            )
                            (expressionCall.argument0
                                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                            )
                    )

        ExpressionLambda expressionLambda ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                expressionLambda.result

        ExpressionRecordUpdate expressionRecordUpdate ->
            (if localReferencesToCollect |> FastDict.member expressionRecordUpdate.recordVariable.value.name then
                FastDict.singleton expressionRecordUpdate.recordVariable.value.name
                    (FastDict.singleton
                        (expressionRecordUpdate.recordVariable.range |> rangeToAsComparable)
                        expressionRecordUpdate.recordVariable.type_
                    )

             else
                FastDict.empty
            )
                |> collectedLocalReferenceUsesMerge
                    (expressionRecordUpdate.field1Up
                        |> List.foldl
                            (\field soFar ->
                                collectedLocalReferenceUsesMerge
                                    soFar
                                    (field.value
                                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                    )
                            )
                            (expressionRecordUpdate.field0.value
                                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                            )
                    )

        ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matchedExpression
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                |> collectedLocalReferenceUsesMerge
                    (expressionCaseOf.case1Up
                        |> List.foldl
                            (\case_ soFar ->
                                collectedLocalReferenceUsesMerge
                                    soFar
                                    (case_.result
                                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                    )
                            )
                            (expressionCaseOf.case0.result
                                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                            )
                    )

        ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences localReferencesToCollect expressionLetIn


expressionLetInUsesOfLocalReferences :
    FastDict.Dict String whatever_
    ->
        { declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
        , declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration (Type TypeVariableFromContext)
            }
        , result :
            TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
        }
    ->
        FastDict.Dict
            String
            (FastDict.Dict RangeAsComparable (Type TypeVariableFromContext))
expressionLetInUsesOfLocalReferences localReferencesToCollect expressionLetIn =
    expressionLetIn.declaration1Up
        |> List.foldl
            (\letDeclaration soFar ->
                collectedLocalReferenceUsesMerge
                    soFar
                    (letDeclaration.declaration
                        |> letDeclarationUsesOfLocalReferences localReferencesToCollect
                    )
            )
            (expressionLetIn.declaration0.declaration
                |> letDeclarationUsesOfLocalReferences localReferencesToCollect
            )
        |> collectedLocalReferenceUsesMerge
            (expressionLetIn.result
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
            )


letDeclarationUsesOfLocalReferences :
    FastDict.Dict String whatever_
    -> LetDeclaration (Type TypeVariableFromContext)
    ->
        FastDict.Dict
            String
            (FastDict.Dict RangeAsComparable (Type TypeVariableFromContext))
letDeclarationUsesOfLocalReferences localReferencesToCollect letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            letValueOrFunctionDeclaration.result
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect


collectedLocalReferenceUsesMerge :
    FastDict.Dict
        String
        (FastDict.Dict RangeAsComparable (Type TypeVariableFromContext))
    ->
        FastDict.Dict
            String
            (FastDict.Dict RangeAsComparable (Type TypeVariableFromContext))
    ->
        FastDict.Dict
            String
            (FastDict.Dict RangeAsComparable (Type TypeVariableFromContext))
collectedLocalReferenceUsesMerge a b =
    fastDictUnionWith
        (\_ aUses bUses -> FastDict.union aUses bUses)
        a
        b


{-| Unify two dictionaries by combining values at the same key with a given function.

    fastDictUnionWith (\_ usesInA usesInB -> usesInA + usesInB)
        (FastDict.fromList
            [ ( "setFromListMap", 3 )
            , ( "setUnifyList", 1 )
            ]
        )
        (FastDict.fromList
            [ ( "listLast", 1 )
            , ( "setFromListMap", 1 )
            ]
        )
    --> FastDict.fromList
    -->     [ ( "listLast", 1 )
    -->     , ( "setFromListMap", 4 )
    -->     , ( "setUnifyList", 1 )
    -->     ]

-}
fastDictUnionWith :
    (comparable -> a -> a -> a)
    -> FastDict.Dict comparable a
    -> FastDict.Dict comparable a
    -> FastDict.Dict comparable a
fastDictUnionWith combineValuesFromBothAndKey aDict bDict =
    if (aDict |> FastDict.size) > (bDict |> FastDict.size) then
        FastDict.foldl
            (\key b soFar ->
                case FastDict.get key soFar of
                    Nothing ->
                        FastDict.insert key b soFar

                    Just a ->
                        FastDict.insert key (combineValuesFromBothAndKey key a b) soFar
            )
            aDict
            bDict

    else
        FastDict.foldl
            (\key a soFar ->
                case FastDict.get key soFar of
                    Nothing ->
                        FastDict.insert key a soFar

                    Just b ->
                        FastDict.insert key (combineValuesFromBothAndKey key a b) soFar
            )
            bDict
            aDict


expressionTypedNodeContainedTypeVariables :
    TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
expressionTypedNodeContainedTypeVariables expressionTypedNode =
    FastDict.union
        (expressionTypedNode.type_
            |> typeContainedVariables
        )
        (expressionTypedNode.value
            |> expressionContainedTypeVariables
        )


expressionContainedTypeVariables :
    Expression (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
expressionContainedTypeVariables expression =
    case expression of
        ExpressionUnit ->
            FastDict.empty

        ExpressionInteger _ ->
            FastDict.empty

        ExpressionFloat _ ->
            FastDict.empty

        ExpressionString _ ->
            FastDict.empty

        ExpressionChar _ ->
            FastDict.empty

        ExpressionReference _ ->
            FastDict.empty

        ExpressionOperatorFunction _ ->
            FastDict.empty

        ExpressionRecordAccessFunction _ ->
            FastDict.empty

        ExpressionNegation negated ->
            expressionTypedNodeContainedTypeVariables
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeContainedTypeVariables
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeContainedTypeVariables
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            FastDict.union
                (expressionInfixOperation.left
                    |> expressionTypedNodeContainedTypeVariables
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTuple parts ->
            FastDict.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTriple parts ->
            parts.part0
                |> expressionTypedNodeContainedTypeVariables
                |> FastDict.union
                    (parts.part1
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> expressionTypedNodeContainedTypeVariables
                |> FastDict.union
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionList elements ->
            elements
                |> listMapToFastSetFastsAndUnify
                    expressionTypedNodeContainedTypeVariables

        ExpressionRecord fields ->
            fields
                |> listMapToFastSetFastsAndUnify
                    (\field ->
                        field.value
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionCall expressionCall ->
            expressionCall.called
                |> expressionTypedNodeContainedTypeVariables
                |> FastDict.union
                    (expressionCall.argument0
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (expressionCall.argument1Up
                        |> listMapToFastSetFastsAndUnify
                            expressionTypedNodeContainedTypeVariables
                    )

        ExpressionLambda expressionLambda ->
            expressionLambda.parameter1Up
                |> List.foldl
                    (\parameter soFar ->
                        FastDict.union
                            soFar
                            (parameter
                                |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (expressionLambda.parameter0
                        |> patternTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (expressionLambda.result
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionRecordUpdate expressionRecordUpdate ->
            expressionRecordUpdate.recordVariable.type_
                |> typeContainedVariables
                |> FastDict.union
                    (expressionRecordUpdate.field1Up
                        |> List.foldl
                            (\field soFar ->
                                FastDict.union
                                    soFar
                                    (field.value
                                        |> expressionTypedNodeContainedTypeVariables
                                    )
                            )
                            (expressionRecordUpdate.field0.value
                                |> expressionTypedNodeContainedTypeVariables
                            )
                    )

        ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matchedExpression
                |> expressionTypedNodeContainedTypeVariables
                |> FastDict.union
                    (expressionCaseOf.case1Up
                        |> List.foldl
                            (\case_ soFar ->
                                FastDict.union
                                    soFar
                                    (case_ |> expressionCaseOfCaseContainedTypeVariables)
                            )
                            (expressionCaseOf.case0
                                |> expressionCaseOfCaseContainedTypeVariables
                            )
                    )

        ExpressionLetIn expressionLetIn ->
            expressionLetIn.declaration1Up
                |> List.foldl
                    (\letDeclaration soFar ->
                        FastDict.union
                            soFar
                            (letDeclaration.declaration
                                |> letDeclarationContainedTypeVariables
                            )
                    )
                    (expressionLetIn.declaration0.declaration
                        |> letDeclarationContainedTypeVariables
                    )
                |> FastDict.union
                    (expressionLetIn.result
                        |> expressionTypedNodeContainedTypeVariables
                    )


letDeclarationContainedTypeVariables :
    LetDeclaration (Type comparableTypeVariable)
    -> FastSetFast comparableTypeVariable
letDeclarationContainedTypeVariables letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            FastDict.union
                (letDestructuring.pattern
                    |> patternTypedNodeContainedTypeVariables
                )
                (letDestructuring.expression
                    |> expressionTypedNodeContainedTypeVariables
                )

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            letValueOrFunctionDeclaration.type_
                |> typeContainedVariables
                |> FastDict.union
                    (letValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetFastsAndUnify
                            patternTypedNodeContainedTypeVariables
                    )
                |> FastDict.union
                    (letValueOrFunctionDeclaration.result
                        |> expressionTypedNodeContainedTypeVariables
                    )


expressionCaseOfCaseContainedTypeVariables :
    { pattern : TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    , result : TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    }
    -> FastSetFast comparableTypeVariable
expressionCaseOfCaseContainedTypeVariables syntaxCase =
    FastDict.union
        (syntaxCase.pattern
            |> patternTypedNodeContainedTypeVariables
        )
        (syntaxCase.result
            |> expressionTypedNodeContainedTypeVariables
        )


createEquivalentVariablesToCondensedVariableLookup :
    List EquivalentVariableSet
    -> Result String (FastDict.Dict TypeVariableFromContext TypeVariableFromContext)
createEquivalentVariablesToCondensedVariableLookup equivalentVariables =
    equivalentVariables
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\equivalentVariableSet soFar ->
                Result.map
                    (\unifiedVariable ->
                        equivalentVariableSet.variables
                            |> FastDict.foldl
                                (\variable () soFarInSet ->
                                    soFarInSet
                                        |> FastDict.insert variable unifiedVariable
                                )
                                soFar
                    )
                    (equivalentVariablesCreateCondensedVariable equivalentVariableSet)
            )


valueAndFunctionDeclarationsGetPartiallyInferred :
    FastDict.Dict
        String
        (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
valueAndFunctionDeclarationsGetPartiallyInferred valueAndFunctionDeclarationsSoFar =
    valueAndFunctionDeclarationsSoFar
        |> FastDict.foldl
            (\name declarationValueOrFunction moduleLevelPartiallyInferredDeclarationsSoFar ->
                case declarationValueOrFunction.signature of
                    Just _ ->
                        moduleLevelPartiallyInferredDeclarationsSoFar

                    Nothing ->
                        moduleLevelPartiallyInferredDeclarationsSoFar
                            |> FastDict.insert name
                                { range =
                                    declarationValueOrFunction |> valueOrFunctionDeclarationInfoRange
                                , type_ = declarationValueOrFunction.type_
                                }
            )
            FastDict.empty


valueOrFunctionDeclarationInfoRange :
    ValueOrFunctionDeclarationInfo typeVariable_
    -> Elm.Syntax.Range.Range
valueOrFunctionDeclarationInfoRange valueOrFunctionDeclarationInfo =
    { start =
        case valueOrFunctionDeclarationInfo.documentation of
            Just documentation ->
                documentation.range.start

            Nothing ->
                case valueOrFunctionDeclarationInfo.signature of
                    Just signature ->
                        signature.range.start

                    Nothing ->
                        valueOrFunctionDeclarationInfo.nameRange.start
    , end = valueOrFunctionDeclarationInfo.result.range.end
    }


fastSetFastToListHighestToLowestAndMap :
    (comparable -> listElement)
    -> FastSetFast comparable
    -> List listElement
fastSetFastToListHighestToLowestAndMap setElementToListElement fastSet =
    fastSet
        |> FastDict.foldl
            (\setElement () soFar ->
                (setElement |> setElementToListElement) :: soFar
            )
            []


valueAndFunctionDeclarationsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            { declarations :
                FastDict.Dict
                    String
                    (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            , unchangedDeclarations : FastSetFast String
            , substitutions : VariableSubstitutions
            }
valueAndFunctionDeclarationsSubstituteVariableByNotVariable declarationTypes substitutionToApply valueAndFunctionDeclarationsToApplySubstitutionTo =
    valueAndFunctionDeclarationsToApplySubstitutionTo
        |> fastDictFoldlWhileOkFrom
            substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty
            (\declarationName declarationToSubstituteIn soFar ->
                Result.andThen
                    (\declarationSubstituted ->
                        if declarationSubstituted.unchanged then
                            Ok
                                { substitutions = soFar.substitutions
                                , unchangedDeclarations =
                                    soFar.unchangedDeclarations
                                        |> FastDict.insert declarationName ()
                                , declarations =
                                    FastDict.insert declarationName
                                        declarationToSubstituteIn
                                        soFar.declarations
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , unchangedDeclarations =
                                        soFar.unchangedDeclarations
                                    , declarations =
                                        FastDict.insert declarationName
                                            declarationSubstituted.declaration
                                            soFar.declarations
                                    }
                                )
                                (variableSubstitutionsMerge
                                    { declarationTypes = declarationTypes
                                    , range = everywhereRange
                                    }
                                    soFar.substitutions
                                    declarationSubstituted.substitutions
                                )
                    )
                    (declarationToSubstituteIn
                        |> valueOrFunctionDeclarationInfoSubstituteVariableByNotVariable
                            declarationTypes
                            substitutionToApply
                    )
                    |> Result.mapError
                        (\substitutionError ->
                            "I inferred various parts of the value/function declaration "
                                ++ declarationName
                                ++ " but there was a problem after substituting pieces of knowledge: "
                                ++ substitutionError
                        )
            )


{-| Hacky way to get a range that includes any other possible range.
Avoid if possible
-}
everywhereRange : Elm.Syntax.Range.Range
everywhereRange =
    { start = { row = 1, column = 1 }
    , end = { row = 10000000, column = 10000000 }
    }


substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty :
    { substitutions : VariableSubstitutions
    , declarations : FastDict.Dict String declarationInfo_
    , unchangedDeclarations : FastSetFast String
    }
substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty =
    { substitutions = variableSubstitutionsNone
    , declarations = FastDict.empty
    , unchangedDeclarations = FastDict.empty
    }


variableToTypeSubstitutionsCondenseVariables :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> FastDict.Dict TypeVariableFromContext TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsCondenseVariables context variableToCondensedLookup variableToType =
    variableToType
        |> fastDictFoldlWhileOkFrom
            variableSubstitutionsNone
            (\uncondensedVariable replacementType soFar ->
                let
                    replacementTypeUsingCondensedVariables : TypeNotVariable TypeVariableFromContext
                    replacementTypeUsingCondensedVariables =
                        replacementType
                            |> typeNotVariableMapVariables
                                (\variable ->
                                    variableToCondensedLookup
                                        |> FastDict.get variable
                                        |> Maybe.withDefault variable
                                )
                in
                case variableToCondensedLookup |> FastDict.get uncondensedVariable of
                    Nothing ->
                        Ok
                            { equivalentVariables = soFar.equivalentVariables
                            , variableToType =
                                soFar.variableToType
                                    |> FastDict.insert uncondensedVariable
                                        replacementTypeUsingCondensedVariables
                            }

                    Just condensedVariable ->
                        case soFar.variableToType |> FastDict.get condensedVariable of
                            Nothing ->
                                Ok
                                    { equivalentVariables = soFar.equivalentVariables
                                    , variableToType =
                                        soFar.variableToType
                                            |> FastDict.insert condensedVariable
                                                replacementTypeUsingCondensedVariables
                                    }

                            Just existingReplacementTypeForCondensedVariable ->
                                Result.andThen
                                    (\replacementTypeForCondensedVariable ->
                                        case replacementTypeForCondensedVariable.type_ of
                                            TypeVariable replacementTypeVariableForCondensedVariable ->
                                                Result.map
                                                    (\equivalentVariablesWithCondensed ->
                                                        { equivalentVariables =
                                                            equivalentVariablesWithCondensed
                                                        , variableToType = soFar.variableToType
                                                        }
                                                    )
                                                    (soFar.equivalentVariables
                                                        |> equivalentVariablesMergeWithSetOf2
                                                            condensedVariable
                                                            replacementTypeVariableForCondensedVariable
                                                    )

                                            TypeNotVariable replacementTypeNotVariableForCondensedVariable ->
                                                Result.map
                                                    (\substitutionsSoFarAndFromUnifying ->
                                                        { variableToType =
                                                            substitutionsSoFarAndFromUnifying.variableToType
                                                                |> FastDict.insert condensedVariable
                                                                    replacementTypeNotVariableForCondensedVariable
                                                        , equivalentVariables =
                                                            substitutionsSoFarAndFromUnifying.equivalentVariables
                                                        }
                                                    )
                                                    (variableSubstitutionsMerge context
                                                        soFar
                                                        replacementTypeForCondensedVariable.substitutions
                                                    )
                                    )
                                    (typeNotVariableUnify context
                                        existingReplacementTypeForCondensedVariable
                                        replacementTypeUsingCondensedVariables
                                    )
            )


valueOrFunctionDeclarationInfoSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    -> ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    ->
        Result
            String
            { unchanged : Bool
            , declaration : ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
valueOrFunctionDeclarationInfoSubstituteVariableByNotVariable declarationTypes replacement declarationValueOrFunctionSoFar =
    let
        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
        typeContext =
            { declarationTypes = declarationTypes
            , range = declarationValueOrFunctionSoFar |> valueOrFunctionDeclarationInfoRange
            }
    in
    resultAndThen3
        (\typeSubstituted parametersSubstituted resultSubstituted ->
            if typeSubstituted.unchanged && parametersSubstituted.allUnchanged && resultSubstituted.unchanged then
                Ok
                    { unchanged = True
                    , declaration = declarationValueOrFunctionSoFar
                    , substitutions = parametersSubstituted.substitutions
                    }

            else
                Result.map
                    (\fullSubstitutions ->
                        { unchanged = False
                        , declaration =
                            { nameRange = declarationValueOrFunctionSoFar.nameRange
                            , documentation = declarationValueOrFunctionSoFar.documentation
                            , signature = declarationValueOrFunctionSoFar.signature
                            , parameters = parametersSubstituted.nodes
                            , result = resultSubstituted.node
                            , type_ = typeSubstituted.type_
                            }
                        , substitutions = fullSubstitutions
                        }
                    )
                    (variableSubstitutionsMerge3 typeContext
                        parametersSubstituted.substitutions
                        resultSubstituted.substitutions
                        typeSubstituted.substitutions
                    )
        )
        (declarationValueOrFunctionSoFar.type_
            |> typeSubstituteVariableByNotVariable typeContext
                replacement
        )
        (declarationValueOrFunctionSoFar.parameters
            |> listFoldrWhileOkFrom
                substitutionsNoneNodesEmptyAllUnchangedTrue
                (\patternTypedNode soFar ->
                    Result.andThen
                        (\patternSubstituted ->
                            if patternSubstituted.unchanged then
                                Ok
                                    { allUnchanged = soFar.allUnchanged
                                    , substitutions = soFar.substitutions
                                    , nodes =
                                        patternTypedNode :: soFar.nodes
                                    }

                            else
                                Result.map
                                    (\fullSubstitutions ->
                                        { allUnchanged = False
                                        , substitutions = fullSubstitutions
                                        , nodes =
                                            patternSubstituted.node
                                                :: soFar.nodes
                                        }
                                    )
                                    (variableSubstitutionsMerge typeContext
                                        patternSubstituted.substitutions
                                        soFar.substitutions
                                    )
                        )
                        (patternTypedNode
                            |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                replacement
                        )
                )
        )
        (declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                replacement
        )


typeNotVariableIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable variable_
    -> Bool
typeNotVariableIsEquivalentToTypeVariable declarationTypes typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            case declarationTypes |> FastDict.get typeConstruct.moduleOrigin of
                Nothing ->
                    False

                Just originModule ->
                    case originModule.typeAliases |> FastDict.get typeConstruct.name of
                        Nothing ->
                            False

                        Just typeAlias ->
                            typeAlias.type_ |> typeIsEquivalentToTypeVariable declarationTypes

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type variable_
    -> Bool
typeIsEquivalentToTypeVariable declarationTypes type_ =
    case type_ of
        TypeVariable _ ->
            True

        TypeNotVariable typeNotVariable ->
            typeNotVariable
                |> typeNotVariableIsEquivalentToTypeVariable declarationTypes


declarationValueOrFunctionInfoMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> ValueOrFunctionDeclarationInfo (Type typeVariable)
    -> ValueOrFunctionDeclarationInfo (Type changedTypeVariable)
declarationValueOrFunctionInfoMapTypeVariables variableChange declarationValueOrFunctionSoFar =
    { nameRange = declarationValueOrFunctionSoFar.nameRange
    , documentation = declarationValueOrFunctionSoFar.documentation
    , signature = declarationValueOrFunctionSoFar.signature
    , parameters =
        declarationValueOrFunctionSoFar.parameters
            |> List.map
                (\argument ->
                    argument |> patternTypedNodeMapTypeVariables variableChange
                )
    , result =
        declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeMapTypeVariables variableChange
    , type_ =
        declarationValueOrFunctionSoFar.type_
            |> typeMapVariables variableChange
    }


expressionTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { unchanged : Bool
            , substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionTypedNodeSubstituteVariableByNotVariable declarationTypes replacement expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionFloat _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionChar _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionString _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionInteger integer ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionInteger integer
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionReference reference ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionReference reference
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionOperatorFunction symbol ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionOperatorFunction symbol
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionRecordAccessFunction field ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionRecordAccessFunction field
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionNegation negated ->
            Result.map
                (\negatedSubstituted ->
                    if negatedSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = negatedSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionNegation negatedSubstituted.node
                            , type_ = negatedSubstituted.node.type_
                            }
                        }
                )
                (negated
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionParenthesized inParensSubstituted.node
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (inParens
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccess recordAccess ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted recordSubstituted ->
                    if typeSubstituted.unchanged && recordSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionRecordAccess
                                            { fieldName = recordAccess.fieldName
                                            , fieldNameRange = recordAccess.fieldNameRange
                                            , record = recordSubstituted.node
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                typeSubstituted.substitutions
                                recordSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (recordAccess.record
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionInfixOperation expressionInfixOperation ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\typeSubstituted leftSubstituted rightSubstituted ->
                    if typeSubstituted.unchanged && leftSubstituted.unchanged && rightSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionInfixOperation
                                            { operator =
                                                { symbol = expressionInfixOperation.operator.symbol
                                                , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                                                , type_ =
                                                    TypeNotVariable
                                                        (TypeFunction
                                                            { input = leftSubstituted.node.type_
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input = rightSubstituted.node.type_
                                                                        , output = typeSubstituted.type_
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                }
                                            , left = leftSubstituted.node
                                            , right = rightSubstituted.node
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                leftSubstituted.substitutions
                                rightSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable typeContext
                        replacement
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTuple expressionTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionTuple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (expressionTuple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTuple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTriple expressionTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionTriple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            , part2 = part2Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                , part2 = part2Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (expressionTriple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part2
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen3
                (\conditionSubstituted onTrueSubstituted onFalseSubstituted ->
                    if conditionSubstituted.unchanged && onTrueSubstituted.unchanged && onFalseSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionIfThenElse
                                            { condition = conditionSubstituted.node
                                            , onTrue = onTrueSubstituted.node
                                            , onFalse = onFalseSubstituted.node
                                            }
                                    , type_ = onTrueSubstituted.node.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                conditionSubstituted.substitutions
                                onTrueSubstituted.substitutions
                                onFalseSubstituted.substitutions
                            )
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionList expressionListElements ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    if typeSubstituted.unchanged && elementsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionList
                                            elementsSubstituted.nodes
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge typeContext
                                elementsSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (expressionListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\elementNode soFar ->
                            Result.andThen
                                (\elementSubstituted ->
                                    if elementSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = elementNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsSoFarWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsSoFarWithElement
                                                , nodes =
                                                    elementSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                elementSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (elementNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionCall expressionCall ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen4
                (\typeSubstituted calledSubstituted argument0Substituted argument1UpSubstituted ->
                    if typeSubstituted.unchanged && calledSubstituted.unchanged && argument0Substituted.unchanged && argument1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionCall
                                            { called = calledSubstituted.node
                                            , argument0 = argument0Substituted.node
                                            , argument1Up = argument1UpSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge4
                                typeContext
                                calledSubstituted.substitutions
                                argument0Substituted.substitutions
                                argument1UpSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (expressionCall.called
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    if argumentSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                argumentNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    argumentSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                argumentSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (argumentNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecord expressionRecordFields ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            Result.map
                (\fieldsSubstituted ->
                    if fieldsSubstituted.allUnchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = fieldsSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value =
                                ExpressionRecord fieldsSubstituted.nodes
                            , type_ =
                                TypeNotVariable
                                    (TypeRecord
                                        (fieldsSubstituted.nodes
                                            |> List.foldl
                                                (\fieldSubstituted soFar ->
                                                    soFar
                                                        |> FastDict.insert fieldSubstituted.name
                                                            fieldSubstituted.value.type_
                                                )
                                                FastDict.empty
                                        )
                                    )
                            }
                        }
                )
                (expressionRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    if fieldValueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { range = fieldNode.range
                                                    , name = fieldNode.name
                                                    , nameRange = fieldNode.nameRange
                                                    , value = fieldValueSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldValueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\typeSubstituted field0Substituted field1UpSubstituted ->
                    if typeSubstituted.unchanged && field0Substituted.unchanged && field1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionRecordUpdate
                                            { recordVariable =
                                                { value = expressionRecordUpdate.recordVariable.value
                                                , range = expressionRecordUpdate.recordVariable.range
                                                , type_ = typeSubstituted.type_
                                                }
                                            , field0 = field0Substituted.node
                                            , field1Up = field1UpSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                field0Substituted.substitutions
                                field1UpSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (Result.map
                    (\fieldValueSubstituted ->
                        if fieldValueSubstituted.unchanged then
                            { unchanged = True
                            , node = expressionRecordUpdate.field0
                            , substitutions = variableSubstitutionsNone
                            }

                        else
                            { unchanged = False
                            , substitutions = fieldValueSubstituted.substitutions
                            , node =
                                { range = expressionRecordUpdate.field0.range
                                , name = expressionRecordUpdate.field0.name
                                , nameRange = expressionRecordUpdate.field0.nameRange
                                , value = fieldValueSubstituted.node
                                }
                            }
                    )
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    if fieldValueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { range = fieldNode.range
                                                    , name = fieldNode.name
                                                    , nameRange = fieldNode.nameRange
                                                    , value = fieldValueSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldValueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLambda expressionLambda ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\parameter0Substituted parameter1UpSubstituted resultSubstituted ->
                    if parameter0Substituted.unchanged && parameter1UpSubstituted.allUnchanged && resultSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionLambda
                                            { parameter0 = parameter0Substituted.node
                                            , parameter1Up = parameter1UpSubstituted.nodes
                                            , result = resultSubstituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = parameter0Substituted.node.type_
                                                , output =
                                                    parameter1UpSubstituted.nodes
                                                        |> List.foldr
                                                            (\argumentTypedNode output ->
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input = argumentTypedNode.type_
                                                                        , output = output
                                                                        }
                                                                    )
                                                            )
                                                            resultSubstituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                typeContext
                                parameter0Substituted.substitutions
                                parameter1UpSubstituted.substitutions
                                resultSubstituted.substitutions
                            )
                )
                (expressionLambda.parameter0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLambda.parameter1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\parameterNode soFar ->
                            Result.andThen
                                (\parameterSubstituted ->
                                    if parameterSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                parameterNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsSoFarWithParameter ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsSoFarWithParameter
                                                , nodes =
                                                    parameterSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge typeContext
                                                parameterSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLambda.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionCaseOf expressionCaseOf ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\matchedSubstituted case0Substituted case1UpSubstituted ->
                    if matchedSubstituted.unchanged && case0Substituted.unchanged && case1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionCaseOf
                                            { case0 = case0Substituted.node
                                            , case1Up = case1UpSubstituted.nodes
                                            , matchedExpression = matchedSubstituted.node
                                            }
                                    , type_ = case0Substituted.node.result.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                matchedSubstituted.substitutions
                                case0Substituted.substitutions
                                case1UpSubstituted.substitutions
                            )
                )
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (resultAndThen2
                    (\patternSubstituted resultSubstituted ->
                        if patternSubstituted.unchanged && resultSubstituted.unchanged then
                            Ok
                                { unchanged = True
                                , node = expressionCaseOf.case0
                                , substitutions = variableSubstitutionsNone
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { unchanged = False
                                    , substitutions = fullSubstitutions
                                    , node =
                                        { pattern = patternSubstituted.node
                                        , result = resultSubstituted.node
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge
                                    { declarationTypes = declarationTypes
                                    , range =
                                        { start = expressionCaseOf.case0.pattern.range.start
                                        , end = expressionCaseOf.case0.result.range.end
                                        }
                                    }
                                    patternSubstituted.substitutions
                                    resultSubstituted.substitutions
                                )
                    )
                    (expressionCaseOf.case0.pattern
                        |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                    (expressionCaseOf.case0.result
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionCaseOf.case1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\case_ soFar ->
                            resultAndThen2
                                (\patternSubstituted resultSubstituted ->
                                    if resultSubstituted.unchanged && patternSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = case_ :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { pattern = patternSubstituted.node
                                                    , result = resultSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge3 typeContext
                                                patternSubstituted.substitutions
                                                resultSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (case_.pattern
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                                (case_.result
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLetIn expressionLetIn ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\declaration0Substituted declaration1UpSubstituted resultSubstituted ->
                    if declaration0Substituted.unchanged && declaration1UpSubstituted.allUnchanged && resultSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        let
                            resultLetInNode :
                                TypedNode
                                    (Expression (Type TypeVariableFromContext))
                                    (Type TypeVariableFromContext)
                            resultLetInNode =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLetIn
                                        { declaration0 =
                                            declaration0Substituted.node
                                        , declaration1Up = declaration1UpSubstituted.nodes
                                        , result = resultSubstituted.node
                                        }
                                , type_ = resultSubstituted.node.type_
                                }

                            updatedValueOrFunctionTypes :
                                FastDict.Dict
                                    String
                                    { range : Elm.Syntax.Range.Range
                                    , type_ : Type TypeVariableFromContext
                                    }
                            updatedValueOrFunctionTypes =
                                case declaration0Substituted.updatedValueOrFunctionType of
                                    Nothing ->
                                        declaration1UpSubstituted.updatedValueOrFunctionTypes

                                    Just declaration0UpdatedValueOrFunctionType ->
                                        FastDict.insert declaration0UpdatedValueOrFunctionType.name
                                            { range = declaration0UpdatedValueOrFunctionType.range
                                            , type_ = declaration0UpdatedValueOrFunctionType.type_
                                            }
                                            declaration1UpSubstituted.updatedValueOrFunctionTypes

                            variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError : Result String VariableSubstitutions
                            variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError =
                                expressionTypedNodeUsesOfLocalReferences
                                    updatedValueOrFunctionTypes
                                    resultLetInNode
                                    |> fastDictFoldlWhileOkFrom
                                        variableSubstitutionsNone
                                        (\inferredLetDeclarationName uses soFar ->
                                            case updatedValueOrFunctionTypes |> FastDict.get inferredLetDeclarationName of
                                                Nothing ->
                                                    Err
                                                        ("("
                                                            ++ (expressionTypedNode.range |> rangeToInfoString)
                                                            ++ ") "
                                                            ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                                                        )

                                                Just inferredDeclarationType ->
                                                    uses
                                                        |> fastDictFoldlWhileOkFrom
                                                            soFar
                                                            (\useRangeAsComparable useType soFarWithUses ->
                                                                let
                                                                    letDeclarationTypeNewInstanceForUse : Type TypeVariableFromContext
                                                                    letDeclarationTypeNewInstanceForUse =
                                                                        inferredDeclarationType.type_
                                                                            |> typeMapVariables
                                                                                (\inferredDeclarationTypeVariable ->
                                                                                    if
                                                                                        inferredDeclarationType.range
                                                                                            |> rangeIncludesRangeAsComparable
                                                                                                useRangeAsComparable
                                                                                    then
                                                                                        let
                                                                                            ( _, inferredDeclarationTypeVariableName ) =
                                                                                                inferredDeclarationTypeVariable
                                                                                        in
                                                                                        ( useRangeAsComparable
                                                                                        , inferredDeclarationTypeVariableName
                                                                                        )

                                                                                    else
                                                                                        inferredDeclarationTypeVariable
                                                                                )
                                                                in
                                                                Result.andThen
                                                                    (\useUnifiedWithNewLetTypeInstance ->
                                                                        -- we need to check if the partialTpeNewInstance
                                                                        -- is actually more strict then the already existing use type.
                                                                        -- If we don't, this would run indefinitely: E.g.
                                                                        -- a : number
                                                                        -- b = round a
                                                                        -- where a is already known as Float
                                                                        -- when it is unified with the let `number`
                                                                        if
                                                                            typesAreEquallyStrict
                                                                                (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                                                (useType |> typeContainedVariables)
                                                                        then
                                                                            Result.map
                                                                                (\mergedEquivalentVariables ->
                                                                                    { equivalentVariables = mergedEquivalentVariables
                                                                                    , variableToType = soFarWithUses.variableToType
                                                                                    }
                                                                                )
                                                                                (equivalentVariableSetMerge
                                                                                    soFarWithUses.equivalentVariables
                                                                                    useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables
                                                                                )

                                                                        else
                                                                            variableSubstitutionsMerge
                                                                                typeContext
                                                                                soFarWithUses
                                                                                useUnifiedWithNewLetTypeInstance.substitutions
                                                                    )
                                                                    (typeUnify typeContext
                                                                        useType
                                                                        letDeclarationTypeNewInstanceForUse
                                                                    )
                                                            )
                                        )
                        in
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node = resultLetInNode
                                }
                            )
                            (Result.andThen
                                (\variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes ->
                                    variableSubstitutionsMerge4
                                        typeContext
                                        declaration0Substituted.substitutions
                                        declaration1UpSubstituted.substitutions
                                        resultSubstituted.substitutions
                                        variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes
                                )
                                variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError
                            )
                )
                (expressionLetIn.declaration0
                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue
                        (\letDeclarationNode soFar ->
                            Result.andThen
                                (\declarationSubstituted ->
                                    if declarationSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , updatedValueOrFunctionTypes =
                                                soFar.updatedValueOrFunctionTypes
                                            , nodes =
                                                letDeclarationNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , updatedValueOrFunctionTypes =
                                                    case declarationSubstituted.updatedValueOrFunctionType of
                                                        Nothing ->
                                                            soFar.updatedValueOrFunctionTypes

                                                        Just updatedValueOrFunctionType ->
                                                            FastDict.insert updatedValueOrFunctionType.name
                                                                { range = updatedValueOrFunctionType.range
                                                                , type_ = updatedValueOrFunctionType.type_
                                                                }
                                                                soFar.updatedValueOrFunctionTypes
                                                , nodes =
                                                    declarationSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                soFar.substitutions
                                                declarationSubstituted.substitutions
                                            )
                                )
                                (letDeclarationNode
                                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


letDeclarationSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : LetDeclaration (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { unchanged : Bool
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , updatedValueOrFunctionType :
                Maybe
                    { name : String
                    , range : Elm.Syntax.Range.Range
                    , type_ : Type TypeVariableFromContext
                    }
            , substitutions : VariableSubstitutions
            }
letDeclarationSubstituteVariableByNotVariable declarationTypes replacement letDeclarationAndRange =
    case letDeclarationAndRange.declaration of
        LetDestructuring letDestructuring ->
            resultAndThen2
                (\patternSubstituted expressionSubstituted ->
                    if patternSubstituted.unchanged && expressionSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = letDeclarationAndRange
                            , substitutions = variableSubstitutionsNone
                            , updatedValueOrFunctionType = Nothing
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , updatedValueOrFunctionType = Nothing
                                , node =
                                    { range = letDeclarationAndRange.range
                                    , declaration =
                                        LetDestructuring
                                            { pattern = patternSubstituted.node
                                            , expression = expressionSubstituted.node
                                            }
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = letDeclarationAndRange.range
                                }
                                patternSubstituted.substitutions
                                expressionSubstituted.substitutions
                            )
                )
                (letDestructuring.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letDestructuring.expression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = letDeclarationAndRange.range
                    }
            in
            resultAndThen3
                (\parametersSubstituted resultSubstituted typeSubstituted ->
                    if typeSubstituted.unchanged then
                        if resultSubstituted.unchanged && parametersSubstituted.allUnchanged then
                            Ok
                                { unchanged = True
                                , substitutions = variableSubstitutionsNone
                                , updatedValueOrFunctionType = Nothing
                                , node = letDeclarationAndRange
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { unchanged = False
                                    , substitutions = fullSubstitutions
                                    , updatedValueOrFunctionType = Nothing
                                    , node =
                                        { range = letDeclarationAndRange.range
                                        , declaration =
                                            LetValueOrFunctionDeclaration
                                                { parameters = parametersSubstituted.nodes
                                                , result = resultSubstituted.node
                                                , type_ = letValueOrFunction.type_
                                                , signature = letValueOrFunction.signature
                                                , nameRange = letValueOrFunction.nameRange
                                                , name = letValueOrFunction.name
                                                }
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge typeContext
                                    parametersSubstituted.substitutions
                                    resultSubstituted.substitutions
                                )

                    else
                        case letValueOrFunction.signature of
                            Just signature ->
                                Err
                                    ("the let value/function annotation type ("
                                        ++ (signature.range |> rangeToInfoString)
                                        ++ ") is too loose. It is annotated as "
                                        ++ (letValueOrFunction.type_ |> typeToInfoString)
                                        ++ " but should be at least as strict as "
                                        ++ (typeSubstituted.type_ |> typeToInfoString)
                                    )

                            Nothing ->
                                Result.map
                                    (\fullSubstitutions ->
                                        { unchanged = False
                                        , substitutions = fullSubstitutions
                                        , updatedValueOrFunctionType =
                                            Just
                                                { name = letValueOrFunction.name
                                                , range = letDeclarationAndRange.range
                                                , type_ = typeSubstituted.type_
                                                }
                                        , node =
                                            { range = letDeclarationAndRange.range
                                            , declaration =
                                                LetValueOrFunctionDeclaration
                                                    { parameters = parametersSubstituted.nodes
                                                    , result = resultSubstituted.node
                                                    , type_ = typeSubstituted.type_
                                                    , signature = letValueOrFunction.signature
                                                    , nameRange = letValueOrFunction.nameRange
                                                    , name = letValueOrFunction.name
                                                    }
                                            }
                                        }
                                    )
                                    (variableSubstitutionsMerge3 typeContext
                                        parametersSubstituted.substitutions
                                        resultSubstituted.substitutions
                                        typeSubstituted.substitutions
                                    )
                )
                (letValueOrFunction.parameters
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\parameterNode soFar ->
                            Result.andThen
                                (\parameterSubstituted ->
                                    if parameterSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                parameterNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    parameterSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                soFar.substitutions
                                                parameterSubstituted.substitutions
                                            )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letValueOrFunction.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )


expressionTypedNodeCondenseTypeVariables :
    ModuleLevelDeclarationTypesAvailableInModule
    -> (TypeVariableFromContext -> TypeVariableFromContext)
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
expressionTypedNodeCondenseTypeVariables declarationTypes typeVariableChange expressionTypedNode =
    case
        expressionCondenseTypeVariables
            { range = expressionTypedNode.range
            , declarationTypes = declarationTypes
            }
            typeVariableChange
            expressionTypedNode.value
    of
        Err error ->
            Err error

        Ok condensedExpression ->
            Ok
                { node =
                    { range = expressionTypedNode.range
                    , value = condensedExpression.expression
                    , type_ =
                        expressionTypedNode.type_
                            |> typeMapVariables typeVariableChange
                    }
                , substitutions = condensedExpression.substitutions
                }


okExpressionUnitSubstitutionsNone :
    Result
        String
        { expression : Expression (Type TypeVariableFromContext)
        , substitutions : VariableSubstitutions
        }
okExpressionUnitSubstitutionsNone =
    Ok
        { expression = ExpressionUnit
        , substitutions = variableSubstitutionsNone
        }


expressionCondenseTypeVariables :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> (TypeVariableFromContext -> TypeVariableFromContext)
    -> Expression (Type TypeVariableFromContext)
    ->
        Result
            String
            { expression : Expression (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
expressionCondenseTypeVariables context typeVariableChange expression =
    -- IGNORE TCO
    case expression of
        ExpressionUnit ->
            okExpressionUnitSubstitutionsNone

        ExpressionFloat floatValue ->
            Ok
                { expression = ExpressionFloat floatValue
                , substitutions = variableSubstitutionsNone
                }

        ExpressionChar charValue ->
            Ok
                { expression = ExpressionChar charValue
                , substitutions = variableSubstitutionsNone
                }

        ExpressionString stringValue ->
            Ok
                { expression = ExpressionString stringValue
                , substitutions = variableSubstitutionsNone
                }

        ExpressionInteger expressionNumber ->
            Ok
                { expression = ExpressionInteger expressionNumber
                , substitutions = variableSubstitutionsNone
                }

        ExpressionReference reference ->
            Ok
                { expression = ExpressionReference reference
                , substitutions = variableSubstitutionsNone
                }

        ExpressionOperatorFunction expressionOperatorFunction ->
            Ok
                { expression = ExpressionOperatorFunction expressionOperatorFunction
                , substitutions = variableSubstitutionsNone
                }

        ExpressionRecordAccessFunction fieldName ->
            Ok
                { expression = ExpressionRecordAccessFunction fieldName
                , substitutions = variableSubstitutionsNone
                }

        ExpressionNegation inNegation ->
            Result.map
                (\condensedInNegation ->
                    { expression =
                        ExpressionNegation
                            condensedInNegation.node
                    , substitutions = condensedInNegation.substitutions
                    }
                )
                (inNegation
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionParenthesized inParens ->
            Result.map
                (\condensedInParens ->
                    { expression =
                        ExpressionParenthesized
                            condensedInParens.node
                    , substitutions = condensedInParens.substitutions
                    }
                )
                (inParens
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionRecordAccess expressionRecordAccess ->
            Result.map
                (\condensedRecord ->
                    { expression =
                        ExpressionRecordAccess
                            { record = condensedRecord.node
                            , fieldName = expressionRecordAccess.fieldName
                            , fieldNameRange = expressionRecordAccess.fieldNameRange
                            }
                    , substitutions = condensedRecord.substitutions
                    }
                )
                (expressionRecordAccess.record
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionInfixOperation expressionInfixOperation ->
            resultAndThen2
                (\condensedLeft condensedRight ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionInfixOperation
                                    { operator =
                                        { symbol = expressionInfixOperation.operator.symbol
                                        , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                                        , type_ =
                                            expressionInfixOperation.operator.type_
                                                |> typeMapVariables typeVariableChange
                                        }
                                    , left = condensedLeft.node
                                    , right = condensedRight.node
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge context
                            condensedLeft.substitutions
                            condensedRight.substitutions
                        )
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionTuple expressionTuple ->
            resultAndThen2
                (\condensedPart0 condensedPart1 ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionTuple
                                    { part0 = condensedPart0.node
                                    , part1 = condensedPart1.node
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge context
                            condensedPart0.substitutions
                            condensedPart1.substitutions
                        )
                )
                (expressionTuple.part0
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionTuple.part1
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionTriple expressionTriple ->
            resultAndThen3
                (\condensedPart0 condensedPart1 condensedPart2 ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionTriple
                                    { part0 = condensedPart0.node
                                    , part1 = condensedPart1.node
                                    , part2 = condensedPart2.node
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge3 context
                            condensedPart0.substitutions
                            condensedPart1.substitutions
                            condensedPart2.substitutions
                        )
                )
                (expressionTriple.part0
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionTriple.part1
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionTriple.part2
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen3
                (\condensedCondition condensedOnTrue condensedOnFalse ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionIfThenElse
                                    { condition = condensedCondition.node
                                    , onTrue = condensedOnTrue.node
                                    , onFalse = condensedOnFalse.node
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge3 context
                            condensedCondition.substitutions
                            condensedOnTrue.substitutions
                            condensedOnFalse.substitutions
                        )
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionList expressionListElements ->
            Result.map
                (\condensedElements ->
                    { expression = ExpressionList condensedElements.nodes
                    , substitutions = condensedElements.substitutions
                    }
                )
                (expressionListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\element soFar ->
                            Result.andThen
                                (\condensedElement ->
                                    Result.map
                                        (\substitutionsSoFarWithElement ->
                                            { nodes =
                                                condensedElement.node :: soFar.nodes
                                            , substitutions = substitutionsSoFarWithElement
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedElement.substitutions
                                        )
                                )
                                (element
                                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )

        ExpressionCall expressionCall ->
            resultAndThen3
                (\condensedCalled condensedArgument0 condensedArgument1Up ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionCall
                                    { called = condensedCalled.node
                                    , argument0 = condensedArgument0.node
                                    , argument1Up = condensedArgument1Up.nodes
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge3 context
                            condensedCalled.substitutions
                            condensedArgument0.substitutions
                            condensedArgument1Up.substitutions
                        )
                )
                (expressionCall.called
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionCall.argument0
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionCall.argument1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\argument soFar ->
                            Result.andThen
                                (\condensedArgument ->
                                    Result.map
                                        (\substitutionsSoFarWithArgument ->
                                            { nodes =
                                                condensedArgument.node :: soFar.nodes
                                            , substitutions = substitutionsSoFarWithArgument
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedArgument.substitutions
                                        )
                                )
                                (argument
                                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )

        ExpressionRecord expressionRecordFields ->
            Result.map
                (\condensedFields ->
                    { expression =
                        ExpressionRecord
                            condensedFields.nodes
                    , substitutions = condensedFields.substitutions
                    }
                )
                (expressionRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\field soFar ->
                            Result.andThen
                                (\condensedFieldValue ->
                                    Result.map
                                        (\substitutionsSoFarWithField ->
                                            { nodes =
                                                { range = field.range
                                                , name = field.name
                                                , nameRange = field.nameRange
                                                , value = condensedFieldValue.node
                                                }
                                                    :: soFar.nodes
                                            , substitutions = substitutionsSoFarWithField
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedFieldValue.substitutions
                                        )
                                )
                                (field.value
                                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            resultAndThen2
                (\condensedField0Value condensedField1Up ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionRecordUpdate
                                    { recordVariable =
                                        { range = expressionRecordUpdate.recordVariable.range
                                        , value = expressionRecordUpdate.recordVariable.value
                                        , type_ =
                                            expressionRecordUpdate.recordVariable.type_
                                                |> typeMapVariables typeVariableChange
                                        }
                                    , field0 =
                                        { range = expressionRecordUpdate.field0.range
                                        , name = expressionRecordUpdate.field0.name
                                        , nameRange = expressionRecordUpdate.field0.nameRange
                                        , value = condensedField0Value.node
                                        }
                                    , field1Up = condensedField1Up.nodes
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge context
                            condensedField0Value.substitutions
                            condensedField1Up.substitutions
                        )
                )
                (expressionRecordUpdate.field0.value
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\field soFar ->
                            Result.andThen
                                (\condensedFieldValue ->
                                    Result.map
                                        (\substitutionsSoFarWithField ->
                                            { nodes =
                                                { range = field.range
                                                , name = field.name
                                                , nameRange = field.nameRange
                                                , value = condensedFieldValue.node
                                                }
                                                    :: soFar.nodes
                                            , substitutions = substitutionsSoFarWithField
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedFieldValue.substitutions
                                        )
                                )
                                (field.value
                                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )

        ExpressionLambda expressionLambda ->
            Result.map
                (\condensedResult ->
                    { expression =
                        ExpressionLambda
                            { parameter0 =
                                expressionLambda.parameter0
                                    |> patternTypedNodeMapTypeVariables typeVariableChange
                            , parameter1Up =
                                expressionLambda.parameter1Up
                                    |> List.map
                                        (\argument ->
                                            argument |> patternTypedNodeMapTypeVariables typeVariableChange
                                        )
                            , result = condensedResult.node
                            }
                    , substitutions = condensedResult.substitutions
                    }
                )
                (expressionLambda.result
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )

        ExpressionCaseOf expressionCaseOf ->
            resultAndThen3
                (\condensedMatched condensedCase0Result condensedCase1Up ->
                    Result.map
                        (\fullSubstitutions ->
                            { expression =
                                ExpressionCaseOf
                                    { matchedExpression = condensedMatched.node
                                    , case0 =
                                        { pattern =
                                            expressionCaseOf.case0.pattern
                                                |> patternTypedNodeMapTypeVariables typeVariableChange
                                        , result = condensedCase0Result.node
                                        }
                                    , case1Up = condensedCase1Up.nodes
                                    }
                            , substitutions = fullSubstitutions
                            }
                        )
                        (variableSubstitutionsMerge3 context
                            condensedMatched.substitutions
                            condensedCase0Result.substitutions
                            condensedCase1Up.substitutions
                        )
                )
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionCaseOf.case0.result
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionCaseOf.case1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\case_ soFar ->
                            Result.andThen
                                (\condensedCaseResult ->
                                    Result.map
                                        (\substitutionsSoFarWithCase ->
                                            { nodes =
                                                { pattern =
                                                    case_.pattern
                                                        |> patternTypedNodeMapTypeVariables typeVariableChange
                                                , result = condensedCaseResult.node
                                                }
                                                    :: soFar.nodes
                                            , substitutions = substitutionsSoFarWithCase
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedCaseResult.substitutions
                                        )
                                )
                                (case_.result
                                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )

        ExpressionLetIn expressionLetIn ->
            resultAndThen3
                (\condensedResult condensedDeclaraton0 condensedDeclaration1Up ->
                    let
                        condensedLetIn :
                            { declaration0 :
                                { range : Elm.Syntax.Range.Range
                                , declaration : LetDeclaration (Type TypeVariableFromContext)
                                }
                            , declaration1Up :
                                List
                                    { range : Elm.Syntax.Range.Range
                                    , declaration : LetDeclaration (Type TypeVariableFromContext)
                                    }
                            , result :
                                TypedNode
                                    (Expression (Type TypeVariableFromContext))
                                    (Type TypeVariableFromContext)
                            }
                        condensedLetIn =
                            { declaration0 =
                                { range = expressionLetIn.declaration0.range
                                , declaration = condensedDeclaraton0.declaration
                                }
                            , declaration1Up =
                                condensedDeclaration1Up.nodes
                            , result = condensedResult.node
                            }

                        moreConcreteDeclarationTypesToApplyToUses :
                            FastDict.Dict
                                String
                                { range : Elm.Syntax.Range.Range
                                , type_ : Type TypeVariableFromContext
                                }
                        moreConcreteDeclarationTypesToApplyToUses =
                            case condensedDeclaraton0.moreConcreteTypeToApplyToUses of
                                Nothing ->
                                    condensedDeclaration1Up.moreConcreteTypesToApplyToUses

                                Just declaration0UpdatedValueOrFunctionType ->
                                    FastDict.insert declaration0UpdatedValueOrFunctionType.name
                                        { range = declaration0UpdatedValueOrFunctionType.range
                                        , type_ = declaration0UpdatedValueOrFunctionType.type_
                                        }
                                        condensedDeclaration1Up.moreConcreteTypesToApplyToUses

                        variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError : Result String VariableSubstitutions
                        variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError =
                            expressionLetInUsesOfLocalReferences
                                moreConcreteDeclarationTypesToApplyToUses
                                condensedLetIn
                                |> fastDictFoldlWhileOkFrom
                                    variableSubstitutionsNone
                                    (\inferredDeclarationName uses soFar ->
                                        case moreConcreteDeclarationTypesToApplyToUses |> FastDict.get inferredDeclarationName of
                                            Nothing ->
                                                Err
                                                    ("("
                                                        ++ (context.range |> rangeToInfoString)
                                                        ++ ") "
                                                        ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                                                    )

                                            Just inferredDeclarationType ->
                                                uses
                                                    |> fastDictFoldlWhileOkFrom
                                                        soFar
                                                        (\useRangeAsComparable useType soFarWithUses ->
                                                            let
                                                                partialTypeNewInstance :
                                                                    { type_ : Type TypeVariableFromContext
                                                                    , containedVariables : FastSetFast TypeVariableFromContext
                                                                    }
                                                                partialTypeNewInstance =
                                                                    inferredDeclarationType.type_
                                                                        |> typeMapVariablesAndCollectResultingVariables
                                                                            (\inferredDeclarationTypeVariable ->
                                                                                if
                                                                                    inferredDeclarationType.range
                                                                                        |> rangeIncludesRangeAsComparable
                                                                                            useRangeAsComparable
                                                                                then
                                                                                    let
                                                                                        ( _, inferredDeclarationTypeVariableName ) =
                                                                                            inferredDeclarationTypeVariable
                                                                                    in
                                                                                    ( useRangeAsComparable
                                                                                    , inferredDeclarationTypeVariableName
                                                                                    )

                                                                                else
                                                                                    inferredDeclarationTypeVariable
                                                                            )

                                                                useTypeContainedVariables : FastSetFast TypeVariableFromContext
                                                                useTypeContainedVariables =
                                                                    useType |> typeContainedVariables
                                                            in
                                                            -- TODO optimization: skip substitutions when it doesn't get more strict
                                                            if
                                                                typesAreEquallyStrict
                                                                    useTypeContainedVariables
                                                                    partialTypeNewInstance.containedVariables
                                                            then
                                                                Ok soFarWithUses

                                                            else
                                                                Result.andThen
                                                                    (\useUnifiedWithNewLetTypeInstance ->
                                                                        -- optimization: skip variable→type substitutions when it doesn't get more strict
                                                                        if
                                                                            typesAreEquallyStrict
                                                                                useTypeContainedVariables
                                                                                (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                                        then
                                                                            Result.map
                                                                                (\mergedEquivalentVariables ->
                                                                                    { equivalentVariables = mergedEquivalentVariables
                                                                                    , variableToType = soFarWithUses.variableToType
                                                                                    }
                                                                                )
                                                                                (equivalentVariableSetMerge
                                                                                    soFarWithUses.equivalentVariables
                                                                                    useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables
                                                                                )

                                                                        else
                                                                            variableSubstitutionsMerge context
                                                                                soFarWithUses
                                                                                useUnifiedWithNewLetTypeInstance.substitutions
                                                                    )
                                                                    (typeUnify context
                                                                        useType
                                                                        partialTypeNewInstance.type_
                                                                    )
                                                        )
                                    )
                    in
                    Result.map
                        (\fullSubstitutions ->
                            { expression = ExpressionLetIn condensedLetIn
                            , substitutions = fullSubstitutions
                            }
                        )
                        (Result.andThen
                            (\variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes ->
                                variableSubstitutionsMerge4 context
                                    condensedResult.substitutions
                                    condensedDeclaraton0.substitutions
                                    condensedDeclaration1Up.substitutions
                                    variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes
                            )
                            variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionLetIn.declaration0
                    |> letDeclarationCondenseTypeVariables context.declarationTypes
                        typeVariableChange
                )
                (expressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        nodesListEmptySubstitutionsNoneMoreConcreteTypesToApplyToUsesDictEmpty
                        (\letDeclarationAndRange soFar ->
                            Result.andThen
                                (\condensedLetDeclaration ->
                                    Result.map
                                        (\substitutionsWithDeclaration ->
                                            { nodes =
                                                { range = letDeclarationAndRange.range
                                                , declaration = condensedLetDeclaration.declaration
                                                }
                                                    :: soFar.nodes
                                            , substitutions = substitutionsWithDeclaration
                                            , moreConcreteTypesToApplyToUses =
                                                case condensedLetDeclaration.moreConcreteTypeToApplyToUses of
                                                    Nothing ->
                                                        soFar.moreConcreteTypesToApplyToUses

                                                    Just moreConcreteTypeToApplyToUses ->
                                                        FastDict.insert moreConcreteTypeToApplyToUses.name
                                                            { range = moreConcreteTypeToApplyToUses.range
                                                            , type_ = moreConcreteTypeToApplyToUses.type_
                                                            }
                                                            soFar.moreConcreteTypesToApplyToUses
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            soFar.substitutions
                                            condensedLetDeclaration.substitutions
                                        )
                                )
                                (letDeclarationAndRange
                                    |> letDeclarationCondenseTypeVariables context.declarationTypes
                                        typeVariableChange
                                )
                        )
                )


nodesListEmptySubstitutionsNoneMoreConcreteTypesToApplyToUsesDictEmpty :
    { nodes : List node_
    , substitutions : VariableSubstitutions
    , moreConcreteTypesToApplyToUses : FastDict.Dict name_ declaration_
    }
nodesListEmptySubstitutionsNoneMoreConcreteTypesToApplyToUsesDictEmpty =
    { nodes = []
    , substitutions = variableSubstitutionsNone
    , moreConcreteTypesToApplyToUses = FastDict.empty
    }


letDeclarationCondenseTypeVariables :
    ModuleLevelDeclarationTypesAvailableInModule
    -> (TypeVariableFromContext -> TypeVariableFromContext)
    ->
        { declaration : LetDeclaration (Type TypeVariableFromContext)
        , range : Elm.Syntax.Range.Range
        }
    ->
        Result
            String
            { declaration : LetDeclaration (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            , moreConcreteTypeToApplyToUses :
                Maybe
                    { name : String
                    , range : Elm.Syntax.Range.Range
                    , type_ : Type TypeVariableFromContext
                    }
            }
letDeclarationCondenseTypeVariables declarationTypes typeVariableChange expressionLetDeclaration =
    case expressionLetDeclaration.declaration of
        LetDestructuring letDestructuring ->
            Result.map
                (\condenxedDestructuringExpression ->
                    { declaration =
                        LetDestructuring
                            { pattern =
                                letDestructuring.pattern
                                    |> patternTypedNodeMapTypeVariables typeVariableChange
                            , expression = condenxedDestructuringExpression.node
                            }
                    , substitutions = condenxedDestructuringExpression.substitutions
                    , moreConcreteTypeToApplyToUses = Nothing
                    }
                )
                (letDestructuring.expression
                    |> expressionTypedNodeCondenseTypeVariables declarationTypes
                        typeVariableChange
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            Result.andThen
                (\condensedResult ->
                    let
                        uncondensedTypeContainedVariables : FastSetFast TypeVariableFromContext
                        uncondensedTypeContainedVariables =
                            letValueOrFunction.type_
                                |> typeContainedVariables

                        condensedType :
                            { type_ : Type TypeVariableFromContext
                            , containedVariables : FastSetFast TypeVariableFromContext
                            }
                        condensedType =
                            letValueOrFunction.type_
                                |> typeMapVariablesAndCollectResultingVariables
                                    typeVariableChange

                        condensedTypeIsEquallyStrict : Bool
                        condensedTypeIsEquallyStrict =
                            typesAreEquallyStrict uncondensedTypeContainedVariables
                                condensedType.containedVariables
                    in
                    case letValueOrFunction.signature of
                        Nothing ->
                            Ok
                                { moreConcreteTypeToApplyToUses =
                                    -- if we don't check whether the condensed type
                                    -- is _actually_ more strict, we could end up in an endless loop
                                    -- if partially declared types cross-influence each other.
                                    if condensedTypeIsEquallyStrict then
                                        Nothing

                                    else
                                        Just
                                            { name = letValueOrFunction.name
                                            , range = expressionLetDeclaration.range
                                            , type_ = condensedType.type_
                                            }
                                , declaration =
                                    LetValueOrFunctionDeclaration
                                        { signature = Nothing
                                        , nameRange = letValueOrFunction.nameRange
                                        , name = letValueOrFunction.name
                                        , parameters =
                                            letValueOrFunction.parameters
                                                |> List.map
                                                    (\argument ->
                                                        argument |> patternTypedNodeMapTypeVariables typeVariableChange
                                                    )
                                        , result = condensedResult.node
                                        , type_ = condensedType.type_
                                        }
                                , substitutions = condensedResult.substitutions
                                }

                        Just signature ->
                            if Basics.not condensedTypeIsEquallyStrict then
                                Err
                                    ("the let value/function annotation type ("
                                        ++ (signature.range |> rangeToInfoString)
                                        ++ ") is too loose. It is annotated as "
                                        ++ (letValueOrFunction.type_ |> typeToInfoString)
                                        ++ " but should be at least as strict as "
                                        ++ (condensedType.type_ |> typeToInfoString)
                                    )

                            else
                                Ok
                                    { moreConcreteTypeToApplyToUses = Nothing
                                    , declaration =
                                        LetValueOrFunctionDeclaration
                                            { signature =
                                                Just
                                                    { nameRange = signature.nameRange
                                                    , range = signature.range
                                                    , annotationType = signature.annotationType
                                                    , annotationTypeRange = signature.annotationTypeRange
                                                    }
                                            , nameRange = letValueOrFunction.nameRange
                                            , name = letValueOrFunction.name
                                            , parameters =
                                                letValueOrFunction.parameters
                                                    |> List.map
                                                        (\argument ->
                                                            argument |> patternTypedNodeMapTypeVariables typeVariableChange
                                                        )
                                            , result = condensedResult.node
                                            , type_ =
                                                letValueOrFunction.type_
                                                    |> typeMapVariables typeVariableChange
                                            }
                                    , substitutions = condensedResult.substitutions
                                    }
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeCondenseTypeVariables declarationTypes
                        typeVariableChange
                )


{-| How do we check a type has gotten more strict?

 - each variable has at most one corresponding condensed variable
   so if we have less condensed variables, the type is more limited
 - also, if any condensed variable has more constraints,
   the type is also more limited

-}
typesAreEquallyStrict :
    FastSetFast TypeVariableFromContext
    -> FastSetFast TypeVariableFromContext
    -> Bool
typesAreEquallyStrict aType bType =
    ((aType |> FastDict.size) - (bType |> FastDict.size) == 0)
        && ((aType
                |> fastSetFastToListHighestToLowestAndMap
                    (\( _, aVariable ) ->
                        aVariable
                            |> typeVariableConstraint
                            |> maybeTypeVariableConstraintToString
                    )
                |> List.sort
            )
                == (bType
                        |> fastSetFastToListHighestToLowestAndMap
                            (\( _, bVariable ) ->
                                bVariable
                                    |> typeVariableConstraint
                                    |> maybeTypeVariableConstraintToString
                            )
                        |> List.sort
                   )
           )


{-| Use for renaming but not for possibly adding constraints
(in which case you're looking for `expressionTypedNodeCondenseTypeVariables`)
-}
expressionTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Expression (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Expression (Type changedTypeVariable)) (Type changedTypeVariable)
expressionTypedNodeMapTypeVariables typeVariableChange expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


expressionTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Expression type_) type_
    -> TypedNode (Expression changedType) changedType
expressionTypedNodeMapTypes typeChange expressionTypedNode =
    { range = expressionTypedNode.range
    , value =
        expressionTypedNode.value
            |> expressionMapTypes typeChange
    , type_ =
        expressionTypedNode.type_
            |> typeChange
    }


expressionMapTypes :
    (type_ -> changedType)
    -> Expression type_
    -> Expression changedType
expressionMapTypes typeChange expression =
    -- IGNORE TCO
    case expression of
        ExpressionUnit ->
            ExpressionUnit

        ExpressionFloat floatValue ->
            ExpressionFloat floatValue

        ExpressionChar charValue ->
            ExpressionChar charValue

        ExpressionString stringValue ->
            ExpressionString stringValue

        ExpressionInteger expressionNumber ->
            ExpressionInteger expressionNumber

        ExpressionReference reference ->
            ExpressionReference reference

        ExpressionOperatorFunction expressionOperatorFunction ->
            ExpressionOperatorFunction expressionOperatorFunction

        ExpressionRecordAccessFunction fieldName ->
            ExpressionRecordAccessFunction fieldName

        ExpressionNegation inNegation ->
            ExpressionNegation
                (inNegation
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionParenthesized inParens ->
            ExpressionParenthesized
                (inParens
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionRecordAccess expressionRecordAccess ->
            ExpressionRecordAccess
                { record =
                    expressionRecordAccess.record
                        |> expressionTypedNodeMapTypes typeChange
                , fieldName = expressionRecordAccess.fieldName
                , fieldNameRange = expressionRecordAccess.fieldNameRange
                }

        ExpressionInfixOperation expressionInfixOperation ->
            ExpressionInfixOperation
                { operator =
                    { symbol = expressionInfixOperation.operator.symbol
                    , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                    , type_ =
                        expressionInfixOperation.operator.type_
                            |> typeChange
                    }
                , left =
                    expressionInfixOperation.left
                        |> expressionTypedNodeMapTypes typeChange
                , right =
                    expressionInfixOperation.right
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTuple expressionTuple ->
            ExpressionTuple
                { part0 =
                    expressionTuple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTuple.part1
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTriple expressionTriple ->
            ExpressionTriple
                { part0 =
                    expressionTriple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTriple.part1
                        |> expressionTypedNodeMapTypes typeChange
                , part2 =
                    expressionTriple.part2
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionIfThenElse expressionIfThenElse ->
            ExpressionIfThenElse
                { condition =
                    expressionIfThenElse.condition
                        |> expressionTypedNodeMapTypes typeChange
                , onTrue =
                    expressionIfThenElse.onTrue
                        |> expressionTypedNodeMapTypes typeChange
                , onFalse =
                    expressionIfThenElse.onFalse
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionList expressionListElements ->
            ExpressionList
                (expressionListElements
                    |> List.map
                        (\element ->
                            element
                                |> expressionTypedNodeMapTypes
                                    typeChange
                        )
                )

        ExpressionCall expressionCall ->
            ExpressionCall
                { called =
                    expressionCall.called
                        |> expressionTypedNodeMapTypes typeChange
                , argument0 =
                    expressionCall.argument0
                        |> expressionTypedNodeMapTypes typeChange
                , argument1Up =
                    expressionCall.argument1Up
                        |> List.map
                            (\argument ->
                                argument
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            )
                }

        ExpressionRecord expressionRecordFields ->
            ExpressionRecord
                (expressionRecordFields
                    |> List.map
                        (\field ->
                            { range = field.range
                            , name = field.name
                            , nameRange = field.nameRange
                            , value =
                                field.value
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            }
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            ExpressionRecordUpdate
                { recordVariable =
                    { range = expressionRecordUpdate.recordVariable.range
                    , value = expressionRecordUpdate.recordVariable.value
                    , type_ =
                        expressionRecordUpdate.recordVariable.type_
                            |> typeChange
                    }
                , field0 =
                    { range = expressionRecordUpdate.field0.range
                    , name = expressionRecordUpdate.field0.name
                    , nameRange = expressionRecordUpdate.field0.nameRange
                    , value =
                        expressionRecordUpdate.field0.value
                            |> expressionTypedNodeMapTypes
                                typeChange
                    }
                , field1Up =
                    expressionRecordUpdate.field1Up
                        |> List.map
                            (\field ->
                                { range = field.range
                                , name = field.name
                                , nameRange = field.nameRange
                                , value =
                                    field.value
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                }
                            )
                }

        ExpressionLambda expressionLambda ->
            ExpressionLambda
                { parameter0 =
                    expressionLambda.parameter0
                        |> patternTypedNodeMapTypes typeChange
                , parameter1Up =
                    expressionLambda.parameter1Up
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    expressionLambda.result
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionCaseOf expressionCaseOf ->
            ExpressionCaseOf
                { matchedExpression =
                    expressionCaseOf.matchedExpression
                        |> expressionTypedNodeMapTypes typeChange
                , case0 =
                    { pattern =
                        expressionCaseOf.case0.pattern
                            |> patternTypedNodeMapTypes typeChange
                    , result =
                        expressionCaseOf.case0.result
                            |> expressionTypedNodeMapTypes typeChange
                    }
                , case1Up =
                    expressionCaseOf.case1Up
                        |> List.map
                            (\case_ ->
                                { pattern =
                                    case_.pattern
                                        |> patternTypedNodeMapTypes typeChange
                                , result =
                                    case_.result
                                        |> expressionTypedNodeMapTypes typeChange
                                }
                            )
                }

        ExpressionLetIn expressionLetIn ->
            ExpressionLetIn
                { declaration0 =
                    { range = expressionLetIn.declaration0.range
                    , declaration =
                        expressionLetIn.declaration0.declaration
                            |> letDeclarationMapTypes typeChange
                    }
                , declaration1Up =
                    expressionLetIn.declaration1Up
                        |> List.map
                            (\letDeclarationAndRange ->
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    letDeclarationAndRange.declaration
                                        |> letDeclarationMapTypes typeChange
                                }
                            )
                , result =
                    expressionLetIn.result
                        |> expressionTypedNodeMapTypes typeChange
                }


letDeclarationMapTypes :
    (type_ -> changedType)
    -> LetDeclaration type_
    -> LetDeclaration changedType
letDeclarationMapTypes typeChange expressionLetDeclaration =
    case expressionLetDeclaration of
        LetDestructuring letDestructuring ->
            LetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> patternTypedNodeMapTypes typeChange
                , expression =
                    letDestructuring.expression
                        |> expressionTypedNodeMapTypes typeChange
                }

        LetValueOrFunctionDeclaration letValueOrFunction ->
            LetValueOrFunctionDeclaration
                { signature = letValueOrFunction.signature
                , nameRange = letValueOrFunction.nameRange
                , name = letValueOrFunction.name
                , parameters =
                    letValueOrFunction.parameters
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    letValueOrFunction.result
                        |> expressionTypedNodeMapTypes typeChange
                , type_ =
                    letValueOrFunction.type_
                        |> typeChange
                }


expressionTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionTypedNodeApplyVariableSubstitutions declarationTypes substitutions expressionTypedNode =
    let
        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
        typeContext =
            { declarationTypes = declarationTypes
            , range = expressionTypedNode.range
            }
    in
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") "
                            ++ error
                        )

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables
                                typeContext
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            case
                                expressionTypedNode
                                    |> expressionTypedNodeCondenseTypeVariables
                                        declarationTypes
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                            of
                                Err error ->
                                    Err error

                                Ok condensedExpressionTypedNode ->
                                    case
                                        variableSubstitutionsMerge
                                            typeContext
                                            variableToTypeWithCondensedVariables
                                            condensedExpressionTypedNode.substitutions
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullSubstitutionsForNextIteration ->
                                            expressionTypedNodeApplyVariableSubstitutions
                                                declarationTypes
                                                fullSubstitutionsForNextIteration
                                                condensedExpressionTypedNode.node

        [] ->
            if substitutions.variableToType |> FastDict.isEmpty then
                Ok expressionTypedNode

            else
                case
                    substitutions.variableToType
                        |> substitutionsVariableToTypeApplyOverItself typeContext
                of
                    Err error ->
                        Err error

                    Ok variableToTypeSubstitutedOverItself ->
                        case
                            expressionTypedNode
                                |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                    variableToTypeSubstitutedOverItself
                        of
                            Err error ->
                                Err error

                            Ok expressionTypedNodeWithVariableToTypeSubstitutionApplied ->
                                if expressionTypedNodeWithVariableToTypeSubstitutionApplied.unchanged then
                                    Ok expressionTypedNode

                                else
                                    expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                        expressionTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                        expressionTypedNodeWithVariableToTypeSubstitutionApplied.node


patternTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypedNodeApplyVariableSubstitutions declarationTypes substitutions patternTypedNode =
    let
        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
        typeContext =
            { declarationTypes = declarationTypes
            , range = patternTypedNode.range
            }
    in
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err
                        ("("
                            ++ (patternTypedNode.range |> rangeToInfoString)
                            ++ ") "
                            ++ error
                        )

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables
                                typeContext
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            patternTypedNodeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (patternTypedNode
                                    |> patternTypedNodeMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            if substitutions.variableToType |> FastDict.isEmpty then
                Ok patternTypedNode

            else
                case
                    substitutions.variableToType
                        |> substitutionsVariableToTypeApplyOverItself typeContext
                of
                    Err error ->
                        Err error

                    Ok variableToTypeSubstitutedOverItself ->
                        case
                            patternTypedNode
                                |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                    variableToTypeSubstitutedOverItself
                        of
                            Err error ->
                                Err error

                            Ok patternTypedNodeWithVariableToTypeSubstitutionApplied ->
                                if patternTypedNodeWithVariableToTypeSubstitutionApplied.unchanged then
                                    Ok patternTypedNode

                                else
                                    patternTypedNodeApplyVariableSubstitutions declarationTypes
                                        patternTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                        patternTypedNodeWithVariableToTypeSubstitutionApplied.node


substitutionsVariableToTypeApplyOverItself :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    ->
        Result
            String
            (FastDict.Dict
                TypeVariableFromContext
                (TypeNotVariable TypeVariableFromContext)
            )
substitutionsVariableToTypeApplyOverItself context variableToTypeInitial =
    if (variableToTypeInitial |> FastDict.size) <= 1 then
        Ok variableToTypeInitial

    else
        -- TODO optimize by instead updating existing variableToTypeInitial
        -- and skipping when replacement type does not contain
        variableToTypeInitial
            |> fastDictFoldlWhileOkFrom
                FastDict.empty
                (\variable replacementTypeNotVariable soFar ->
                    Result.map
                        (\replacementTypeSubstituted ->
                            soFar
                                |> FastDict.insert variable
                                    replacementTypeSubstituted
                        )
                        (replacementTypeNotVariable
                            |> typeNotVariableFullyApplyVariableToTypeSubstitutions
                                context
                                variableToTypeInitial
                        )
                )


typeNotVariableFullyApplyVariableToTypeSubstitutions :
    -- TODO do new substitutions need be tracked?
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    -> TypeNotVariable TypeVariableFromContext
    -> Result String (TypeNotVariable TypeVariableFromContext)
typeNotVariableFullyApplyVariableToTypeSubstitutions context substitutionsToApply typeNotVariable =
    case
        -- TODO optimize by not tracking new substitutions
        typeNotVariable
            |> typeNotVariableSubstituteVariableByNotVariable context
                substitutionsToApply
    of
        Err error ->
            Err error

        Ok typeNotVariableSubstituted ->
            if typeNotVariableSubstituted.unchanged then
                Ok typeNotVariable

            else
                typeNotVariableFullyApplyVariableToTypeSubstitutions context
                    substitutionsToApply
                    typeNotVariableSubstituted.type_


patternTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { unchanged : Bool
            , substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
patternTypedNodeSubstituteVariableByNotVariable declarationTypes replacement patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternChar _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternString _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternInt _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternIgnored ->
            Result.map
                (\substituted ->
                    { unchanged = substituted.unchanged
                    , substitutions = substituted.substitutions
                    , node =
                        if substituted.unchanged then
                            patternTypedNode

                        else
                            { range = patternTypedNode.range
                            , value = PatternIgnored
                            , type_ = substituted.type_
                            }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = patternTypedNode.range
                        }
                        replacement
                )

        PatternVariable name ->
            Result.map
                (\substituted ->
                    if substituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = substituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value = PatternVariable name
                            , type_ = substituted.type_
                            }
                        }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        { declarationTypes = declarationTypes
                        , range = patternTypedNode.range
                        }
                        replacement
                )

        PatternParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value = PatternParenthesized inParensSubstituted.node
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (inParens
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternAs patternAs ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value =
                                PatternAs
                                    { pattern = inParensSubstituted.node
                                    , variable =
                                        { range = patternAs.variable.range
                                        , value = patternAs.variable.value
                                        , type_ = inParensSubstituted.node.type_
                                        }
                                    }
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (patternAs.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternListCons patternListCons ->
            resultAndThen2
                (\headSubstituted tailSubstituted ->
                    if headSubstituted.unchanged && tailSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternListCons
                                            { head = headSubstituted.node
                                            , tail = tailSubstituted.node
                                            }
                                    , type_ = typeListList headSubstituted.node.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                headSubstituted.substitutions
                                tailSubstituted.substitutions
                            )
                )
                (patternListCons.head
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListCons.tail
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTuple patternTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternTuple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (patternTuple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTuple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTriple patternTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternTriple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            , part2 = part2Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                , part2 = part2Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (patternTriple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part2
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternRecord patternRecordFields ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted fieldsSubstituted ->
                    if typeSubstituted.unchanged && fieldsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternRecord
                                            fieldsSubstituted.nodes
                                    , type_ =
                                        TypeNotVariable
                                            (TypeRecord
                                                (fieldsSubstituted.nodes
                                                    |> List.foldl
                                                        (\fieldSubstituted soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldSubstituted.value
                                                                    fieldSubstituted.type_
                                                        )
                                                        FastDict.empty
                                                )
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                typeSubstituted.substitutions
                                fieldsSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (patternRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldTypeSubstituted ->
                                    if fieldTypeSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithField ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithField
                                                , nodes =
                                                    { value = fieldNode.value
                                                    , range = fieldNode.range
                                                    , type_ = fieldTypeSubstituted.type_
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldTypeSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.type_
                                    |> typeSubstituteVariableByNotVariable
                                        typeContext
                                        replacement
                                )
                        )
                )

        PatternListExact patternListElements ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    if typeSubstituted.unchanged && elementsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternListExact
                                            elementsSubstituted.nodes
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                elementsSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (patternListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\elementNode soFar ->
                            Result.andThen
                                (\fieldSubstituted ->
                                    if fieldSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = elementNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithElement
                                                , nodes =
                                                    fieldSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (elementNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        PatternVariant patternVariant ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted valuesSubstituted ->
                    if typeSubstituted.unchanged && valuesSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternVariant
                                            { qualification = patternVariant.qualification
                                            , name = patternVariant.name
                                            , moduleOrigin = patternVariant.moduleOrigin
                                            , values = valuesSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge typeContext
                                typeSubstituted.substitutions
                                valuesSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable
                        typeContext
                        replacement
                )
                (patternVariant.values
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\argumentNode soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                argumentNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithElement
                                                , nodes =
                                                    valueSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )


substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , updatedValueOrFunctionTypes :
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
    , nodes : List node_
    }
substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , updatedValueOrFunctionTypes = FastDict.empty
    , nodes = []
    }


substitutionsNoneNodesEmpty : { substitutions : VariableSubstitutions, nodes : List node_ }
substitutionsNoneNodesEmpty =
    { substitutions = variableSubstitutionsNone
    , nodes = []
    }


substitutionsNoneNodesEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , nodes : List node_
    }
substitutionsNoneNodesEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , nodes = []
    }


patternTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Pattern (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Pattern (Type changedTypeVariable)) (Type changedTypeVariable)
patternTypedNodeMapTypeVariables typeVariableChange patternTypedNode =
    patternTypedNode
        |> patternTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


patternTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Pattern type_) type_
    -> TypedNode (Pattern changedType) changedType
patternTypedNodeMapTypes typeChange patternTypedNode =
    { range = patternTypedNode.range
    , value =
        patternTypedNode.value
            |> patternMapTypes typeChange
    , type_ =
        patternTypedNode.type_
            |> typeChange
    }


patternMapTypes :
    (type_ -> changedType)
    -> Pattern type_
    -> Pattern changedType
patternMapTypes typeChange pattern =
    -- IGNORE TCO
    case pattern of
        PatternUnit ->
            PatternUnit

        PatternChar charValue ->
            PatternChar charValue

        PatternString stringValue ->
            PatternString stringValue

        PatternInt patternInt ->
            PatternInt patternInt

        PatternIgnored ->
            PatternIgnored

        PatternVariable variable ->
            PatternVariable variable

        PatternParenthesized inParens ->
            PatternParenthesized
                (inParens
                    |> patternTypedNodeMapTypes typeChange
                )

        PatternAs patternAs ->
            let
                patternWithTypeWithVariablesChanged : TypedNode (Pattern changedType) changedType
                patternWithTypeWithVariablesChanged =
                    patternAs.pattern
                        |> patternTypedNodeMapTypes typeChange
            in
            PatternAs
                { pattern = patternWithTypeWithVariablesChanged
                , variable =
                    { range = patternAs.variable.range
                    , value = patternAs.variable.value
                    , type_ = patternWithTypeWithVariablesChanged.type_
                    }
                }

        PatternListCons patternListCons ->
            PatternListCons
                { head =
                    patternListCons.head
                        |> patternTypedNodeMapTypes typeChange
                , tail =
                    patternListCons.tail
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTuple patternTuple ->
            PatternTuple
                { part0 =
                    patternTuple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTuple.part1
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTriple patternTriple ->
            PatternTriple
                { part0 =
                    patternTriple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTriple.part1
                        |> patternTypedNodeMapTypes typeChange
                , part2 =
                    patternTriple.part2
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternRecord patternRecordFields ->
            PatternRecord
                (patternRecordFields
                    |> List.map
                        (\field ->
                            { value = field.value
                            , range = field.range
                            , type_ = field.type_ |> typeChange
                            }
                        )
                )

        PatternListExact patternListElement ->
            PatternListExact
                (patternListElement
                    |> List.map
                        (\element ->
                            element
                                |> patternTypedNodeMapTypes
                                    typeChange
                        )
                )

        PatternVariant patternVariant ->
            PatternVariant
                { qualification = patternVariant.qualification
                , name = patternVariant.name
                , moduleOrigin = patternVariant.moduleOrigin
                , values =
                    patternVariant.values
                        |> List.map
                            (\argument ->
                                argument
                                    |> patternTypedNodeMapTypes
                                        typeChange
                            )
                }


equivalentVariablesCreateCondensedVariable : EquivalentVariableSet -> Result String TypeVariableFromContext
equivalentVariablesCreateCondensedVariable set =
    -- TODO figure out why getMaxKey for example doesn't work. Makes no sense to me
    case set.variables |> FastDict.getMinKey of
        Nothing ->
            Err "implementation bug: equivalent variable set is empty"

        Just variable0 ->
            Ok
                ( set.overarchingRangeAsComparable
                , case set.constraint of
                    Nothing ->
                        let
                            ( _, variable0Name ) =
                                variable0
                        in
                        variable0Name

                    Just unifiedConstraint ->
                        unifiedConstraint |> typeVariableConstraintToString
                )


maybeTypeVariableConstraintToString : Maybe TypeVariableConstraint -> String
maybeTypeVariableConstraintToString maybeConstraint =
    case maybeConstraint of
        Nothing ->
            ""

        Just constraint ->
            constraint |> typeVariableConstraintToString


typeVariableConstraintToString : TypeVariableConstraint -> String
typeVariableConstraintToString constraint =
    case constraint of
        TypeVariableConstraintNumber ->
            "number"

        TypeVariableConstraintAppendable ->
            "appendable"

        TypeVariableConstraintComparable ->
            "comparable"

        TypeVariableConstraintCompappend ->
            "compappend"


fastDictFoldlWhileOkFrom : ok -> (key -> value -> ok -> Result err ok) -> FastDict.Dict key value -> Result err ok
fastDictFoldlWhileOkFrom initialFolded reduceToResult fastDict =
    fastDict
        |> -- we could use stoppableFoldl with some overhead for the case that all are ok
           -- but elm-syntax-type-infer optimizes for the more common case
           FastDict.foldl
            (\key value soFarOrError ->
                case soFarOrError of
                    Err error ->
                        Err error

                    Ok soFar ->
                        reduceToResult key value soFar
            )
            (Ok initialFolded)


fastDictMapAndSmallestJust : (key -> value -> Maybe ok) -> FastDict.Dict key value -> Maybe ok
fastDictMapAndSmallestJust keyValueToMaybe fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value _ ->
                case keyValueToMaybe key value of
                    Just foldedWithEntry ->
                        FastDict.Stop (Just foldedWithEntry)

                    Nothing ->
                        fastDictContinueNothing
            )
            Nothing


fastDictContinueNothing : FastDict.Step (Maybe folded_)
fastDictContinueNothing =
    FastDict.Continue Nothing


parameterPatternsTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
    ->
        Result
            String
            { introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , nodes :
                List
                    (TypedNode
                        (Pattern (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                    )
            }
parameterPatternsTypeInfer context parameterPatterns =
    parameterPatterns
        |> listFoldrWhileOkFrom
            introducedExpressionVariablesEmptyNodesEmpty
            (\pattern soFar ->
                Result.map
                    (\patternInferred ->
                        { nodes =
                            patternInferred
                                :: soFar.nodes
                        , introducedExpressionVariables =
                            FastDict.union soFar.introducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                    )
                    (pattern |> patternTypeInfer context)
            )
        |> Result.map
            (\folded ->
                { introducedExpressionVariables = folded.introducedExpressionVariables
                , nodes = folded.nodes
                }
            )


introducedExpressionVariablesEmptyNodesEmpty :
    { introducedExpressionVariables : FastDict.Dict String (Type TypeVariableFromContext)
    , nodes : List node_
    }
introducedExpressionVariablesEmptyNodesEmpty =
    { introducedExpressionVariables = FastDict.empty
    , nodes = []
    }


{-| Extract all known types
from module [metadata](https://dark.elm.dmy.fr/packages/elm/project-metadata-utils/latest/),
usually from parsing the `docs.json` of a dependency.

For elm-syntax modules, use [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)

-}
moduleInterfaceToTypes :
    Elm.Docs.Module
    -> { types : ModuleTypes, errors : List String }
moduleInterfaceToTypes moduleInterface =
    let
        typeAliases :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { type_ : Type String
                    , parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    }
            }
        typeAliases =
            moduleInterface.aliases
                |> List.foldl
                    (\typeAliasDeclarationInterface soFar ->
                        case
                            typeAliasDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            typeAliasDeclarationInterface.name
                                            { type_ = type_
                                            , parameters = typeAliasDeclarationInterface.args
                                            , recordFieldOrder =
                                                case typeAliasDeclarationInterface.tipe of
                                                    Elm.Type.Record fields Nothing ->
                                                        Just (fields |> List.map (\( name, _ ) -> name))

                                                    Elm.Type.Record _ (Just _) ->
                                                        Nothing

                                                    Elm.Type.Var _ ->
                                                        Nothing

                                                    Elm.Type.Lambda _ _ ->
                                                        Nothing

                                                    Elm.Type.Tuple _ ->
                                                        Nothing

                                                    Elm.Type.Type _ _ ->
                                                        Nothing
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        choiceTypes :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (List (Type String))
                    }
            }
        choiceTypes =
            moduleInterface.unions
                |> List.foldl
                    (\declarationChoiceType soFar ->
                        case
                            declarationChoiceType.tags
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\( variantName, variantValueInterfaces ) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert variantName
                                                        variantValues
                                            )
                                            (variantValueInterfaces
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue |> interfaceToType
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            declarationChoiceType.name
                                            { parameters =
                                                declarationChoiceType.args
                                            , variants = variants
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        signatures : { errors : List String, types : FastDict.Dict String (Type String) }
        signatures =
            moduleInterface.values
                |> List.foldl
                    (\valueOrFunctionDeclarationInterface soFar ->
                        case
                            valueOrFunctionDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            valueOrFunctionDeclarationInterface.name
                                            type_
                                }
                    )
                    typesDictEmptyErrorsEmpty
    in
    { errors =
        typeAliases.errors
            ++ choiceTypes.errors
            ++ signatures.errors
    , types =
        { typeAliases = typeAliases.types
        , choiceTypes = choiceTypes.types
        , signatures = signatures.types
        }
    }


typesDictEmptyErrorsEmpty : { types : FastDict.Dict String info_, errors : List error_ }
typesDictEmptyErrorsEmpty =
    { types = FastDict.empty
    , errors = []
    }


interfaceToType : Elm.Type.Type -> Result String (Type String)
interfaceToType typeInterface =
    -- IGNORE TCO
    case typeInterface of
        Elm.Type.Var name ->
            Ok (TypeVariable name)

        Elm.Type.Lambda functionInput functionOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (functionInput |> interfaceToType)
                (functionOutput |> interfaceToType)

        Elm.Type.Tuple parts ->
            case parts of
                [] ->
                    okTypeUnit

                [ inParens ] ->
                    inParens |> interfaceToType

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (tuplePart1 |> interfaceToType)
                        (tuplePart0 |> interfaceToType)

                [ triplePart0, triplePart1, triplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (triplePart0 |> interfaceToType)
                        (triplePart1 |> interfaceToType)
                        (triplePart2 |> interfaceToType)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Type.Type reference argumentInterfaces ->
            case reference |> String.split "." |> List.reverse of
                referenceName :: referenceModulePartLast :: referenceModulePartBeforeLastDown ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin =
                                        (referenceModulePartLast :: referenceModulePartBeforeLastDown)
                                            |> List.reverse
                                    , name = referenceName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentInterfaces |> listMapAndCombineOk interfaceToType)

                [ _ ] ->
                    Err "invalid reference"

                [] ->
                    Err "invalid reference"

        Elm.Type.Record fieldInterfaces Nothing ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )

        Elm.Type.Record fieldInterfaces (Just extendedRecordVariable) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { fields = fields
                            , recordVariable = extendedRecordVariable
                            }
                        )
                )
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )


okTypeUnit : Result error_ (Type variable_)
okTypeUnit =
    Ok (TypeNotVariable TypeUnit)


{-| Extract all known types
from declarations within a module.
Un-annotated value/function declarations are ignored.

For dependency modules, use [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

-}
moduleDeclarationsToTypes :
    ModuleOriginLookup
    -> List Elm.Syntax.Declaration.Declaration
    -> { types : ModuleTypes, errors : List String }
moduleDeclarationsToTypes moduleOriginLookupNotIncludingLocalDeclarations declarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            declarations
                |> List.foldl
                    (\declaration soFar ->
                        case declaration of
                            Elm.Syntax.Declaration.InfixDeclaration _ ->
                                soFar

                            Elm.Syntax.Declaration.Destructuring _ _ ->
                                soFar

                            Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( []
                                                , declarationValueOrFunction.declaration
                                                    |> Elm.Syntax.Node.value
                                                    |> .name
                                                    |> Elm.Syntax.Node.value
                                                )
                                                []
                                }

                            Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationTypeAlias.name |> Elm.Syntax.Node.value )
                                                []
                                }

                            Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationChoiceType.name |> Elm.Syntax.Node.value )
                                                []
                                    , references =
                                        declarationChoiceType.constructors
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ variant) soFarReferencesIncludingVariantsSoFar ->
                                                    soFarReferencesIncludingVariantsSoFar
                                                        |> FastDict.insert
                                                            ( [], variant.name |> Elm.Syntax.Node.value )
                                                            []
                                                )
                                                soFar.references
                                }

                            Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( [], declarationPortSignature.name |> Elm.Syntax.Node.value )
                                                []
                                }
                    )
                    moduleOriginLookupNotIncludingLocalDeclarations
    in
    declarations
        |> List.foldl
            (\declaration soFar ->
                case declaration of
                    Elm.Syntax.Declaration.InfixDeclaration _ ->
                        soFar

                    Elm.Syntax.Declaration.Destructuring _ _ ->
                        { errors =
                            "destructuring at the module level is invalid syntax"
                                :: soFar.errors
                        , types = soFar.types
                        }

                    Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                        case declarationValueOrFunction.signature of
                            Nothing ->
                                soFar

                            Just (Elm.Syntax.Node.Node _ declarationValueOrFunctionSignature) ->
                                case
                                    declarationValueOrFunctionSignature.typeAnnotation
                                        |> Elm.Syntax.Node.value
                                        |> syntaxToType moduleOriginLookup
                                of
                                    Err error ->
                                        { errors = error :: soFar.errors
                                        , types = soFar.types
                                        }

                                    Ok type_ ->
                                        { errors = soFar.errors
                                        , types =
                                            { signatures =
                                                soFar.types.signatures
                                                    |> FastDict.insert
                                                        (declarationValueOrFunctionSignature.name |> Elm.Syntax.Node.value)
                                                        type_
                                            , typeAliases = soFar.types.typeAliases
                                            , choiceTypes = soFar.types.choiceTypes
                                            }
                                        }

                    Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                        case
                            declarationTypeAlias.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases =
                                        soFar.types.typeAliases
                                            |> FastDict.insert
                                                (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationTypeAlias.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , type_ = type_
                                                , recordFieldOrder =
                                                    case declarationTypeAlias.typeAnnotation |> Elm.Syntax.Node.value of
                                                        Elm.Syntax.TypeAnnotation.Record fields ->
                                                            Just
                                                                (fields
                                                                    |> List.map
                                                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                                                            name
                                                                        )
                                                                )

                                                        Elm.Syntax.TypeAnnotation.GenericType _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Unit ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                                                            Nothing
                                                }
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }

                    Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                        case
                            declarationChoiceType.constructors
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\(Elm.Syntax.Node.Node _ variant) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        (variant.name |> Elm.Syntax.Node.value)
                                                        variantValues
                                            )
                                            (variant.arguments
                                                |> listMapAndCombineOk
                                                    (\(Elm.Syntax.Node.Node _ variantValue) ->
                                                        variantValue |> syntaxToType moduleOriginLookup
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes =
                                        soFar.types.choiceTypes
                                            |> FastDict.insert
                                                (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationChoiceType.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , variants = variants
                                                }
                                    }
                                }

                    Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                        case
                            declarationPortSignature.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures =
                                        soFar.types.signatures
                                            |> FastDict.insert
                                                (declarationPortSignature.name |> Elm.Syntax.Node.value)
                                                type_
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }
            )
            typesEmptyAndErrorsEmpty


typesEmptyAndErrorsEmpty : { types : ModuleTypes, errors : List error_ }
typesEmptyAndErrorsEmpty =
    { types = moduleTypesEmpty
    , errors = []
    }


moduleTypesEmpty : ModuleTypes
moduleTypesEmpty =
    { signatures = FastDict.empty
    , typeAliases = FastDict.empty
    , choiceTypes = FastDict.empty
    }


typeVariablesFromContextToDisambiguationLookup :
    FastSetFast TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookup variables =
    variables
        |> FastDict.foldl
            (\variable () soFar ->
                let
                    ( _, name ) =
                        variable

                    alreadyExists : String -> Bool
                    alreadyExists toDisambiguate =
                        soFar
                            |> fastDictAny
                                (\diambiguatedVariableSoFar ->
                                    diambiguatedVariableSoFar == toDisambiguate
                                )

                    variableAsDisambiguatedString : String
                    variableAsDisambiguatedString =
                        name |> nameDisambiguateBy alreadyExists
                in
                soFar
                    |> FastDict.insert variable
                        variableAsDisambiguatedString
            )
            FastDict.empty


nameDisambiguateBy : (String -> Bool) -> String -> String
nameDisambiguateBy alreadyExists currentName =
    nameDisambiguateWithIndexBy 0 alreadyExists currentName


nameDisambiguateWithIndexBy : Int -> (String -> Bool) -> String -> String
nameDisambiguateWithIndexBy index alreadyExists currentName =
    let
        indexedCurrentName : String
        indexedCurrentName =
            case index of
                0 ->
                    currentName

                indexAtLeast1 ->
                    currentName ++ (indexAtLeast1 |> String.fromInt) ++ ""
    in
    if alreadyExists indexedCurrentName then
        nameDisambiguateWithIndexBy (index + 1) alreadyExists currentName

    else
        indexedCurrentName


fastDictAny : (value -> Bool) -> FastDict.Dict key_ value -> Bool
fastDictAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.value
                    || state.left ()
                    || state.right ()
            )


fastSetFastAny : (key -> Bool) -> FastDict.Dict key value_ -> Bool
fastSetFastAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.key
                    || state.left ()
                    || state.right ()
            )


listMapToFastDict :
    (a -> { key : comparableKey, value : value })
    -> List a
    -> FastDict.Dict comparableKey value
listMapToFastDict elementToKeyValue list =
    list
        |> List.foldl
            (\element soFar ->
                let
                    keyValue : { key : comparableKey, value : value }
                    keyValue =
                        element |> elementToKeyValue
                in
                soFar |> FastDict.insert keyValue.key keyValue.value
            )
            FastDict.empty


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


listFoldl2WhileOkFrom :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> Result error state)
    -> Result error state
listFoldl2WhileOkFrom initialState aList bList reduce =
    case aList of
        [] ->
            Ok initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    Ok initialState

                bHead :: bTail ->
                    case reduce aHead bHead initialState of
                        Err error ->
                            Err error

                        Ok stateAfterReducingHeads ->
                            listFoldl2WhileOkFrom
                                stateAfterReducingHeads
                                aTail
                                bTail
                                reduce


listFoldlWhileOkFromResult :
    Result err okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFromResult initialResult reduceOnOk list =
    case initialResult of
        Err error ->
            Err error

        Ok initialOkFolded ->
            listFoldlWhileOkFrom initialOkFolded reduceOnOk list


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


{-| Prefer `listFoldlWhileOkFrom` whenever you don't need to reverse the result
-}
listFoldrWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldrWhileOkFrom initialOkFolded reduceOnOk list =
    list
        |> List.foldr
            (\element soFar ->
                case soFar of
                    Err error ->
                        Err error

                    Ok soFarOk ->
                        soFarOk |> reduceOnOk element
            )
            (Ok initialOkFolded)


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


resultAndThen3 :
    (a -> b -> c -> Result error d)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
resultAndThen3 abToResult aResult bResult cResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            abToResult a b c


resultAndThen4 :
    (a -> b -> c -> d -> Result error e)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
    -> Result error e
resultAndThen4 abToResult aResult bResult cResult dResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            case dResult of
                                Err error ->
                                    Err error

                                Ok d ->
                                    abToResult a b c d


elmCoreTypesGeneratedFromDocsJson :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypesGeneratedFromDocsJson =
    FastDict.fromList
        [ ( [ "Array" ]
          , { signatures =
                FastDict.fromList
                    [ ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Array" ]
                                , name = "Array"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "initialize"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "push"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toIndexedList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Array"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Basics" ]
          , { signatures =
                FastDict.fromList
                    [ ( "abs"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "acos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "always"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "asin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "ceiling"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "clamp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "number"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "number"
                                                        , output =
                                                            TypeVariable
                                                                "number"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "compare"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Order"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "degrees"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "e"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "floor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "isInfinite"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isNaN"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "logBase"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "max"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "min"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "modBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "never"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Never"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "not"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pi"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "radians"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remainderBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "round"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sqrt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "tan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "truncate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "turns"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bool"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "True", [] ), ( "False", [] ) ]
                        }
                      )
                    , ( "Float"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Int"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Never"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Order"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "LT", [] ), ( "EQ", [] ), ( "GT", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Bitwise" ]
          , { signatures =
                FastDict.fromList
                    [ ( "and"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "complement"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "or"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftLeftBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightZfBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Char" ]
          , { signatures =
                FastDict.fromList
                    [ ( "fromCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlpha"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlphaNum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isHexDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isOctDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Char"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Debug" ]
          , { signatures =
                FastDict.fromList
                    [ ( "log"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toString"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "todo"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Dict" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Dict" ]
                                , name = "Dict"
                                , arguments =
                                    [ TypeVariable "k"
                                    , TypeVariable "v"
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "comparable"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keys"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "merge"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "result"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "comparable"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "a"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "comparable"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Dict"
                                                                                    ]
                                                                                , name =
                                                                                    "Dict"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "comparable"
                                                                                    , TypeVariable
                                                                                        "a"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Dict"
                                                                                                ]
                                                                                            , name =
                                                                                                "Dict"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "comparable"
                                                                                                , TypeVariable
                                                                                                    "b"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "k"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "update"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "values"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Dict"
                      , { parameters = [ "k", "v" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "List" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concatMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "drop"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filterMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "head"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersperse"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maximum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "minimum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "product"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "range"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sort"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Order"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "tail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "take"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unzip"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.singleton
                    "List"
                    { parameters = [ "a" ], variants = FastDict.empty }
            }
          )
        , ( [ "Maybe" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Maybe"
                      , { parameters = [ "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Just"
                                  , [ TypeVariable "a" ]
                                  )
                                , ( "Nothing", [] )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform" ]
          , { signatures =
                FastDict.fromList
                    [ ( "sendToApp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sendToSelf"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "worker"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecord
                                            (FastDict.fromList
                                                [ ( "init"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "flags"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeTuple
                                                                        { part0 =
                                                                            TypeVariable
                                                                                "model"
                                                                        , part1 =
                                                                            TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        [ "Platform"
                                                                                        , "Cmd"
                                                                                        ]
                                                                                    , name =
                                                                                        "Cmd"
                                                                                    , arguments =
                                                                                        [ TypeVariable
                                                                                            "msg"
                                                                                        ]
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "subscriptions"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "model"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeConstruct
                                                                        { moduleOrigin =
                                                                            [ "Platform"
                                                                            , "Sub"
                                                                            ]
                                                                        , name =
                                                                            "Sub"
                                                                        , arguments =
                                                                            [ TypeVariable
                                                                                "msg"
                                                                            ]
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "update"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "msg"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            TypeVariable
                                                                                "model"
                                                                        , output =
                                                                            TypeNotVariable
                                                                                (TypeTuple
                                                                                    { part0 =
                                                                                        TypeVariable
                                                                                            "model"
                                                                                    , part1 =
                                                                                        TypeNotVariable
                                                                                            (TypeConstruct
                                                                                                { moduleOrigin =
                                                                                                    [ "Platform"
                                                                                                    , "Cmd"
                                                                                                    ]
                                                                                                , name =
                                                                                                    "Cmd"
                                                                                                , arguments =
                                                                                                    [ TypeVariable
                                                                                                        "msg"
                                                                                                    ]
                                                                                                }
                                                                                            )
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Program"
                                            , arguments =
                                                [ TypeVariable
                                                    "flags"
                                                , TypeVariable
                                                    "model"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "ProcessId"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Program"
                      , { parameters = [ "flags", "model", "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Router"
                      , { parameters = [ "appMsg", "selfMsg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Task"
                      , { parameters = [ "err", "ok" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Cmd" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Cmd" ]
                                            , name = "Cmd"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Cmd" ]
                                , name = "Cmd"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Cmd"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Sub" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Sub" ]
                                            , name = "Sub"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Sub" ]
                                , name = "Sub"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Sub"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Process" ]
          , { signatures =
                FastDict.fromList
                    [ ( "kill"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Process" ]
                                            , name = "Id"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sleep"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "spawn"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "y"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Process" ]
                                                        , name = "Id"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Id"
                      , { parameters = []
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "ProcessId"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Result" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "value"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "value"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Result" ]
                                            , name = "Result"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Result"
                      , { parameters = [ "error", "value" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Ok"
                                  , [ TypeVariable "value" ]
                                  )
                                , ( "Err"
                                  , [ TypeVariable "error" ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Set" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Set" ]
                                , name = "Set"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable2"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable2"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Set"
                      , { parameters = [ "t" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "String" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "contains"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "endsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromChar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexes"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indices"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "join"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "left"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lines"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pad"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replace"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "right"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "startsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trim"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uncons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Char"
                                                                        ]
                                                                    , name =
                                                                        "Char"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "words"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "String"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Task" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attempt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "onError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "perform"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Never"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Task"
                      , { parameters = [ "x", "a" ]
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "Task"
                                    , arguments =
                                        [ TypeVariable "x"
                                        , TypeVariable "a"
                                        ]
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Tuple" ]
          , { signatures =
                FastDict.fromList
                    [ ( "first"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "mapBoth"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "a"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "x"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "y"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapFirst"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "x"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapSecond"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pair"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "second"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "b"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        ]
