module ElmSyntaxTypeInfer exposing
    ( ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
    , importsToModuleOriginLookup, ModuleOriginLookup
    , valueOrFunctionDeclarations
    , TypedNode, Expression(..), LetDeclaration(..), Base10Or16(..), Pattern(..)
    , Type(..), TypeNotVariable(..)
    )

{-| Add type information to the nodes
of an [elm-syntax](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/) tree.


## context

@docs ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
@docs importsToModuleOriginLookup, ModuleOriginLookup


## syntax

@docs valueOrFunctionDeclarations
@docs TypedNode, Expression, LetDeclaration, Base10Or16, Pattern
@docs Type, TypeNotVariable

-}

import Elm.Docs
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.Import
import Elm.Syntax.ModuleName
import Elm.Syntax.Node
import Elm.Syntax.Pattern
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import Elm.Type
import FastDict
import FastSet


{-| Container for known types of members of a module.
Create with [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)
-}
type alias ModuleTypes =
    { signatures :
        -- value, function, port
        FastDict.Dict String (Type String)
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : Type String
            }
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List (Type String))
            }
    }


{-| [`ModuleTypes`](#ModuleTypes) exposed in `elm/core`.

Please _always_ start with [`elmCoreTypes`](#elmCoreTypes)
and add further module info with [`FastDict.union`]()
using [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

And if for some reason you already know used dependencies at compile time,
you can re-use the [code generator used for these elm/core types](https://github.com/lue-bird/elm-syntax-type-infer/codegen)

-}
elmCoreTypes :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypes =
    elmCoreTypesGeneratedFromDocsJson


{-| When syntax _introduces_ type variables from another "context" (another (let) declaration, another branch, another element, ...)
we need to differentiate these from variables in the current "context"

For example,

    ( 0, 1 )
    -- ( number, number )
    ( identity, List.map identity )
    -- ( a -> a, List a -> List a )

would be incorrect inferences because
the `number` in `0` and `1` or `a` in `identity` and `List.map` are not related
and can be different types.
So in practice these are

    ( 0, 1 )
    -- ( ( [ "0" ], "number" ), ( [ "1" ], "number" ) )
    ( identity, List.map identity )
    -- ( ( [ "0" ], "a" ) -> ( [ "0" ], "a" )
    -- , List ( [ "1", "argument0" ], "a" )
    --   -> List ( [ "1", "argument0" ], "a" )
    -- )

`"0"` and `"1"` referring to the tuple part location
and `"argument0"` referring to the applied argument index.

We could work with some kind of name disambiguation system
but preserving names and context is usually nicer
for the final inferred variable names.

Performance note: `ContextVariable` is a tuple to allow for internal use as a dict key.

-}
type alias TypeVariableFromContext =
    ( -- path inner to outer
      List String
    , String
    )


type TypeVariableConstraint
    = TypeVariableConstraintNumber
    | TypeVariableConstraintAppendable
    | TypeVariableConstraintComparable
    | TypeVariableConstraintCompappend


typeVariableFromContextName : TypeVariableFromContext -> String
typeVariableFromContextName ( _, name ) =
    name


typeVariableConstraint : String -> Maybe TypeVariableConstraint
typeVariableConstraint variableName =
    if variableName |> String.startsWith "number" then
        Just TypeVariableConstraintNumber

    else if variableName |> String.startsWith "appendable" then
        Just TypeVariableConstraintAppendable

    else if variableName |> String.startsWith "comparable" then
        Just TypeVariableConstraintComparable

    else if variableName |> String.startsWith "compappend" then
        Just TypeVariableConstraintCompappend

    else
        Nothing


maybeTypeVariableConstraintMerge : Maybe TypeVariableConstraint -> Maybe TypeVariableConstraint -> Result String (Maybe TypeVariableConstraint)
maybeTypeVariableConstraintMerge a b =
    case a of
        Nothing ->
            Ok b

        Just aConstraint ->
            case b of
                Nothing ->
                    Ok (Just aConstraint)

                Just bConstraint ->
                    Result.map Just
                        (typeVariableConstraintMerge aConstraint bConstraint)


typeVariableConstraintMerge : TypeVariableConstraint -> TypeVariableConstraint -> Result String TypeVariableConstraint
typeVariableConstraintMerge a b =
    case a of
        TypeVariableConstraintNumber ->
            case b of
                TypeVariableConstraintNumber ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintCompappend ->
                    Err "number and compappend variables cannot be unified"

        TypeVariableConstraintAppendable ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintAppendable

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend

        TypeVariableConstraintComparable ->
            case b of
                TypeVariableConstraintNumber ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintComparable

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend

        TypeVariableConstraintCompappend ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and compappend variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend


{-| Type information attached to expressions and patterns,
see [`TypedNode`](#TypedNode).

This is different from [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)
in that it doesn't contain
information unrelated to type inference like ranges, qualification levels or parens.

-}
type Type variable
    = TypeVariable variable
    | TypeNotVariable (TypeNotVariable variable)


{-| [`Type`](#Type) except the variable case
-}
type TypeNotVariable variable
    = TypeUnit
    | TypeConstruct
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type variable)
        }
    | TypeTuple
        { part0 : Type variable
        , part1 : Type variable
        }
    | TypeTriple
        { part0 : Type variable
        , part1 : Type variable
        , part2 : Type variable
        }
    | TypeRecord (FastDict.Dict String (Type variable))
    | TypeRecordExtension
        { recordVariable : variable
        , fields : FastDict.Dict String (Type variable)
        }
    | TypeFunction
        { input : Type variable
        , output : Type variable
        }


typeMapVariables :
    (variable -> changedVariable)
    -> Type variable
    -> Type changedVariable
typeMapVariables variableMap type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable variable ->
            TypeVariable (variable |> variableMap)

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariable
                    |> typeNotVariableMapVariables variableMap
                )


typeContainedVariables :
    Type comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeContainedVariables type_ =
    case type_ of
        TypeVariable variable ->
            FastSet.singleton variable

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableContainedVariables


typeNotVariableContainedVariables :
    TypeNotVariable comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeNotVariableContainedVariables typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            FastSet.empty

        TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> typeContainedVariables)
                (typeFunction.output |> typeContainedVariables)

        TypeTuple typeTuple ->
            FastSet.union
                (typeTuple.part0 |> typeContainedVariables)
                (typeTuple.part1 |> typeContainedVariables)

        TypeTriple typeTriple ->
            FastSet.union
                (FastSet.union
                    (typeTriple.part0 |> typeContainedVariables)
                    (typeTriple.part1 |> typeContainedVariables)
                )
                (typeTriple.part2 |> typeContainedVariables)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapAndFastSetsUnify typeContainedVariables

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union (value |> typeContainedVariables) soFar
                    )
                    FastSet.empty

        TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union (value |> typeContainedVariables) soFar
                    )
                    (FastSet.singleton typeRecordExtension.recordVariable)


typeNotVariableMapVariables :
    (variable -> variableMapped)
    -> TypeNotVariable variable
    -> TypeNotVariable variableMapped
typeNotVariableMapVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            TypeUnit

        TypeConstruct typeConstruct ->
            TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map (\arg -> arg |> typeMapVariables variableMap)
                }

        TypeTuple typeTuple ->
            TypeTuple
                { part0 = typeTuple.part0 |> typeMapVariables variableMap
                , part1 = typeTuple.part1 |> typeMapVariables variableMap
                }

        TypeTriple typeTriple ->
            TypeTriple
                { part0 = typeTriple.part0 |> typeMapVariables variableMap
                , part1 = typeTriple.part1 |> typeMapVariables variableMap
                , part2 = typeTriple.part2 |> typeMapVariables variableMap
                }

        TypeRecord typeRecordFields ->
            TypeRecord
                (typeRecordFields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> typeMapVariables variableMap
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable =
                    typeRecordExtension.recordVariable
                        |> variableMap
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
                }

        TypeFunction typeFunction ->
            TypeFunction
                { input = typeFunction.input |> typeMapVariables variableMap
                , output = typeFunction.output |> typeMapVariables variableMap
                }


{-| How do references used in a module map to their origin module?

Contains variants, type alias names, choice type names, port names, expression declaration names
and whether `(|.)` and or `(|=)` are imported from `Parser.Advanced`.

Also contains locally declared names when available.

-}
type alias ModuleOriginLookup =
    { references :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , keepOperatorIsExposedFromParserAdvanced : Bool
    , ignoreOperatorIsExposedFromParserAdvanced : Bool
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed [`ModuleTypes`](#ModuleTypes)
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleOriginLookup :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleOriginLookup
importsToModuleOriginLookup modulesTypes imports =
    let
        importsNormal :
            List
                { moduleName : Elm.Syntax.ModuleName.ModuleName
                , alias : Maybe String
                , exposes : List String
                }
        importsNormal =
            implicitImports
                ++ (imports
                        |> List.map
                            (\(Elm.Syntax.Node.Node _ syntaxImport) ->
                                let
                                    importModuleName : Elm.Syntax.ModuleName.ModuleName
                                    importModuleName =
                                        syntaxImport.moduleName |> Elm.Syntax.Node.value
                                in
                                { moduleName = importModuleName
                                , alias =
                                    syntaxImport.moduleAlias
                                        |> Maybe.map
                                            (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                                                syntaxAlias |> String.join "."
                                            )
                                , exposes =
                                    case syntaxImport.exposingList of
                                        Nothing ->
                                            []

                                        Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                            case modulesTypes |> FastDict.get importModuleName of
                                                Nothing ->
                                                    []

                                                Just moduleTypes ->
                                                    case syntaxExposing of
                                                        Elm.Syntax.Exposing.All _ ->
                                                            (moduleTypes.signatures |> FastDict.keys)
                                                                ++ (moduleTypes.typeAliases |> FastDict.keys)
                                                                ++ (moduleTypes.choiceTypes
                                                                        |> FastDict.foldl
                                                                            (\choiceTypeName choiceTypeInfo soFar ->
                                                                                choiceTypeName
                                                                                    :: (choiceTypeInfo.variants |> FastDict.keys)
                                                                                    ++ soFar
                                                                            )
                                                                            []
                                                                   )

                                                        Elm.Syntax.Exposing.Explicit exposes ->
                                                            exposes
                                                                |> List.concatMap
                                                                    (\(Elm.Syntax.Node.Node _ expose) ->
                                                                        case expose of
                                                                            Elm.Syntax.Exposing.InfixExpose operator ->
                                                                                [ operator ]

                                                                            Elm.Syntax.Exposing.FunctionExpose name ->
                                                                                [ name ]

                                                                            Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                                                [ name ]

                                                                            Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                case choiceTypeExpose.open of
                                                                                    Nothing ->
                                                                                        [ choiceTypeExpose.name ]

                                                                                    Just _ ->
                                                                                        case moduleTypes.choiceTypes |> FastDict.get choiceTypeExpose.name of
                                                                                            Nothing ->
                                                                                                []

                                                                                            Just choiceTypeDeclared ->
                                                                                                choiceTypeDeclared.variants |> FastDict.keys
                                                                    )
                                }
                            )
                   )
                |> importsCombine

        operatorIsExposedFromParserAdvanced : String -> Bool
        operatorIsExposedFromParserAdvanced operator =
            importsNormal
                |> List.any
                    (\syntaxImport ->
                        (case syntaxImport.moduleName of
                            [ "Parser", "Advanced" ] ->
                                True

                            _ ->
                                False
                        )
                            && (syntaxImport.exposes
                                    |> List.any
                                        (\syntaxExpose ->
                                            (syntaxExpose == operator)
                                                || (syntaxExpose == ("(" ++ operator ++ ")"))
                                        )
                               )
                    )
    in
    { references =
        importsNormal
            |> List.foldl
                (\syntaxImport soFar ->
                    case modulesTypes |> FastDict.get syntaxImport.moduleName of
                        Nothing ->
                            soFar

                        Just moduleTypes ->
                            let
                                exposedFromImportedModuleItself : List String
                                exposedFromImportedModuleItself =
                                    (moduleTypes.signatures |> FastDict.keys)
                                        ++ (moduleTypes.typeAliases |> FastDict.keys)
                                        ++ (moduleTypes.choiceTypes
                                                |> FastDict.foldl
                                                    (\choiceTypeName choiceType variantNamesSoFar ->
                                                        choiceTypeName
                                                            :: (choiceType.variants |> FastDict.keys)
                                                            ++ variantNamesSoFar
                                                    )
                                                    []
                                           )
                            in
                            FastDict.union
                                (FastDict.union
                                    (syntaxImport.exposes
                                        |> listMapToFastDict
                                            (\expose ->
                                                { key = ( [], expose )
                                                , value = syntaxImport.moduleName
                                                }
                                            )
                                    )
                                    (case syntaxImport.alias of
                                        Nothing ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( syntaxImport.moduleName, exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )

                                        Just importAlias ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( [ importAlias ], exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )
                                    )
                                )
                                soFar
                )
                FastDict.empty
    , keepOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|."
    , ignoreOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|="
    }


implicitImports :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , exposes : List String
        }
implicitImports =
    [ { moduleName = [ "Basics" ]
      , alias = Nothing
      , exposes =
            [ "Int"
            , "Float"
            , "(+)"
            , "(-)"
            , "(*)"
            , "(/)"
            , "(//)"
            , "(^)"
            , "toFloat"
            , "round"
            , "floor"
            , "ceiling"
            , "truncate"
            , "(==)"
            , "(/=)"
            , "(<)"
            , "(>)"
            , "(<=)"
            , "(>=)"
            , "max"
            , "min"
            , "compare"
            , "Order"
            , "LT"
            , "EQ"
            , "GT"
            , "Bool"
            , "True"
            , "False"
            , "not"
            , "(&&)"
            , "(||)"
            , "xor"
            , "(++)"
            , "modBy"
            , "remainderBy"
            , "negate"
            , "abs"
            , "clamp"
            , "sqrt"
            , "logBase"
            , "e"
            , "pi"
            , "cos"
            , "sin"
            , "tan"
            , "acos"
            , "asin"
            , "atan"
            , "atan2"
            , "degrees"
            , "radians"
            , "turns"
            , "toPolar"
            , "fromPolar"
            , "isNaN"
            , "isInfinite"
            , "identity"
            , "always"
            , "(<|)"
            , "(|>)"
            , "(<<)"
            , "(>>)"
            , "Never"
            , "never"
            ]
      }
    , { moduleName = [ "List" ], alias = Nothing, exposes = [ "List", "(::)" ] }
    , { moduleName = [ "Maybe" ], alias = Nothing, exposes = [ "Maybe", "Just", "Nothing" ] }
    , { moduleName = [ "Result" ], alias = Nothing, exposes = [ "Result", "Ok", "Err" ] }
    , { moduleName = [ "String" ], alias = Nothing, exposes = [ "String" ] }
    , { moduleName = [ "Char" ], alias = Nothing, exposes = [ "Char" ] }
    , { moduleName = [ "Tuple" ], alias = Nothing, exposes = [] }
    , { moduleName = [ "Debug" ], alias = Nothing, exposes = [] }
    , { moduleName = [ "Platform" ], alias = Nothing, exposes = [ "Program" ] }
    , { moduleName = [ "Platform", "Cmd" ], alias = Just "Cmd", exposes = [ "Cmd" ] }
    , { moduleName = [ "Platform", "Sub" ], alias = Just "Sub", exposes = [ "Sub" ] }
    ]


listMapToFastDict :
    (a -> { key : comparableKey, value : value })
    -> List a
    -> FastDict.Dict comparableKey value
listMapToFastDict elementToKeyValue list =
    list
        |> List.foldl
            (\element soFar ->
                let
                    keyValue : { key : comparableKey, value : value }
                    keyValue =
                        element |> elementToKeyValue
                in
                soFar |> FastDict.insert keyValue.key keyValue.value
            )
            FastDict.empty


importsCombine :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , exposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , exposes : List String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , exposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , exposes : List String
            }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , exposes : List String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importsMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importsMerge :
    { moduleName : Elm.Syntax.ModuleName.ModuleName
    , alias : Maybe String
    , exposes : List String
    }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , exposes : List String
        }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , exposes : List String
        }
importsMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , exposes =
        exposingCombine earlier.exposes later.exposes
    }


exposingCombine : List String -> List String -> List String
exposingCombine a b =
    a ++ b |> exposeListToNormal


exposeListToNormal :
    List String
    -> List String
exposeListToNormal syntaxExposeList =
    syntaxExposeList
        |> List.sort
        |> exposesCombine


exposesCombine : List String -> List String
exposesCombine syntaxExposes =
    exposesCombineFrom [] syntaxExposes


exposesCombineFrom : List String -> List String -> List String
exposesCombineFrom soFar syntaxExposes =
    case syntaxExposes of
        [] ->
            soFar

        [ onlyExpose ] ->
            onlyExpose :: soFar

        expose0 :: expose1 :: expose2Up ->
            case Basics.compare expose0 expose1 of
                EQ ->
                    exposesCombineFrom soFar (expose0 :: expose2Up)

                LT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)

                GT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)


syntaxToType :
    ModuleOriginLookup
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String (Type String)
syntaxToType moduleOriginLookup syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Ok (TypeNotVariable TypeUnit)

        Elm.Syntax.TypeAnnotation.GenericType variableName ->
            Ok (TypeVariable variableName)

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( qualification, unqualifiedName )) argumentNodes ->
            case moduleOriginLookup.references |> FastDict.get ( qualification, unqualifiedName ) of
                Nothing ->
                    Err
                        ("could not find imported/local declaration for "
                            ++ qualifiedToString { qualification = qualification, name = unqualifiedName }
                        )

                Just originModule ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = originModule
                                    , name = unqualifiedName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentNodes
                            |> listMapAndCombineOk
                                (\(Elm.Syntax.Node.Node _ argument) ->
                                    argument |> syntaxToType moduleOriginLookup
                                )
                        )

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [] ->
                    Err "empty tuple"

                [ Elm.Syntax.Node.Node _ inParens ] ->
                    inParens |> syntaxToType moduleOriginLookup

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1, Elm.Syntax.Node.Node _ syntaxPart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)
                        (syntaxPart2 |> syntaxToType moduleOriginLookup)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.TypeAnnotation.Record recordFields ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (recordFields
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariableName) (Elm.Syntax.Node.Node _ recordExtensionFields) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable = recordVariableName
                            , fields = fields
                            }
                        )
                )
                (recordExtensionFields
                    |> listFoldlWhileOkFrom
                        FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation (Elm.Syntax.Node.Node _ syntaxInput) (Elm.Syntax.Node.Node _ syntaxOutput) ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (syntaxInput |> syntaxToType moduleOriginLookup)
                (syntaxOutput |> syntaxToType moduleOriginLookup)


qualifiedToString :
    { qualification : Elm.Syntax.ModuleName.ModuleName, name : String }
    -> String
qualifiedToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationUntilDot :: qualificationAfterDot ->
            ((qualificationUntilDot :: qualificationAfterDot)
                |> String.join "."
            )
                ++ "."
                ++ reference.name


typeSubstituteVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : Type TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariable declarationTypes replacement type_ =
    case replacement.type_ of
        TypeVariable argumentVariable ->
            Ok
                { type_ =
                    type_
                        |> typeMapVariables
                            (\variable ->
                                if variable == replacement.variable then
                                    argumentVariable

                                else
                                    variable
                            )
                , substitutions = variableSubstitutionsNone
                }

        TypeNotVariable argumentNotVariable ->
            type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    { variable = replacement.variable
                    , type_ = argumentNotVariable
                    }


typeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariableByNotVariable declarationTypes replacement type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable typeVariable ->
            if typeVariable == replacement.variable then
                case replacement.variable |> typeVariableFromContextName |> typeVariableConstraint of
                    Nothing ->
                        Ok
                            { type_ = TypeNotVariable replacement.type_
                            , substitutions = variableSubstitutionsNone
                            }

                    Just constraint ->
                        case constraint of
                            TypeVariableConstraintNumber ->
                                if replacement.type_ |> typeNotVariableIsNumber then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify number type variable with types other than Int/Float"

                            TypeVariableConstraintAppendable ->
                                if replacement.type_ |> typeNotVariableIsAppendable then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify appendable type variable with types other than String/List _"

                            TypeVariableConstraintComparable ->
                                if replacement.type_ |> typeNotVariableIsComparable (\var -> var |> typeVariableFromContextName |> typeVariableConstraint) then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify comparable type variable with types other than Int/Float/String/Time.Posix/List of comparable/tuple of comparables/triple of comparable"

                            TypeVariableConstraintCompappend ->
                                if replacement.type_ |> typeNotVariableIsCompappend (\var -> var |> typeVariableFromContextName |> typeVariableConstraint) then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify compappend type variable with types other than String/List of comparable"

            else
                Ok
                    { type_ = TypeVariable typeVariable
                    , substitutions = variableSubstitutionsNone
                    }

        TypeNotVariable typeNotVariable ->
            Result.map
                (\typeAndSubstitutions ->
                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                    , substitutions = typeAndSubstitutions.substitutions
                    }
                )
                (typeNotVariable
                    |> typeNotVariableSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


typeNotVariableSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableSubstituteVariableByNotVariable declarationTypes replacement typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            Ok
                { type_ = TypeUnit
                , substitutions = variableSubstitutionsNone
                }

        TypeConstruct typeChoiceConstruct ->
            Result.map
                (\argumentsSubstituted ->
                    { type_ =
                        TypeConstruct
                            { moduleOrigin = typeChoiceConstruct.moduleOrigin
                            , name = typeChoiceConstruct.name
                            , arguments =
                                argumentsSubstituted.argumentsReverse
                                    |> List.reverse
                            }
                    , substitutions = argumentsSubstituted.substitutions
                    }
                )
                (typeChoiceConstruct.arguments
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , argumentsReverse = []
                        }
                        (\argument soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithArgument ->
                                            { argumentsReverse =
                                                argumentSubstituted.type_
                                                    :: soFar.argumentsReverse
                                            , substitutions = substitutionsWithArgument
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argument
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeTuple typeTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTuple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (typeTuple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTuple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeTriple typeTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTriple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    , part2 = part2Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (typeTriple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part2
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeRecord typeRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    { substitutions = fieldsSubstituted.substitutions
                    , type_ = TypeRecord fieldsSubstituted.types
                    }
                )
                (typeRecordFields
                    |> fastDictFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , types = FastDict.empty
                        }
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            valueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            Result.andThen
                (\fieldsSubstituted ->
                    if typeRecordExtension.recordVariable /= replacement.variable then
                        Ok
                            { substitutions = fieldsSubstituted.substitutions
                            , type_ =
                                TypeRecordExtension
                                    { recordVariable = typeRecordExtension.recordVariable
                                    , fields = fieldsSubstituted.types
                                    }
                            }

                    else
                        case replacement.type_ of
                            TypeRecord replacementRecordFields ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ = TypeRecord fieldsMerged.types
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types = soFar.types |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    valueUnified.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordFields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            TypeRecordExtension replacementRecordExtension ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ =
                                            TypeRecordExtension
                                                { recordVariable = replacement.variable
                                                , fields = fieldsMerged.types
                                                }
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types = soFar.types |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    valueUnified.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordExtension.fields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"
                )
                (typeRecordExtension.fields
                    |> fastDictFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , types = FastDict.empty
                        }
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            soFar.substitutions
                                            valueSubstituted.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeFunction typeFunction ->
            resultAndThen2
                (\inputSubstituted outputSubstituted ->
                    Result.map
                        (\substitutionsInputOutput ->
                            { type_ =
                                TypeFunction
                                    { input = inputSubstituted.type_
                                    , output = outputSubstituted.type_
                                    }
                            , substitutions = substitutionsInputOutput
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            inputSubstituted.substitutions
                            outputSubstituted.substitutions
                        )
                )
                (typeFunction.input
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeFunction.output
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


typeNotVariableIsNumber : TypeNotVariable variable_ -> Bool
typeNotVariableIsNumber type_ =
    (type_
        == TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Int"
            , arguments = []
            }
    )
        || (type_
                == TypeConstruct
                    { moduleOrigin = [ "Basics" ]
                    , name = "Float"
                    , arguments = []
                    }
           )


typeNotVariableIsAppendable : TypeNotVariable variable_ -> Bool
typeNotVariableIsAppendable type_ =
    case type_ of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            True

                        _ ->
                            False

                _ ->
                    False

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeNotVariableIsComparable :
    (variable -> Maybe TypeVariableConstraint)
    -> TypeNotVariable variable
    -> Bool
typeNotVariableIsComparable typeVariableToConstraint typeNotVariable =
    -- IGNORE TCO
    case typeNotVariable of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                [ "Time" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "Posix" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            variableReplacementTypeChoiceConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument |> typeIsComparable typeVariableToConstraint
                                    )

                        _ ->
                            False

                _ ->
                    False

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeIsComparable typeVariableToConstraint)
                && (typeTuple.part1 |> typeIsComparable typeVariableToConstraint)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeIsComparable typeVariableToConstraint)
                && (typeTriple.part1 |> typeIsComparable typeVariableToConstraint)
                && (typeTriple.part2 |> typeIsComparable typeVariableToConstraint)

        TypeUnit ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsComparable :
    (variable -> Maybe TypeVariableConstraint)
    -> Type variable
    -> Bool
typeIsComparable typeVariableToConstraint type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableToConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    True

                Just TypeVariableConstraintNumber ->
                    True

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableIsComparable typeVariableToConstraint


typeNotVariableIsCompappend :
    (variable -> Maybe TypeVariableConstraint)
    -> TypeNotVariable variable
    -> Bool
typeNotVariableIsCompappend typeVariableToConstraint type_ =
    -- IGNORE TCO
    case type_ of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            variableReplacementTypeChoiceConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument |> typeIsComparable typeVariableToConstraint
                                    )

                        _ ->
                            False

                _ ->
                    False

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


{-| All you need to turn a generic type with variables
into a concrete type with all the info we've inferred already.

While variable types in context get passed down,
variable substitutions get passed all the way to the top and only get processed there.

-}
type alias VariableSubstitutions =
    { equivalentVariables :
        List (FastSet.Set TypeVariableFromContext)
    , variableToType :
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    }


variableSubstitutionsNone : VariableSubstitutions
variableSubstitutionsNone =
    { equivalentVariables = []
    , variableToType = FastDict.empty
    }


variableSubstitutionsMerge :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge declarationTypes a b =
    -- IGNORE TCO
    FastDict.merge
        (\variable aType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable aType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        (\variable aType bType soFarOrError ->
            Result.andThen
                (\soFar ->
                    Result.andThen
                        (\abTypesUnified ->
                            Result.map
                                (\substitutionsWithAB ->
                                    case abTypesUnified.type_ of
                                        TypeVariable abUnifiedVariable ->
                                            { equivalentVariables =
                                                substitutionsWithAB.equivalentVariables
                                                    |> equivalentVariablesMergeWithSetOf2
                                                        variable
                                                        abUnifiedVariable
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                            }

                                        TypeNotVariable abUnifiedNotVariable ->
                                            { equivalentVariables = substitutionsWithAB.equivalentVariables
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                                    |> FastDict.insert variable abUnifiedNotVariable
                                            }
                                )
                                (variableSubstitutionsMerge declarationTypes
                                    soFar
                                    abTypesUnified.substitutions
                                )
                        )
                        (typeNotVariableUnify declarationTypes aType bType)
                )
                soFarOrError
        )
        (\variable bType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable bType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        a.variableToType
        b.variableToType
        (Ok
            { variableToType = FastDict.empty
            , equivalentVariables =
                equivalentVariableSetMerge
                    a.equivalentVariables
                    b.equivalentVariables
            }
        )


variableSubstitutionsMerge3 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge3 declarationTypes a b c =
    variableSubstitutionsMerge
        declarationTypes
        a
        b
        |> Result.andThen
            (\abSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abSubstitutions
                    c
            )


variableSubstitutionsMerge4 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge4 declarationTypes a b c d =
    variableSubstitutionsMerge3
        declarationTypes
        a
        b
        c
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abcSubstitutions
                    d
            )


variableSubstitutionsMerge5 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge5 declarationTypes a b c d e =
    variableSubstitutionsMerge4
        declarationTypes
        a
        b
        c
        d
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abcSubstitutions
                    e
            )


equivalentVariablesMergeWithSetOf2 :
    comparable
    -> comparable
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariablesMergeWithSetOf2 aEquivalentVariable bEquivalentVariable equivalentVariables =
    equivalentVariableSetMerge
        equivalentVariables
        [ FastSet.singleton aEquivalentVariable
            |> FastSet.insert bEquivalentVariable
        ]


equivalentVariableSetMerge :
    List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariableSetMerge a b =
    let
        mergedIntoA :
            { sets : List (FastSet.Set comparable)
            , bRemaining : List (FastSet.Set comparable)
            }
        mergedIntoA =
            a
                |> List.foldl
                    (\aEquivalentVariableSet soFar ->
                        case
                            soFar.bRemaining
                                |> listMapAndFirstJustAndRemainingAnyOrder
                                    (\bEquivalentVariableSet ->
                                        if fastSetShareElements aEquivalentVariableSet bEquivalentVariableSet then
                                            Just bEquivalentVariableSet

                                        else
                                            Nothing
                                    )
                        of
                            Nothing ->
                                { sets = aEquivalentVariableSet :: soFar.sets
                                , bRemaining = soFar.bRemaining
                                }

                            Just bEquivalentVariableSetAndRemaining ->
                                { sets =
                                    FastSet.union aEquivalentVariableSet bEquivalentVariableSetAndRemaining.value
                                        :: soFar.sets
                                , bRemaining = bEquivalentVariableSetAndRemaining.remaining
                                }
                    )
                    { sets = [], bRemaining = b }
    in
    mergedIntoA.sets
        ++ mergedIntoA.bRemaining


fastSetShareElements : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetShareElements a b =
    FastSet.intersect a b /= FastSet.empty


listMapAndFirstJustAndRemainingAnyOrder :
    (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAnyOrder elementToMaybe list =
    listMapAndFirstJustAndRemainingAndOrderWithBefore [] elementToMaybe list


listMapAndFirstJustAndRemainingAndOrderWithBefore :
    List a
    -> (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAndOrderWithBefore elementsBeforeReverse elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybe of
                Just headValue ->
                    Just
                        { value = headValue
                        , remaining =
                            (elementsBeforeReverse |> List.reverse)
                                ++ tail
                        }

                Nothing ->
                    listMapAndFirstJustAndRemainingAndOrderWithBefore
                        (head :: elementsBeforeReverse)
                        elementToMaybe
                        tail


typeUnify3 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnify3 declarationTypes a b c =
    Result.andThen
        (\abUnified ->
            Result.andThen
                (\abcUnified ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , type_ = abcUnified.type_
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            abUnified.substitutions
                            abcUnified.substitutions
                        )
                )
                (typeUnify declarationTypes
                    abUnified.type_
                    c
                )
        )
        (typeUnify declarationTypes a b)


typeUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnify declarationTypes a b =
    case a of
        TypeNotVariable aTypeNotVariable ->
            case b of
                TypeVariable bVariableName ->
                    Ok
                        { type_ = TypeNotVariable aTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton bVariableName
                                    aTypeNotVariable
                            , equivalentVariables = []
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    Result.map
                        (\unifiedNotVariable ->
                            { type_ = unifiedNotVariable.type_
                            , substitutions = unifiedNotVariable.substitutions
                            }
                        )
                        (typeNotVariableUnify declarationTypes
                            aTypeNotVariable
                            bTypeNotVariable
                        )

        TypeVariable aVariable ->
            case b of
                TypeVariable bVariable ->
                    Ok
                        { type_ = TypeVariable aVariable
                        , substitutions =
                            { variableToType = FastDict.empty
                            , equivalentVariables =
                                [ FastSet.singleton aVariable
                                    |> FastSet.insert bVariable
                                ]
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    Ok
                        { type_ = TypeNotVariable bTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton aVariable
                                    bTypeNotVariable
                            , equivalentVariables = []
                            }
                        }


typeNotVariableUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnify declarationTypes a b =
    let
        maybeTypeConstructsWithSameName :
            Maybe
                { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                , name : String
                , aArguments : List (Type TypeVariableFromContext)
                , bArguments : List (Type TypeVariableFromContext)
                }
        maybeTypeConstructsWithSameName =
            case a of
                TypeConstruct aTypeConstruct ->
                    case b of
                        TypeConstruct bTypeConstruct ->
                            if
                                (aTypeConstruct.moduleOrigin
                                    == bTypeConstruct.moduleOrigin
                                )
                                    && (aTypeConstruct.name
                                            == bTypeConstruct.name
                                       )
                            then
                                Just
                                    { moduleOrigin = aTypeConstruct.moduleOrigin
                                    , name = aTypeConstruct.name
                                    , aArguments = aTypeConstruct.arguments
                                    , bArguments = bTypeConstruct.arguments
                                    }

                            else
                                Nothing

                        _ ->
                            Nothing

                _ ->
                    Nothing

        maybeUnifiedWithTypeConstruct :
            Maybe
                (Result
                    String
                    { type_ : Type TypeVariableFromContext
                    , substitutions : VariableSubstitutions
                    }
                )
        maybeUnifiedWithTypeConstruct =
            case maybeTypeConstructsWithSameName of
                Just matchingTypeConstructs ->
                    Result.map
                        (\argumentsABUnified ->
                            { type_ =
                                TypeNotVariable
                                    (TypeConstruct
                                        { moduleOrigin = matchingTypeConstructs.moduleOrigin
                                        , name = matchingTypeConstructs.name
                                        , arguments =
                                            argumentsABUnified.argumentsReverse
                                                |> List.reverse
                                        }
                                    )
                            , substitutions = argumentsABUnified.substitutions
                            }
                        )
                        (List.map2
                            (\aArgument bArgument -> { a = aArgument, b = bArgument })
                            matchingTypeConstructs.aArguments
                            matchingTypeConstructs.bArguments
                            |> listFoldlWhileOkFrom
                                { argumentsReverse = []
                                , substitutions = variableSubstitutionsNone
                                }
                                (\ab soFar ->
                                    Result.andThen
                                        (\argumentTypeUnifiedAndSubstitutions ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { argumentsReverse =
                                                        argumentTypeUnifiedAndSubstitutions.type_
                                                            :: soFar.argumentsReverse
                                                    , substitutions =
                                                        substitutionsWithArgument
                                                    }
                                                )
                                                (variableSubstitutionsMerge
                                                    declarationTypes
                                                    argumentTypeUnifiedAndSubstitutions.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes ab.a ab.b)
                                )
                        )
                        |> Just

                Nothing ->
                    case typeUnifyWithTryToExpandTypeConstruct declarationTypes a b of
                        Just result ->
                            Just result

                        Nothing ->
                            typeUnifyWithTryToExpandTypeConstruct declarationTypes b a
    in
    case maybeUnifiedWithTypeConstruct of
        Just result ->
            result

        Nothing ->
            case a of
                TypeUnit ->
                    case b of
                        TypeUnit ->
                            Ok
                                { type_ = TypeNotVariable TypeUnit
                                , substitutions = variableSubstitutionsNone
                                }

                        _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                TypeConstruct aTypeConstruct ->
                    Err
                        ("choice type "
                            ++ qualifiedToString
                                { qualification = aTypeConstruct.moduleOrigin
                                , name = aTypeConstruct.name
                                }
                            ++ "cannot be unified be with a choice type with a different name"
                        )

                TypeTuple aTuple ->
                    case b of
                        TypeTuple bTuple ->
                            resultAndThen2
                                (\part0ABUnified part1ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTuple.part0 bTuple.part0)
                                (typeUnify declarationTypes aTuple.part1 bTuple.part1)

                        _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                TypeTriple aTriple ->
                    case b of
                        TypeTriple bTriple ->
                            resultAndThen3
                                (\part0ABUnified part1ABUnified part2ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTriple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        , part2 = part2ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                            part2ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTriple.part0 bTriple.part0)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)

                        _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                TypeRecord aRecord ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordUnify declarationTypes aRecord bRecord)

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    bRecordExtension
                                    aRecord
                                )

                        _ ->
                            Err "record cannot be unified with types other than record or record extension"

                TypeRecordExtension aRecordExtension ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    aRecordExtension
                                    bRecord
                                )

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecordExtension declarationTypes
                                    aRecordExtension
                                    bRecordExtension
                                )

                        _ ->
                            Err "record extension cannot be unified with types other than record or record extension"

                TypeFunction aFunction ->
                    case b of
                        TypeFunction bFunction ->
                            resultAndThen2
                                (\inputABUnified outputABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = inputABUnified.type_
                                                        , output = outputABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            inputABUnified.substitutions
                                            outputABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aFunction.input bFunction.input)
                                (typeUnify declarationTypes aFunction.output bFunction.output)

                        _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"


typeUnifyWithTryToExpandTypeConstruct :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Maybe
            (Result
                String
                { substitutions : VariableSubstitutions
                , type_ : Type TypeVariableFromContext
                }
            )
typeUnifyWithTryToExpandTypeConstruct declarationTypes toExpand b =
    case toExpand of
        TypeConstruct typeConstructToExpand ->
            case declarationTypes |> FastDict.get typeConstructToExpand.moduleOrigin of
                Nothing ->
                    Nothing

                Just aOriginModuleTypes ->
                    case aOriginModuleTypes.typeAliases |> FastDict.get typeConstructToExpand.name of
                        Just originAliasDeclaration ->
                            Result.andThen
                                (\typeConstructExpandedWithArguments ->
                                    Result.andThen
                                        (\typeUnified ->
                                            Result.map
                                                (\fullSubstitutions ->
                                                    { substitutions = fullSubstitutions
                                                    , type_ = typeUnified.type_
                                                    }
                                                )
                                                (variableSubstitutionsMerge declarationTypes
                                                    typeConstructExpandedWithArguments.substitutions
                                                    typeUnified.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes
                                            typeConstructExpandedWithArguments.type_
                                            (TypeNotVariable b)
                                        )
                                )
                                (List.map2
                                    (\parameterName argument ->
                                        { variable = ( [], parameterName ), type_ = argument }
                                    )
                                    originAliasDeclaration.parameters
                                    typeConstructToExpand.arguments
                                    |> listFoldlWhileOkFrom
                                        { type_ =
                                            originAliasDeclaration.type_
                                                |> typeMapVariables (\aliasVariable -> ( [], aliasVariable ))
                                        , substitutions = variableSubstitutionsNone
                                        }
                                        (\substitution soFar ->
                                            Result.andThen
                                                (\typeSubstituted ->
                                                    Result.map
                                                        (\substitutionsAfterSubstitution ->
                                                            { type_ = typeSubstituted.type_
                                                            , substitutions = substitutionsAfterSubstitution
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge declarationTypes
                                                            typeSubstituted.substitutions
                                                            soFar.substitutions
                                                        )
                                                )
                                                (soFar.type_
                                                    |> typeSubstituteVariable declarationTypes
                                                        { variable = substitution.variable
                                                        , type_ = substitution.type_
                                                        }
                                                )
                                        )
                                )
                                |> Just

                        Nothing ->
                            Nothing

        _ ->
            Nothing


typeRecordUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> FastDict.Dict String (Type TypeVariableFromContext)
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordUnify declarationTypes aFields bFields =
    Result.map
        (\fieldsUnified ->
            { type_ = TypeRecord fieldsUnified.fieldsUnified
            , substitutions = fieldsUnified.substitutions
            }
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            aFields
            bFields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


typeRecordExtensionUnifyWithRecord :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecord declarationTypes recordExtension recordFields =
    Result.andThen
        (\fieldsUnified ->
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecord fieldsUnified.fieldsUnified
                    }
                )
                (variableSubstitutionsMerge declarationTypes
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            recordExtension.recordVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record extension with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            recordExtension.fields
            recordFields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


typeRecordExtensionUnifyWithRecordExtension :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecordExtension declarationTypes aRecordExtension bRecordExtension =
    Result.andThen
        (\fieldsUnified ->
            let
                newBaseVariable : TypeVariableFromContext
                newBaseVariable =
                    ( -- creating a new variable safely
                      "_of"
                        :: ([ (aRecordExtension.recordVariable |> typeVariableFromContextName)
                                :: (aRecordExtension.recordVariable |> Tuple.first)
                            , (bRecordExtension.recordVariable |> typeVariableFromContextName)
                                :: (bRecordExtension.recordVariable |> Tuple.first)
                            ]
                                |> List.sort
                                |> List.intersperse [ "_and" ]
                                |> List.concat
                           )
                    , "base"
                    )
            in
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecordExtension
                            { recordVariable = newBaseVariable
                            , fields = fieldsUnified.fieldsUnified
                            }
                    }
                )
                (variableSubstitutionsMerge declarationTypes
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            aRecordExtension.recordVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields =
                                    FastDict.diff
                                        bRecordExtension.fields
                                        aRecordExtension.fields
                                }
                            )
                            |> FastDict.insert
                                bRecordExtension.recordVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields =
                                        FastDict.diff
                                            aRecordExtension.fields
                                            bRecordExtension.fields
                                    }
                                )
                    }
                )
        )
        (FastDict.merge
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            aRecordExtension.fields
            bRecordExtension.fields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


{-| A part in the syntax tree

  - its [range](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Range#Range) in the source
  - its global [`Type`](#Type): most concretely inferred,
    influenced by other branches and value/function (let) declaration type annotations by the user

-}
type alias TypedNode value type_ =
    { range : Elm.Syntax.Range.Range
    , value : value
    , type_ : type_
    }


{-| Like [`Elm.Syntax.Expression.Expression`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Expression)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Expression type_
    = ExpressionUnit
    | ExpressionInteger
        { base : Base10Or16
        , value : Int
        }
    | ExpressionFloat Float
    | ExpressionString String
    | ExpressionChar Char
    | ExpressionReference
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    | ExpressionOperatorFunction String
    | ExpressionRecordAccessFunction String
    | ExpressionNegation (TypedNode (Expression type_) type_)
    | ExpressionParenthesized (TypedNode (Expression type_) type_)
    | ExpressionTuple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        }
    | ExpressionTriple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        , part2 : TypedNode (Expression type_) type_
        }
    | ExpressionRecordAccess
        { record : TypedNode (Expression type_) type_
        , fieldNameRange : Elm.Syntax.Range.Range
        , fieldName : String
        }
    | ExpressionInfixOperation
        { symbol : String
        , left : TypedNode (Expression type_) type_
        , right : TypedNode (Expression type_) type_
        }
    | ExpressionIfThenElse
        { condition : TypedNode (Expression type_) type_
        , onTrue : TypedNode (Expression type_) type_
        , onFalse : TypedNode (Expression type_) type_
        }
    | ExpressionList (List (TypedNode (Expression type_) type_))
    | ExpressionCall
        { called : TypedNode (Expression type_) type_
        , argument0 : TypedNode (Expression type_) type_
        , argument1Up : List (TypedNode (Expression type_) type_)
        }
    | ExpressionRecord
        (List
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        )
    | ExpressionRecordUpdate
        { recordVariable :
            TypedNode
                { moduleOrigin :
                    -- `[]` for current module
                    Elm.Syntax.ModuleName.ModuleName
                , name : String
                }
                type_
        , field0 :
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        , field1Up :
            List
                { range : Elm.Syntax.Range.Range
                , name : String
                , nameRange : Elm.Syntax.Range.Range
                , value : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLambda
        { parameter0 : TypedNode (Pattern type_) type_
        , parameter1Up : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionLetIn
        { declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration type_
            }
        , declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration type_
                }
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionCaseOf
        { matchedExpression : TypedNode (Expression type_) type_
        , case0 :
            { pattern : TypedNode (Pattern type_) type_
            , result : TypedNode (Expression type_) type_
            }
        , case1Up :
            List
                { pattern : TypedNode (Pattern type_) type_
                , result : TypedNode (Expression type_) type_
                }
        }


{-| Like [`Elm.Syntax.Expression.LetDeclaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#LetDeclaration)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type LetDeclaration type_
    = LetDestructuring
        { pattern : TypedNode (Pattern type_) type_
        , expression : TypedNode (Expression type_) type_
        }
    | LetValueOrFunctionDeclaration
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        , type_ : type_
        }


{-| Like [`Elm.Syntax.Pattern.Pattern`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern#Pattern)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Pattern type_
    = PatternIgnored
    | PatternVariable String
    | PatternParenthesized (TypedNode (Pattern type_) type_)
    | PatternAs
        { pattern : TypedNode (Pattern type_) type_
        , variable : TypedNode String type_
        }
    | PatternUnit
    | PatternChar Char
    | PatternString String
    | PatternInt { base : Base10Or16, value : Int }
    | PatternTuple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        }
    | PatternTriple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        , part2 : TypedNode (Pattern type_) type_
        }
    | PatternRecord (List (TypedNode String type_))
    | PatternListCons
        { head : TypedNode (Pattern type_) type_
        , tail : TypedNode (Pattern type_) type_
        }
    | PatternListExact (List (TypedNode (Pattern type_) type_))
    | PatternVariant
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        , values : List (TypedNode (Pattern type_) type_)
        }


{-| Either decimal or hexadecimal.
Used by integer pattern and expression
-}
type Base10Or16
    = Base10
    | Base16


typeBasicsFloat : Type variable_
typeBasicsFloat =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Float"
            , arguments = []
            }
        )


typeBasicsBool : Type variable_
typeBasicsBool =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Bool"
            , arguments = []
            }
        )


typeBasicsInt : Type variable_
typeBasicsInt =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Int"
            , arguments = []
            }
        )


typeStringString : Type variable_
typeStringString =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "String" ]
            , name = "String"
            , arguments = []
            }
        )


typeCharChar : Type variable_
typeCharChar =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Char" ]
            , name = "Char"
            , arguments = []
            }
        )


typeListList : Type variable -> Type variable
typeListList a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "List" ]
            , name = "List"
            , arguments = [ a ]
            }
        )


typeParserParser : Type variable -> Type variable
typeParserParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Parser" ]
            , name = "Parser"
            , arguments = [ a ]
            }
        )


typeParserAdvancedParser : Type variable -> Type variable -> Type variable -> Type variable
typeParserAdvancedParser context problem value =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Parser", "Advanced" ]
            , name = "Parser"
            , arguments = [ context, problem, value ]
            }
        )


typeUrlParserParser : Type variable -> Type variable -> Type variable
typeUrlParserParser a b =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Url", "Parser" ]
            , name = "Parser"
            , arguments = [ a, b ]
            }
        )


typeUrlParserQueryParser : Type variable -> Type variable
typeUrlParserQueryParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Url", "Parser", "Query" ]
            , name = "Parser"
            , arguments = [ a ]
            }
        )


patternContextToInPath :
    String
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
patternContextToInPath innermostPathPart context =
    { path = innermostPathPart :: context.path
    , moduleOriginLookup = context.moduleOriginLookup
    , declarationTypes = context.declarationTypes
    }


patternTypeInfer :
    { path : List String
    , moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node : TypedNode (Pattern (Type TypeVariableFromContext)) (Type TypeVariableFromContext)
            , introducedExpressionVariables :
                FastDict.Dict String TypeVariableFromContext
            }
patternTypeInfer context (Elm.Syntax.Node.Node fullRange pattern) =
    -- IGNORE TCO
    case pattern of
        Elm.Syntax.Pattern.FloatPattern _ ->
            Err "float patterns are invalid syntax"

        Elm.Syntax.Pattern.AllPattern ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "ignored" )
            in
            Ok
                { node =
                    { range = fullRange
                    , value = PatternIgnored
                    , type_ = type_
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.UnitPattern ->
            Ok
                { node =
                    { range = fullRange
                    , value = PatternUnit
                    , type_ = TypeNotVariable TypeUnit
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.CharPattern charValue ->
            Ok
                { node =
                    { range = fullRange
                    , value = PatternChar charValue
                    , type_ = typeCharChar
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.IntPattern intValue ->
            Ok
                { node =
                    { range = fullRange
                    , value = PatternInt { base = Base10, value = intValue }
                    , type_ = typeBasicsInt
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.HexPattern intValue ->
            Ok
                { node =
                    { range = fullRange
                    , value = PatternInt { base = Base16, value = intValue }
                    , type_ = typeBasicsInt
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.StringPattern stringValue ->
            Ok
                { node =
                    { range = fullRange
                    , value = PatternString stringValue
                    , type_ = typeStringString
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables = FastDict.empty
                }

        Elm.Syntax.Pattern.VarPattern variableName ->
            let
                typeVariable : TypeVariableFromContext
                typeVariable =
                    ( context.path, variableName )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = PatternVariable variableName
                    , type_ = TypeVariable typeVariable
                    }
                , introducedExpressionVariables =
                    FastDict.singleton variableName typeVariable
                }

        Elm.Syntax.Pattern.ParenthesizedPattern parenthesizedInParens ->
            Result.map
                (\inParens ->
                    { substitutions = inParens.substitutions
                    , node =
                        { range = fullRange
                        , value = PatternParenthesized inParens.node
                        , type_ = inParens.node.type_
                        }
                    , introducedExpressionVariables =
                        inParens.introducedExpressionVariables
                    }
                )
                (parenthesizedInParens
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.AsPattern innerPatternNode (Elm.Syntax.Node.Node variableNameRange variableName) ->
            Result.map
                (\inner ->
                    { substitutions = inner.substitutions
                    , node =
                        { range = fullRange
                        , value =
                            PatternAs
                                { pattern = inner.node
                                , variable =
                                    { value = variableName
                                    , range = variableNameRange
                                    , type_ = inner.node.type_
                                    }
                                }
                        , type_ = inner.node.type_
                        }
                    , introducedExpressionVariables =
                        inner.introducedExpressionVariables
                    }
                )
                (innerPatternNode
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.TuplePattern parts ->
            case parts of
                [] ->
                    -- should be handled by UnitPattern
                    Ok
                        { node =
                            { range = fullRange
                            , value = PatternUnit
                            , type_ = TypeNotVariable TypeUnit
                            }
                        , substitutions = variableSubstitutionsNone
                        , introducedExpressionVariables = FastDict.empty
                        }

                [ parenthesizedInParens ] ->
                    -- should be handled by ParenthesizedPattern
                    Result.map
                        (\inParens ->
                            { substitutions = inParens.substitutions
                            , node =
                                { range = fullRange
                                , value =
                                    PatternParenthesized inParens.node
                                , type_ = inParens.node.type_
                                }
                            , introducedExpressionVariables =
                                inParens.introducedExpressionVariables
                            }
                        )
                        (parenthesizedInParens
                            |> patternTypeInfer context
                        )

                [ tuplePart0, tuplePart1 ] ->
                    resultAndThen2
                        (\part0 part1 ->
                            Result.map
                                (\fullSubstitutions ->
                                    { node =
                                        { range = fullRange
                                        , value =
                                            PatternTuple
                                                { part0 = part0.node
                                                , part1 = part1.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTuple
                                                    { part0 = part0.node.type_
                                                    , part1 = part1.node.type_
                                                    }
                                                )
                                        }
                                    , substitutions = fullSubstitutions
                                    , introducedExpressionVariables =
                                        FastDict.union
                                            part0.introducedExpressionVariables
                                            part1.introducedExpressionVariables
                                    }
                                )
                                (variableSubstitutionsMerge
                                    context.declarationTypes
                                    part0.substitutions
                                    part1.substitutions
                                )
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)

                [ tuplePart0, tuplePart1, tuplePart2 ] ->
                    resultAndThen3
                        (\part0 part1 part2 ->
                            Result.map
                                (\fullSubstitutions ->
                                    { node =
                                        { range = fullRange
                                        , value =
                                            PatternTriple
                                                { part0 = part0.node
                                                , part1 = part1.node
                                                , part2 = part2.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTriple
                                                    { part0 = part0.node.type_
                                                    , part1 = part1.node.type_
                                                    , part2 = part2.node.type_
                                                    }
                                                )
                                        }
                                    , substitutions = fullSubstitutions
                                    , introducedExpressionVariables =
                                        FastDict.union
                                            part0.introducedExpressionVariables
                                            (FastDict.union
                                                part1.introducedExpressionVariables
                                                part2.introducedExpressionVariables
                                            )
                                    }
                                )
                                (variableSubstitutionsMerge3
                                    context.declarationTypes
                                    part0.substitutions
                                    part1.substitutions
                                    part2.substitutions
                                )
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)
                        (tuplePart2 |> patternTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.Pattern.RecordPattern recordFields ->
            let
                fieldTypedNodes : List (TypedNode String (Type TypeVariableFromContext))
                fieldTypedNodes =
                    recordFields
                        |> List.map
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) ->
                                { range = fieldRange
                                , value = fieldName
                                , type_ = TypeVariable ( context.path, fieldName )
                                }
                            )
            in
            Ok
                { node =
                    { range = fullRange
                    , value = PatternRecord fieldTypedNodes
                    , type_ =
                        TypeNotVariable
                            (TypeRecord
                                (fieldTypedNodes
                                    |> List.foldl
                                        (\fieldVariable soFar ->
                                            soFar
                                                |> FastDict.insert fieldVariable.value
                                                    fieldVariable.type_
                                        )
                                        FastDict.empty
                                )
                            )
                    }
                , substitutions = variableSubstitutionsNone
                , introducedExpressionVariables =
                    recordFields
                        |> List.foldl
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) soFar ->
                                soFar
                                    |> FastDict.insert fieldName
                                        ( context.path, fieldName )
                            )
                            FastDict.empty
                }

        Elm.Syntax.Pattern.UnConsPattern headNode tailNode ->
            resultAndThen2
                (\headInferred tailInferred ->
                    Result.andThen
                        (\fullListTypeUnified ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , introducedExpressionVariables =
                                        FastDict.union
                                            headInferred.introducedExpressionVariables
                                            tailInferred.introducedExpressionVariables
                                    , node =
                                        { range = fullRange
                                        , value =
                                            PatternListCons
                                                { head = headInferred.node
                                                , tail = tailInferred.node
                                                }
                                        , type_ = fullListTypeUnified.type_
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3
                                    context.declarationTypes
                                    headInferred.substitutions
                                    tailInferred.substitutions
                                    fullListTypeUnified.substitutions
                                )
                        )
                        (typeUnify
                            context.declarationTypes
                            (typeListList headInferred.node.type_)
                            tailInferred.node.type_
                        )
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "head")
                    headNode
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "tail")
                    tailNode
                )

        Elm.Syntax.Pattern.ListPattern elementNodes ->
            case elementNodes of
                [] ->
                    let
                        type_ : Type TypeVariableFromContext
                        type_ =
                            typeListList
                                (TypeVariable ( context.path, "element" ))
                    in
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , introducedExpressionVariables = FastDict.empty
                        , node =
                            { range = fullRange
                            , value = PatternListExact []
                            , type_ = type_
                            }
                        }

                head :: tail ->
                    Result.map
                        (\elementTypeAndSubstitutions ->
                            { substitutions = elementTypeAndSubstitutions.substitutions
                            , introducedExpressionVariables =
                                elementTypeAndSubstitutions.introducedExpressionVariables
                            , node =
                                { range = fullRange
                                , value =
                                    PatternListExact
                                        elementTypeAndSubstitutions.elementNodesReverse
                                , type_ =
                                    typeListList elementTypeAndSubstitutions.elementType
                                }
                            }
                        )
                        (Result.andThen
                            (\headInferred ->
                                tail
                                    |> listFoldlWhileOkFrom
                                        { substitutions = headInferred.substitutions
                                        , elementType = headInferred.node.type_
                                        , elementNodesReverse =
                                            [ headInferred.node
                                            ]
                                        , introducedExpressionVariables =
                                            headInferred.introducedExpressionVariables
                                        , index = 1
                                        }
                                        (\elementNode soFar ->
                                            Result.andThen
                                                (\elementTypedNodeAndSubstitutions ->
                                                    Result.andThen
                                                        (\elementTypeWithCurrent ->
                                                            Result.map
                                                                (\substitutionsWithElement ->
                                                                    { index = soFar.index + 1
                                                                    , elementNodesReverse =
                                                                        elementTypedNodeAndSubstitutions.node
                                                                            :: soFar.elementNodesReverse
                                                                    , elementType = elementTypeWithCurrent.type_
                                                                    , substitutions = substitutionsWithElement
                                                                    , introducedExpressionVariables =
                                                                        FastDict.union
                                                                            elementTypedNodeAndSubstitutions.introducedExpressionVariables
                                                                            soFar.introducedExpressionVariables
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge3 context.declarationTypes
                                                                    elementTypedNodeAndSubstitutions.substitutions
                                                                    elementTypeWithCurrent.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            elementTypedNodeAndSubstitutions.node.type_
                                                            soFar.elementType
                                                        )
                                                )
                                                (patternTypeInfer
                                                    (context
                                                        |> patternContextToInPath
                                                            (soFar.index |> String.fromInt)
                                                    )
                                                    elementNode
                                                )
                                        )
                            )
                            (patternTypeInfer
                                (context |> patternContextToInPath "0")
                                head
                            )
                        )

        Elm.Syntax.Pattern.NamedPattern qualified parameters ->
            case context.moduleOriginLookup.references |> FastDict.get ( qualified.moduleName, qualified.name ) of
                Nothing ->
                    Err
                        ("no module origin found for the variant reference "
                            ++ qualifiedToString
                                { qualification = qualified.moduleName
                                , name = qualified.name
                                }
                        )

                Just moduleOrigin ->
                    case context.declarationTypes |> FastDict.get moduleOrigin of
                        Nothing ->
                            Err
                                ("no declaration types found at the module origin of the variant reference "
                                    ++ qualifiedToString
                                        { qualification = moduleOrigin
                                        , name = qualified.name
                                        }
                                )

                        Just moduleOriginDeclarationTypes ->
                            case
                                moduleOriginDeclarationTypes.choiceTypes
                                    |> fastDictMapAndSmallestJust
                                        (\choiceTypeName choiceTypeInfo ->
                                            choiceTypeInfo.variants
                                                |> FastDict.get qualified.name
                                                |> Maybe.map
                                                    (\variantParameters ->
                                                        { variantParameters = variantParameters
                                                        , choiceTypeName = choiceTypeName
                                                        , choiceTypeParameters = choiceTypeInfo.parameters
                                                        }
                                                    )
                                        )
                            of
                                Nothing ->
                                    Err
                                        ("no choice type found at the module origin with the variant reference "
                                            ++ qualifiedToString
                                                { qualification = moduleOrigin
                                                , name = qualified.name
                                                }
                                        )

                                Just variant ->
                                    patternVariantTypeInfer context
                                        { fullRange = fullRange
                                        , qualification = qualified.moduleName
                                        , moduleOrigin = moduleOrigin
                                        , name = qualified.name
                                        , variantParameters = variant.variantParameters
                                        , choiceTypeName = variant.choiceTypeName
                                        , choiceTypeParameters = variant.choiceTypeParameters
                                        , parameters = parameters
                                        }


patternVariantTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , choiceTypeName : String
        , choiceTypeParameters : List String
        , variantParameters : List (Type String)
        , parameters : List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , introducedExpressionVariables :
                FastDict.Dict String TypeVariableFromContext
            , node :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
patternVariantTypeInfer context patternVariant =
    Result.map
        (\argumentsUnified ->
            { substitutions = argumentsUnified.substitutions
            , introducedExpressionVariables =
                argumentsUnified.introducedExpressionVariables
            , node =
                { range = patternVariant.fullRange
                , value =
                    PatternVariant
                        { moduleOrigin = patternVariant.moduleOrigin
                        , qualification = patternVariant.qualification
                        , name = patternVariant.name
                        , values =
                            argumentsUnified.nodesReverse
                                |> List.reverse
                        }
                , type_ =
                    TypeNotVariable
                        (TypeConstruct
                            { moduleOrigin = patternVariant.moduleOrigin
                            , name = patternVariant.choiceTypeName
                            , arguments =
                                argumentsUnified.nodesReverse
                                    |> listReverseAndMap
                                        (\value -> value.type_)
                            }
                        )
                }
            }
        )
        (List.map2
            (\typeInVariant argumentPattern ->
                { typeInVariant = typeInVariant
                , pattern = argumentPattern
                }
            )
            patternVariant.variantParameters
            patternVariant.parameters
            |> listFoldlWhileOkFrom
                { substitutions = variableSubstitutionsNone
                , introducedExpressionVariables =
                    FastDict.empty
                , nodesReverse = []
                }
                (\argument soFar ->
                    Result.andThen
                        (\argumentPatternInferred ->
                            Result.andThen
                                (\argumentUnified ->
                                    Result.map
                                        (\substitutionsWithArgument ->
                                            { substitutions = substitutionsWithArgument
                                            , introducedExpressionVariables =
                                                FastDict.union
                                                    argumentPatternInferred.introducedExpressionVariables
                                                    soFar.introducedExpressionVariables
                                            , nodesReverse =
                                                argumentPatternInferred.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            argumentPatternInferred.substitutions
                                            argumentUnified.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    argumentPatternInferred.node.type_
                                    (argument.typeInVariant
                                        |> typeMapVariables
                                            (\variableName -> ( context.path, variableName ))
                                    )
                                )
                        )
                        (argument.pattern
                            |> patternTypeInfer context
                        )
                )
        )


listReverseAndMap : (a -> b) -> List a -> List b
listReverseAndMap elementChange list =
    list
        |> List.foldl
            (\element soFar ->
                (element |> elementChange) :: soFar
            )
            []


expressionTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            }
expressionTypeInfer context (Elm.Syntax.Node.Node fullRange expression) =
    -- IGNORE TCO
    case expression of
        Elm.Syntax.Expression.UnitExpr ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionUnit
                    , type_ = TypeNotVariable TypeUnit
                    }
                }

        Elm.Syntax.Expression.Integer intValue ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base10, value = intValue }
                    , type_ = type_
                    }
                }

        Elm.Syntax.Expression.Hex intValue ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base16, value = intValue }
                    , type_ = type_
                    }
                }

        Elm.Syntax.Expression.Floatable floatValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionFloat floatValue
                    , type_ = typeBasicsFloat
                    }
                }

        Elm.Syntax.Expression.Literal stringValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionString stringValue
                    , type_ = typeStringString
                    }
                }

        Elm.Syntax.Expression.CharLiteral charValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionChar charValue
                    , type_ = typeCharChar
                    }
                }

        Elm.Syntax.Expression.PrefixOperator operator ->
            Result.map
                (\type_ ->
                    { node =
                        { range = fullRange
                        , value = ExpressionOperatorFunction operator
                        , type_ = type_
                        }
                    , substitutions = variableSubstitutionsNone
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                    }
                )
                (operatorFunctionType
                    { path = context.path
                    , moduleOriginLookup = context.moduleOriginLookup
                    }
                    operator
                )

        Elm.Syntax.Expression.FunctionOrValue qualification name ->
            Result.map
                (\inferred ->
                    { substitutions = inferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , node =
                        { type_ = inferred.node.type_
                        , range = inferred.node.range
                        , value = ExpressionReference inferred.node.value
                        }
                    }
                )
                (expressionReferenceTypeInfer context
                    { fullRange = fullRange
                    , qualification = qualification
                    , name = name
                    }
                )

        Elm.Syntax.Expression.RecordAccessFunction dotFieldName ->
            let
                fieldName : String
                fieldName =
                    dotFieldName |> String.replace "." ""

                fieldValueType : Type TypeVariableFromContext
                fieldValueType =
                    TypeVariable ( context.path, fieldName )

                type_ : Type TypeVariableFromContext
                type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeRecordExtension
                                        { recordVariable =
                                            ( context.path
                                            , "recordWith"
                                                ++ (fieldName
                                                        |> stringFirstCharToUpper
                                                   )
                                            )
                                        , fields =
                                            FastDict.singleton fieldName
                                                fieldValueType
                                        }
                                    )
                            , output = fieldValueType
                            }
                        )
            in
            Ok
                { node =
                    { range = fullRange
                    , value =
                        ExpressionRecordAccessFunction fieldName
                    , type_ = type_
                    }
                , substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                }

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            Result.map
                (\inParensInferred ->
                    { node =
                        { range = fullRange
                        , value = ExpressionParenthesized inParensInferred.node
                        , type_ = inParensInferred.node.type_
                        }
                    , substitutions = inParensInferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        inParensInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    }
                )
                (inParens
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.Negation toNegate ->
            Result.andThen
                (\toNegateInferred ->
                    Result.andThen
                        (\fullType ->
                            Result.map
                                (\fullSubstitutions ->
                                    { node =
                                        { range = fullRange
                                        , value =
                                            ExpressionNegation toNegateInferred.node
                                        , type_ = fullType.type_
                                        }
                                    , substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        toNegateInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    toNegateInferred.substitutions
                                    fullType.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            toNegateInferred.node.type_
                            (TypeVariable ( context.path, "number" ))
                        )
                )
                (toNegate
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.RecordAccess recordNode fieldNameNode ->
            Result.andThen
                (\accessedRecordInferred ->
                    let
                        fieldName : String
                        fieldName =
                            fieldNameNode |> Elm.Syntax.Node.value

                        fieldValueType : Type TypeVariableFromContext
                        fieldValueType =
                            TypeVariable ( context.path, fieldName )
                    in
                    Result.andThen
                        (\recordWithAccessedField ->
                            Result.map
                                (\fullSubstitutions ->
                                    { node =
                                        { range = fullRange
                                        , value =
                                            ExpressionRecordAccess
                                                { record = accessedRecordInferred.node
                                                , fieldName = fieldName
                                                , fieldNameRange =
                                                    fieldNameNode |> Elm.Syntax.Node.range
                                                }
                                        , type_ = fieldValueType
                                        }
                                    , substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        accessedRecordInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    accessedRecordInferred.substitutions
                                    recordWithAccessedField.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            accessedRecordInferred.node.type_
                            (TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable =
                                        ( context.path
                                        , "recordWith"
                                            ++ (fieldName |> stringFirstCharToUpper)
                                        )
                                    , fields =
                                        FastDict.singleton fieldName
                                            fieldValueType
                                    }
                                )
                            )
                        )
                )
                (expressionTypeInfer context recordNode)

        Elm.Syntax.Expression.OperatorApplication operator _ left right ->
            expressionInfixOperationTypeInfer context
                { fullRange = fullRange
                , operator = operator
                , left = left
                , right = right
                }

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            resultAndThen3
                (\conditionInferred onTrueInferred onFalseInferred ->
                    resultAndThen2
                        (\conditionTypeInferredAsBool resultType ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            conditionInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            onTrueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            onFalseInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionIfThenElse
                                                { condition = conditionInferred.node
                                                , onTrue = onTrueInferred.node
                                                , onFalse = onFalseInferred.node
                                                }
                                        , type_ = resultType.type_
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge5 context.declarationTypes
                                    conditionInferred.substitutions
                                    onTrueInferred.substitutions
                                    onFalseInferred.substitutions
                                    conditionTypeInferredAsBool.substitutions
                                    resultType.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            conditionInferred.node.type_
                            typeBasicsBool
                        )
                        (typeUnify context.declarationTypes
                            onTrueInferred.node.type_
                            onFalseInferred.node.type_
                        )
                )
                (condition
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "condition")
                )
                (onTrue
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onTrue")
                )
                (onFalse
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onFalse")
                )

        Elm.Syntax.Expression.TupledExpression tupleParts ->
            case tupleParts of
                [] ->
                    -- should be handled by UnitExpr
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                        , node =
                            { range = fullRange
                            , value = ExpressionUnit
                            , type_ = TypeNotVariable TypeUnit
                            }
                        }

                [ inParens ] ->
                    -- should be handled by ParenthesizedExpression
                    Result.map
                        (\inParensInferred ->
                            { node =
                                { range = fullRange
                                , value = ExpressionParenthesized inParensInferred.node
                                , type_ = inParensInferred.node.type_
                                }
                            , substitutions = inParensInferred.substitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                inParensInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            }
                        )
                        (inParens
                            |> expressionTypeInfer context
                        )

                [ part0, part1 ] ->
                    resultAndThen2
                        (\part0Inferred part1Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                            part0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part1Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTuple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTuple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    }
                                                )
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )

                [ part0, part1, part2 ] ->
                    resultAndThen3
                        (\part0Inferred part1Inferred part2Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            part0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part1Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part2Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTriple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                , part2 = part2Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTriple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    , part2 = part2Inferred.node.type_
                                                    }
                                                )
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                    part2Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )
                        (part2
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "2")
                        )

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts. Should not exist in a valid parse result"

        Elm.Syntax.Expression.ListExpr elements ->
            case elements of
                [] ->
                    let
                        type_ : Type ( List String, String )
                        type_ =
                            typeListList
                                (TypeVariable ( context.path, "element" ))
                    in
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        , node =
                            { range = fullRange
                            , value = ExpressionList []
                            , type_ = type_
                            }
                        }

                head :: tail ->
                    Result.map
                        (\elementsInferred ->
                            { substitutions = elementsInferred.substitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                elementsInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            , node =
                                { range = fullRange
                                , value =
                                    ExpressionList
                                        elementsInferred.elementNodesReverse
                                , type_ =
                                    typeListList elementsInferred.elementType
                                }
                            }
                        )
                        (Result.andThen
                            (\headInferred ->
                                tail
                                    |> listFoldlWhileOkFrom
                                        { substitutions = headInferred.substitutions
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                        , elementType = headInferred.node.type_
                                        , elementNodesReverse = [ headInferred.node ]
                                        , index = 1
                                        }
                                        (\elementNode soFar ->
                                            Result.andThen
                                                (\elementInferred ->
                                                    Result.andThen
                                                        (\elementTypeWithCurrent ->
                                                            Result.map
                                                                (\substitutionsWithElement ->
                                                                    { index = soFar.index + 1
                                                                    , elementNodesReverse =
                                                                        elementInferred.node
                                                                            :: soFar.elementNodesReverse
                                                                    , elementType = elementTypeWithCurrent.type_
                                                                    , substitutions = substitutionsWithElement
                                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                                            elementInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge3 context.declarationTypes
                                                                    elementInferred.substitutions
                                                                    elementTypeWithCurrent.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            elementInferred.node.type_
                                                            soFar.elementType
                                                        )
                                                )
                                                (expressionTypeInfer
                                                    (context
                                                        |> expressionContextToInPath
                                                            (soFar.index |> String.fromInt)
                                                    )
                                                    elementNode
                                                )
                                        )
                            )
                            (expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                                head
                            )
                        )

        Elm.Syntax.Expression.Application application ->
            case application of
                [] ->
                    Err "empty application is invalid syntax"

                [ subExpression ] ->
                    -- never produced by elm-syntax
                    subExpression |> expressionTypeInfer context

                called :: argument0 :: argument1Up ->
                    resultAndThen3
                        (\calledInferred argument0Inferred argument1UpInferred ->
                            let
                                resultType : Type TypeVariableFromContext
                                resultType =
                                    TypeVariable ( context.path, "callResult" )

                                calledTypeInferredFromArguments : Type TypeVariableFromContext
                                calledTypeInferredFromArguments =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = argument0Inferred.node.type_
                                            , output =
                                                argument1UpInferred.nodesReverse
                                                    |> List.foldl
                                                        (\argumentInferred output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentInferred.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        resultType
                                            }
                                        )
                            in
                            Result.andThen
                                (\callType ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    calledInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    argument0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    argument1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCall
                                                        { called = calledInferred.node
                                                        , argument0 = argument0Inferred.node
                                                        , argument1Up =
                                                            argument1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = resultType
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge4 context.declarationTypes
                                            calledInferred.substitutions
                                            argument0Inferred.substitutions
                                            argument1UpInferred.substitutions
                                            callType.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    calledTypeInferredFromArguments
                                    calledInferred.node.type_
                                )
                        )
                        (called
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "called")
                        )
                        (argument0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "argument0")
                        )
                        (argument1Up
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                , index = 1
                                }
                                (\argumentNode soFar ->
                                    Result.andThen
                                        (\argumentInferred ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { index = soFar.index + 1
                                                    , substitutions = substitutionsWithArgument
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            argumentInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        argumentInferred.node
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    argumentInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (argumentNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("argument" ++ (soFar.index |> String.fromInt))
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.RecordExpr fields ->
            Result.map
                (\fieldsInferred ->
                    { substitutions =
                        fieldsInferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        fieldsInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , node =
                        { range = fullRange
                        , value =
                            ExpressionRecord
                                (fieldsInferred.fieldTypedNodesReverse
                                    |> List.reverse
                                )
                        , type_ =
                            TypeNotVariable
                                (TypeRecord
                                    (fieldsInferred.fieldTypedNodesReverse
                                        |> List.foldl
                                            (\field soFar ->
                                                soFar
                                                    |> FastDict.insert field.name
                                                        field.value.type_
                                            )
                                            FastDict.empty
                                    )
                                )
                        }
                    }
                )
                (fields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                        , fieldTypedNodesReverse = []
                        }
                        (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node fieldNameRange fieldName, fieldValueNode )) soFar ->
                            Result.andThen
                                (\fieldValueInferred ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { fieldTypedNodesReverse =
                                                { range = fieldRange
                                                , name = fieldName
                                                , nameRange = fieldNameRange
                                                , value = fieldValueInferred.node
                                                }
                                                    :: soFar.fieldTypedNodesReverse
                                            , substitutions = substitutionsWithField
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                    fieldValueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            }
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            fieldValueInferred.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValueNode
                                    |> expressionTypeInfer
                                        (context |> expressionContextToInPath fieldName)
                                )
                        )
                )

        Elm.Syntax.Expression.RecordUpdateExpression (Elm.Syntax.Node.Node recordVariableRange recordVariable) fields ->
            case fields of
                [] ->
                    Err "record update without fields is invalid syntax"

                (Elm.Syntax.Node.Node field0Range ( Elm.Syntax.Node.Node field0NameRange field0Name, field0ValueNode )) :: field1Up ->
                    resultAndThen3
                        (\recordVariableInferred field0Inferred field1UpInferred ->
                            Result.andThen
                                (\typeUnified ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    recordVariableInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    field0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    field1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionRecordUpdate
                                                        { recordVariable =
                                                            { range = recordVariableInferred.node.range
                                                            , value =
                                                                { moduleOrigin =
                                                                    recordVariableInferred.node.value.moduleOrigin
                                                                , name = recordVariableInferred.node.value.name
                                                                }
                                                            , type_ = typeUnified.type_
                                                            }
                                                        , field0 = field0Inferred.node
                                                        , field1Up =
                                                            field1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = typeUnified.type_
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge4 context.declarationTypes
                                            typeUnified.substitutions
                                            recordVariableInferred.substitutions
                                            field0Inferred.substitutions
                                            field1UpInferred.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    recordVariableInferred.node.type_
                                    (TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable = ( context.path, "record" )
                                            , fields =
                                                field1UpInferred.nodesReverse
                                                    |> List.foldl
                                                        (\fieldInferred soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldInferred.name
                                                                    fieldInferred.value.type_
                                                        )
                                                        (FastDict.singleton
                                                            field0Inferred.node.name
                                                            field0Inferred.node.value.type_
                                                        )
                                            }
                                        )
                                    )
                                )
                        )
                        ({ fullRange = recordVariableRange
                         , qualification = []
                         , name = recordVariable
                         }
                            |> expressionReferenceTypeInfer
                                (context |> expressionContextToInPath "record")
                        )
                        (Result.map
                            (\valueInferred ->
                                { substitutions = valueInferred.substitutions
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                    valueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                , node =
                                    { range = field0Range
                                    , name = field0Name
                                    , nameRange = field0NameRange
                                    , value = valueInferred.node
                                    }
                                }
                            )
                            (field0ValueNode
                                |> expressionTypeInfer
                                    (context
                                        |> expressionContextToInPath
                                            ("field" ++ stringFirstCharToUpper field0Name)
                                    )
                            )
                        )
                        (field1Up
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                }
                                (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node nameRange name, valueNode )) soFar ->
                                    Result.andThen
                                        (\fieldValueInferred ->
                                            Result.map
                                                (\substitutionsWithField ->
                                                    { substitutions = substitutionsWithField
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            fieldValueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        { range = fieldRange
                                                        , name = name
                                                        , nameRange = nameRange
                                                        , value = fieldValueInferred.node
                                                        }
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    soFar.substitutions
                                                    fieldValueInferred.substitutions
                                                )
                                        )
                                        (valueNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("field" ++ stringFirstCharToUpper name)
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.LambdaExpression lambda ->
            case lambda.args of
                [] ->
                    Err "lambda without parameter patterns is invalid syntax"

                parameter0 :: parameter1Up ->
                    resultAndThen2
                        (\parameter0Inferred parameter1UpInferred ->
                            Result.andThen
                                (\resultInferred ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionLambda
                                                        { parameter0 = parameter0Inferred.node
                                                        , parameter1Up =
                                                            parameter1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        , result = resultInferred.node
                                                        }
                                                , type_ =
                                                    TypeNotVariable
                                                        (TypeFunction
                                                            { input = parameter0Inferred.node.type_
                                                            , output =
                                                                parameter1UpInferred.nodesReverse
                                                                    |> List.foldl
                                                                        (\argumentTypedNode output ->
                                                                            TypeNotVariable
                                                                                (TypeFunction
                                                                                    { input = argumentTypedNode.type_
                                                                                    , output = output
                                                                                    }
                                                                                )
                                                                        )
                                                                        resultInferred.node.type_
                                                            }
                                                        )
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge3 context.declarationTypes
                                            parameter0Inferred.substitutions
                                            parameter1UpInferred.substitutions
                                            resultInferred.substitutions
                                        )
                                )
                                (lambda.expression
                                    |> expressionTypeInfer
                                        { containingDeclarationName = context.containingDeclarationName
                                        , path = "lambdaResult" :: context.path
                                        , declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , partiallyInferredDeclarationTypes =
                                            context.partiallyInferredDeclarationTypes
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                (FastDict.union
                                                    parameter0Inferred.introducedExpressionVariables
                                                    parameter1UpInferred.introducedExpressionVariables
                                                    |> FastDict.map
                                                        (\_ introduced ->
                                                            introduced |> TypeVariable
                                                        )
                                                )
                                                context.locallyIntroducedExpressionVariables
                                        }
                                )
                        )
                        (parameter0
                            |> patternTypeInfer
                                { path = "parameter0" :: context.path
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (parameter1Up
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , introducedExpressionVariables = FastDict.empty
                                , nodesReverse = []
                                , index = 1
                                }
                                (\pattern soFar ->
                                    Result.andThen
                                        (\patternInferred ->
                                            Result.map
                                                (\substitutionsWithPattern ->
                                                    { index = soFar.index + 1
                                                    , substitutions = substitutionsWithPattern
                                                    , nodesReverse =
                                                        patternInferred.node
                                                            :: soFar.nodesReverse
                                                    , introducedExpressionVariables =
                                                        FastDict.union
                                                            patternInferred.introducedExpressionVariables
                                                            soFar.introducedExpressionVariables
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    soFar.substitutions
                                                    patternInferred.substitutions
                                                )
                                        )
                                        (pattern
                                            |> patternTypeInfer
                                                { path =
                                                    ("parameter" ++ (soFar.index |> String.fromInt))
                                                        :: context.path
                                                , declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                }
                                        )
                                )
                            |> Result.map
                                (\folded ->
                                    { substitutions = folded.substitutions
                                    , introducedExpressionVariables =
                                        folded.introducedExpressionVariables
                                    , nodesReverse = folded.nodesReverse
                                    }
                                )
                        )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            case caseOf.cases of
                [] ->
                    Err "case-of without case branches is invalid syntax"

                ( case0Pattern, case0Result ) :: case1Up ->
                    resultAndThen3
                        (\matchedInferred case0Inferred case1UpInferred ->
                            Result.andThen
                                (\unifiedTypes ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    matchedInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    case0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    case1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCaseOf
                                                        { matchedExpression = matchedInferred.node
                                                        , case0 = case0Inferred.node
                                                        , case1Up =
                                                            case1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = unifiedTypes.resultType
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge4 context.declarationTypes
                                            matchedInferred.substitutions
                                            case0Inferred.substitutions
                                            case1UpInferred.substitutions
                                            unifiedTypes.substitutions
                                        )
                                )
                                (Result.andThen
                                    (\matchedExpressionCase0PatternUnifiedType ->
                                        case1UpInferred.nodesReverse
                                            |> listFoldlWhileOkFrom
                                                { resultType = case0Inferred.node.result.type_
                                                , matchedType = matchedExpressionCase0PatternUnifiedType.type_
                                                , substitutions = matchedExpressionCase0PatternUnifiedType.substitutions
                                                }
                                                (\caseInferred soFar ->
                                                    resultAndThen2
                                                        (\matchedTypeUnifiedWithCasePattern resultTypeUnifiedWithCaseResult ->
                                                            Result.map
                                                                (\substitutionsWithCase ->
                                                                    { substitutions = substitutionsWithCase
                                                                    , matchedType = matchedTypeUnifiedWithCasePattern.type_
                                                                    , resultType = resultTypeUnifiedWithCaseResult.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge3 context.declarationTypes
                                                                    soFar.substitutions
                                                                    matchedTypeUnifiedWithCasePattern.substitutions
                                                                    resultTypeUnifiedWithCaseResult.substitutions
                                                                )
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            soFar.matchedType
                                                            caseInferred.pattern.type_
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            soFar.resultType
                                                            caseInferred.result.type_
                                                        )
                                                )
                                    )
                                    (typeUnify context.declarationTypes
                                        matchedInferred.node.type_
                                        case0Inferred.node.pattern.type_
                                    )
                                )
                        )
                        (caseOf.expression
                            |> expressionTypeInfer (context |> expressionContextToInPath "matched")
                        )
                        (Result.andThen
                            (\patternInferred ->
                                Result.andThen
                                    (\resultInferred ->
                                        Result.map
                                            (\fullSubstitutions ->
                                                { substitutions = fullSubstitutions
                                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                    resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                , node =
                                                    { pattern = patternInferred.node
                                                    , result = resultInferred.node
                                                    }
                                                }
                                            )
                                            (variableSubstitutionsMerge context.declarationTypes
                                                patternInferred.substitutions
                                                resultInferred.substitutions
                                            )
                                    )
                                    (case0Result
                                        |> expressionTypeInfer
                                            { declarationTypes = context.declarationTypes
                                            , moduleOriginLookup = context.moduleOriginLookup
                                            , partiallyInferredDeclarationTypes =
                                                context.partiallyInferredDeclarationTypes
                                            , containingDeclarationName = context.containingDeclarationName
                                            , path = "result" :: "case0" :: context.path
                                            , locallyIntroducedExpressionVariables =
                                                FastDict.union
                                                    (patternInferred.introducedExpressionVariables
                                                        |> FastDict.map
                                                            (\_ introduced ->
                                                                introduced |> TypeVariable
                                                            )
                                                    )
                                                    context.locallyIntroducedExpressionVariables
                                            }
                                    )
                            )
                            (case0Pattern
                                |> patternTypeInfer
                                    { declarationTypes = context.declarationTypes
                                    , moduleOriginLookup = context.moduleOriginLookup
                                    , path = "pattern" :: "case0" :: context.path
                                    }
                            )
                        )
                        (case1Up
                            |> listFoldlWhileOkFrom
                                { index = 1
                                , substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                }
                                (\( casePattern, caseResult ) soFar ->
                                    let
                                        casePath : List String
                                        casePath =
                                            ("case" ++ (soFar.index |> String.fromInt))
                                                :: context.path
                                    in
                                    Result.andThen
                                        (\patternInferred ->
                                            Result.andThen
                                                (\resultInferred ->
                                                    Result.map
                                                        (\fullSubstitutions ->
                                                            { index = soFar.index + 1
                                                            , substitutions = fullSubstitutions
                                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                                    resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            , nodesReverse =
                                                                { pattern = patternInferred.node
                                                                , result = resultInferred.node
                                                                }
                                                                    :: soFar.nodesReverse
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge3 context.declarationTypes
                                                            patternInferred.substitutions
                                                            resultInferred.substitutions
                                                            soFar.substitutions
                                                        )
                                                )
                                                (caseResult
                                                    |> expressionTypeInfer
                                                        { declarationTypes = context.declarationTypes
                                                        , partiallyInferredDeclarationTypes =
                                                            context.partiallyInferredDeclarationTypes
                                                        , moduleOriginLookup = context.moduleOriginLookup
                                                        , containingDeclarationName = context.containingDeclarationName
                                                        , path = "result" :: casePath
                                                        , locallyIntroducedExpressionVariables =
                                                            FastDict.union
                                                                (patternInferred.introducedExpressionVariables
                                                                    |> FastDict.map
                                                                        (\_ introduced ->
                                                                            introduced |> TypeVariable
                                                                        )
                                                                )
                                                                context.locallyIntroducedExpressionVariables
                                                        }
                                                )
                                        )
                                        (casePattern
                                            |> patternTypeInfer
                                                { declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , path = "pattern" :: casePath
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.LetExpression letIn ->
            case letIn.declarations of
                [] ->
                    Err "let-in without declarations is invalid syntax"

                letDeclaration0Node :: letDeclaration1Up ->
                    let
                        expressionVariablesIntroducedWithFromLetDestructurings : FastDict.Dict String (Type TypeVariableFromContext)
                        expressionVariablesIntroducedWithFromLetDestructurings =
                            (letDeclaration0Node :: letDeclaration1Up)
                                |> List.foldl
                                    (\(Elm.Syntax.Node.Node _ letDeclaration) soFar ->
                                        { index = soFar.index + 1
                                        , introducedExpressionVariables =
                                            case letDeclaration of
                                                Elm.Syntax.Expression.LetDestructuring patternNode _ ->
                                                    case
                                                        patternNode
                                                            |> patternTypeInfer
                                                                { path =
                                                                    "pattern"
                                                                        :: ("letDeclaration" ++ (soFar.index |> String.fromInt))
                                                                        :: context.path
                                                                , declarationTypes = context.declarationTypes
                                                                , moduleOriginLookup = context.moduleOriginLookup
                                                                }
                                                    of
                                                        Err _ ->
                                                            soFar.introducedExpressionVariables

                                                        Ok patternInferred ->
                                                            FastDict.union
                                                                (patternInferred.introducedExpressionVariables
                                                                    |> FastDict.map
                                                                        (\_ introduced ->
                                                                            introduced |> TypeVariable
                                                                        )
                                                                )
                                                                soFar.introducedExpressionVariables

                                                Elm.Syntax.Expression.LetFunction _ ->
                                                    soFar.introducedExpressionVariables
                                        }
                                    )
                                    { index = 0
                                    , introducedExpressionVariables =
                                        context.locallyIntroducedExpressionVariables
                                    }
                                |> .introducedExpressionVariables

                        partiallyInferredDeclarationTypesWithLetValueAndFunctions : FastDict.Dict String (Type TypeVariableFromContext)
                        partiallyInferredDeclarationTypesWithLetValueAndFunctions =
                            (letDeclaration0Node :: letDeclaration1Up)
                                |> List.foldl
                                    (\(Elm.Syntax.Node.Node _ letDeclaration) soFar ->
                                        { index = soFar.index + 1
                                        , partiallyInferredDeclarationTypes =
                                            case letDeclaration of
                                                Elm.Syntax.Expression.LetDestructuring _ _ ->
                                                    soFar.partiallyInferredDeclarationTypes

                                                Elm.Syntax.Expression.LetFunction letFunction ->
                                                    soFar.partiallyInferredDeclarationTypes
                                                        |> FastDict.insert
                                                            (letFunction.declaration
                                                                |> Elm.Syntax.Node.value
                                                                |> .name
                                                                |> Elm.Syntax.Node.value
                                                            )
                                                            (TypeVariable
                                                                ( ("letDeclaration"
                                                                    ++ (soFar.index |> String.fromInt)
                                                                  )
                                                                    :: context.path
                                                                , "type"
                                                                )
                                                            )
                                        }
                                    )
                                    { index = 0
                                    , partiallyInferredDeclarationTypes =
                                        context.partiallyInferredDeclarationTypes
                                    }
                                |> .partiallyInferredDeclarationTypes
                    in
                    resultAndThen3
                        (\declaration0Inferred declaration1UpInferred resultInferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            declaration0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            declaration1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionLetIn
                                                { declaration0 = declaration0Inferred.node
                                                , declaration1Up =
                                                    declaration1UpInferred.nodesReverse
                                                        |> List.reverse
                                                , result = resultInferred.node
                                                }
                                        , type_ = resultInferred.node.type_
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    declaration0Inferred.substitutions
                                    declaration1UpInferred.substitutions
                                    resultInferred.substitutions
                                )
                        )
                        (letDeclaration0Node
                            |> letDeclarationTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letDeclaration0" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    expressionVariablesIntroducedWithFromLetDestructurings
                                , partiallyInferredDeclarationTypes =
                                    partiallyInferredDeclarationTypesWithLetValueAndFunctions
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (letDeclaration1Up
                            |> listFoldlWhileOkFrom
                                { index = 1
                                , substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , introducedExpressionVariables = FastDict.empty
                                , nodesReverse = []
                                }
                                (\letDeclarationNode soFar ->
                                    Result.andThen
                                        (\letDeclarationInferred ->
                                            Result.map
                                                (\substitutionsWithLetDeclaration ->
                                                    { index = soFar.index + 1
                                                    , substitutions = substitutionsWithLetDeclaration
                                                    , introducedExpressionVariables =
                                                        FastDict.union
                                                            letDeclarationInferred.introducedExpressionVariables
                                                            soFar.introducedExpressionVariables
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            letDeclarationInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        letDeclarationInferred.node
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    letDeclarationInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (letDeclarationNode
                                            |> letDeclarationTypeInfer
                                                { containingDeclarationName = context.containingDeclarationName
                                                , path =
                                                    ("letDeclaration"
                                                        ++ (soFar.index |> String.fromInt)
                                                    )
                                                        :: context.path
                                                , locallyIntroducedExpressionVariables =
                                                    expressionVariablesIntroducedWithFromLetDestructurings
                                                , partiallyInferredDeclarationTypes =
                                                    partiallyInferredDeclarationTypesWithLetValueAndFunctions
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , declarationTypes = context.declarationTypes
                                                }
                                        )
                                )
                        )
                        (letIn.expression
                            |> expressionTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letInResult" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    expressionVariablesIntroducedWithFromLetDestructurings
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                , partiallyInferredDeclarationTypes =
                                    partiallyInferredDeclarationTypesWithLetValueAndFunctions
                                }
                        )

        Elm.Syntax.Expression.Operator _ ->
            Err "Elm.Syntax.Expression.Operator should not exist in a valid parse result"

        Elm.Syntax.Expression.GLSLExpression _ ->
            Err "glsl shader expressions not supported"


expressionReferenceTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                    , qualification : Elm.Syntax.ModuleName.ModuleName
                    , name : String
                    }
                    (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            }
expressionReferenceTypeInfer context expressionReference =
    case context.moduleOriginLookup.references |> FastDict.get ( expressionReference.qualification, expressionReference.name ) of
        Just moduleOrigin ->
            case context.declarationTypes |> FastDict.get moduleOrigin of
                Nothing ->
                    Err
                        ("No declaration types found for the origin module "
                            ++ (moduleOrigin |> moduleNameToString)
                        )

                Just originModuleDeclarationTypes ->
                    case originModuleDeclarationTypes.signatures |> FastDict.get expressionReference.name of
                        Just signatureType ->
                            Ok
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = expressionReference.qualification
                                        , moduleOrigin = moduleOrigin
                                        , name = expressionReference.name
                                        }
                                    , type_ =
                                        signatureType
                                            |> typeMapVariables
                                                (\variableName -> ( context.path, variableName ))
                                    }
                                }

                        Nothing ->
                            case
                                originModuleDeclarationTypes.choiceTypes
                                    |> fastDictMapAndSmallestJust
                                        (\choiceTypeName choiceTypeInfo ->
                                            choiceTypeInfo.variants
                                                |> FastDict.get expressionReference.name
                                                |> Maybe.map
                                                    (\variantParameters ->
                                                        { variantParameters = variantParameters
                                                        , choiceTypeName = choiceTypeName
                                                        , choiceTypeParameters = choiceTypeInfo.parameters
                                                        }
                                                    )
                                        )
                            of
                                Just variant ->
                                    let
                                        resultType : Type String
                                        resultType =
                                            TypeNotVariable
                                                (TypeConstruct
                                                    { moduleOrigin = moduleOrigin
                                                    , name = variant.choiceTypeName
                                                    , arguments =
                                                        variant.choiceTypeParameters
                                                            |> List.map TypeVariable
                                                    }
                                                )

                                        fullType : Type TypeVariableFromContext
                                        fullType =
                                            variant.variantParameters
                                                |> List.foldr
                                                    (\argument output ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = argument
                                                                , output = output
                                                                }
                                                            )
                                                    )
                                                    resultType
                                                |> typeMapVariables
                                                    (\variableName -> ( context.path, variableName ))
                                    in
                                    Ok
                                        { substitutions = variableSubstitutionsNone
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                        , node =
                                            { range = expressionReference.fullRange
                                            , value =
                                                { qualification = expressionReference.qualification
                                                , moduleOrigin = moduleOrigin
                                                , name = expressionReference.name
                                                }
                                            , type_ = fullType
                                            }
                                        }

                                Nothing ->
                                    case originModuleDeclarationTypes.typeAliases |> FastDict.get expressionReference.name of
                                        Just _ ->
                                            Err
                                                ("I found what looks like a record type alias constructor: "
                                                    ++ qualifiedToString
                                                        { qualification = moduleOrigin, name = expressionReference.name }
                                                    ++ ". These are not supported, yet because our record types don't preserve field order.\n"
                                                    ++ "Hint: no value/function/port/variant was found in the origin module of that reference, so that might be the actual problem."
                                                )

                                        Nothing ->
                                            Err
                                                ("No value/function/port/variant/record type alias constructor found in the origin module of the reference "
                                                    ++ qualifiedToString
                                                        { qualification = moduleOrigin, name = expressionReference.name }
                                                )

        Nothing ->
            case expressionReference.qualification of
                qualificationPart0 :: qualificationPart1Up ->
                    Err
                        ("No origin module found for the qualified reference "
                            ++ qualifiedToString
                                { qualification = qualificationPart0 :: qualificationPart1Up
                                , name = expressionReference.name
                                }
                        )

                [] ->
                    case context.locallyIntroducedExpressionVariables |> FastDict.get expressionReference.name of
                        Nothing ->
                            case context.partiallyInferredDeclarationTypes |> FastDict.get expressionReference.name of
                                Nothing ->
                                    Err
                                        ("No locally introduced expression variable or un-annotated declaration found with the name "
                                            ++ expressionReference.name
                                        )

                                Just partiallyInferredType ->
                                    let
                                        partiallyInferredTypeVariableNameToInContext : TypeVariableFromContext -> TypeVariableFromContext
                                        partiallyInferredTypeVariableNameToInContext ( partiallyInferredTypeVariableContext, partiallyInferredTypeVariableName ) =
                                            ( partiallyInferredTypeVariableContext
                                                ++ context.path
                                            , partiallyInferredTypeVariableName
                                            )

                                        type_ : Type TypeVariableFromContext
                                        type_ =
                                            partiallyInferredType
                                                |> typeMapVariables partiallyInferredTypeVariableNameToInContext
                                    in
                                    Ok
                                        { substitutions = variableSubstitutionsNone
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            partiallyInferredType
                                                |> typeContainedVariables
                                                |> FastSet.foldl
                                                    (\partiallyInferredTypeVariable soFar ->
                                                        soFar
                                                            |> FastDict.insert
                                                                partiallyInferredTypeVariable
                                                                (FastSet.singleton
                                                                    (partiallyInferredTypeVariable
                                                                        |> partiallyInferredTypeVariableNameToInContext
                                                                    )
                                                                )
                                                    )
                                                    FastDict.empty
                                        , node =
                                            { range = expressionReference.fullRange
                                            , value =
                                                { qualification = []
                                                , moduleOrigin = []
                                                , name = expressionReference.name
                                                }
                                            , type_ = type_
                                            }
                                        }

                        Just locallyIntroducedExpressionVariable ->
                            Ok
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = []
                                        , moduleOrigin = []
                                        , name = expressionReference.name
                                        }
                                    , type_ = locallyIntroducedExpressionVariable
                                    }
                                }


usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert :
    TypeVariableFromContext
    -> TypeVariableFromContext
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert partialVariable use usesOfTypeVariablesFromPartiallyInferredDeclarations =
    usesOfTypeVariablesFromPartiallyInferredDeclarations
        |> FastDict.update partialVariable
            (\maybeUsesSoFar ->
                Just
                    (case maybeUsesSoFar of
                        Nothing ->
                            FastSet.singleton use

                        Just usesSoFar ->
                            usesSoFar |> FastSet.insert use
                    )
            )


usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3 :
    FastDict.Dict
        TypeVariableFromContext
        (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3 a b c =
    usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
        (usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
            a
            b
        )
        c


usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge :
    FastDict.Dict
        TypeVariableFromContext
        (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge a b =
    FastDict.merge
        (\variable uses soFar ->
            soFar |> FastDict.insert variable uses
        )
        (\variable usesA usesB soFar ->
            soFar
                |> FastDict.insert variable
                    (FastSet.union usesA usesB)
        )
        (\variable uses soFar ->
            soFar |> FastDict.insert variable uses
        )
        a
        b
        FastDict.empty


letDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            }
letDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letDeclaration) =
    case letDeclaration of
        Elm.Syntax.Expression.LetDestructuring letDestructuringPattern letDestructuringExpression ->
            resultAndThen2
                (\patternInferred expressionInferred ->
                    Result.andThen
                        (\patternExpressionUnifiedType ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , introducedExpressionVariables =
                                        patternInferred.introducedExpressionVariables
                                            |> FastDict.map
                                                (\_ introduced ->
                                                    introduced |> TypeVariable
                                                )
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        expressionInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = letDeclarationRange
                                        , declaration =
                                            LetDestructuring
                                                { pattern = patternInferred.node
                                                , expression = expressionInferred.node
                                                }
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    patternInferred.substitutions
                                    expressionInferred.substitutions
                                    patternExpressionUnifiedType.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            patternInferred.node.type_
                            expressionInferred.node.type_
                        )
                )
                (letDestructuringPattern
                    |> patternTypeInfer
                        { path = "pattern" :: context.path
                        , declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        }
                )
                (letDestructuringExpression
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "expression")
                )

        Elm.Syntax.Expression.LetFunction letValueOrFunction ->
            letFunctionOrValueDeclarationTypeInfer context
                (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction)


letFunctionOrValueDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Function
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            }
letFunctionOrValueDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction) =
    let
        implementation : Elm.Syntax.Expression.FunctionImplementation
        implementation =
            letValueOrFunction.declaration |> Elm.Syntax.Node.value
    in
    Result.andThen
        (\argumentsInferred ->
            let
                letDeclarationTypeVariable : TypeVariableFromContext
                letDeclarationTypeVariable =
                    ( context.path, "type" )

                name : String
                name =
                    implementation.name |> Elm.Syntax.Node.value
            in
            Result.andThen
                (\resultInferred ->
                    let
                        letDeclarationPartiallyInferredType : Type TypeVariableFromContext
                        letDeclarationPartiallyInferredType =
                            argumentsInferred.nodesReverse
                                |> List.foldl
                                    (\parameterTypedNode outputSoFar ->
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = parameterTypedNode.type_
                                                , output = outputSoFar
                                                }
                                            )
                                    )
                                    resultInferred.node.type_
                    in
                    Result.andThen
                        (\fullSubstitutions ->
                            case letValueOrFunction.signature of
                                Nothing ->
                                    Ok
                                        { substitutions = fullSubstitutions
                                        , node =
                                            { range = letDeclarationRange
                                            , declaration =
                                                LetValueOrFunctionDeclaration
                                                    { signature =
                                                        Nothing
                                                    , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                    , name = name
                                                    , parameters =
                                                        argumentsInferred.nodesReverse
                                                            |> List.reverse
                                                    , result = resultInferred.node
                                                    , type_ = letDeclarationPartiallyInferredType
                                                    }
                                            }
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        , introducedExpressionVariables = FastDict.empty
                                        }

                                Just (Elm.Syntax.Node.Node signatureRange letValueOrFunctionSignature) ->
                                    Result.andThen
                                        (\annotationAsType ->
                                            Result.map
                                                (\typeUnifiedWithAnnotation ->
                                                    { substitutions = fullSubstitutions
                                                    , node =
                                                        { range = letDeclarationRange
                                                        , declaration =
                                                            LetValueOrFunctionDeclaration
                                                                { signature =
                                                                    Just
                                                                        { range = signatureRange
                                                                        , nameRange =
                                                                            letValueOrFunctionSignature.name |> Elm.Syntax.Node.range
                                                                        , annotationType =
                                                                            letValueOrFunctionSignature.typeAnnotation
                                                                                |> Elm.Syntax.Node.value
                                                                        , annotationTypeRange =
                                                                            letValueOrFunctionSignature.typeAnnotation
                                                                                |> Elm.Syntax.Node.range
                                                                        }
                                                                , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                , name = name
                                                                , parameters =
                                                                    argumentsInferred.nodesReverse
                                                                        |> List.reverse
                                                                , result = resultInferred.node
                                                                , type_ = typeUnifiedWithAnnotation.type_
                                                                }
                                                        }
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , introducedExpressionVariables = FastDict.empty
                                                    }
                                                )
                                                (typeUnify context.declarationTypes
                                                    letDeclarationPartiallyInferredType
                                                    (annotationAsType
                                                        |> typeMapVariables
                                                            (\variable ->
                                                                ( [ context.containingDeclarationName ], variable )
                                                            )
                                                    )
                                                )
                                        )
                                        (letValueOrFunctionSignature.typeAnnotation
                                            |> Elm.Syntax.Node.value
                                            |> syntaxToType context.moduleOriginLookup
                                        )
                        )
                        (variableSubstitutionsMerge3 context.declarationTypes
                            argumentsInferred.substitutions
                            resultInferred.substitutions
                            (case letDeclarationPartiallyInferredType of
                                TypeVariable letDeclarationPartiallyInferredTypeVariable ->
                                    { equivalentVariables =
                                        [ FastSet.singleton letDeclarationTypeVariable
                                            |> FastSet.insert letDeclarationPartiallyInferredTypeVariable
                                        ]
                                    , variableToType =
                                        FastDict.empty
                                    }

                                TypeNotVariable letDeclarationPartiallyInferredTypeNotVariable ->
                                    { equivalentVariables = []
                                    , variableToType =
                                        FastDict.singleton letDeclarationTypeVariable
                                            letDeclarationPartiallyInferredTypeNotVariable
                                    }
                            )
                        )
                )
                (implementation.expression
                    |> expressionTypeInfer
                        { containingDeclarationName = context.containingDeclarationName
                        , path = "letDeclarationResult" :: context.path
                        , declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , partiallyInferredDeclarationTypes =
                            context.partiallyInferredDeclarationTypes
                        , locallyIntroducedExpressionVariables =
                            FastDict.union
                                argumentsInferred.introducedExpressionVariables
                                context.locallyIntroducedExpressionVariables
                                |> FastDict.insert name
                                    (TypeVariable letDeclarationTypeVariable)
                        }
                )
        )
        (implementation.arguments
            |> parameterPatternsTypeInfer
                { path = context.path
                , declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


moduleNameToString : Elm.Syntax.ModuleName.ModuleName -> String
moduleNameToString moduleName =
    moduleName |> String.join "."


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toLower headChar) tailString


expressionInfixOperationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , operator : String
        , left : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        , right : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionInfixOperationTypeInfer context infixOperation =
    resultAndThen3
        (\operatorAsFunctionType leftInferred rightInferred ->
            let
                resultType : Type TypeVariableFromContext
                resultType =
                    TypeVariable ( context.path, "operationResult" )
            in
            Result.andThen
                (\unifiedType ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                    leftInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    rightInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            , node =
                                { range = infixOperation.fullRange
                                , value =
                                    ExpressionInfixOperation
                                        { symbol = infixOperation.operator
                                        , left = leftInferred.node
                                        , right = rightInferred.node
                                        }
                                , type_ = resultType
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 context.declarationTypes
                            leftInferred.substitutions
                            rightInferred.substitutions
                            unifiedType.substitutions
                        )
                )
                (typeUnify context.declarationTypes
                    operatorAsFunctionType
                    (TypeNotVariable
                        (TypeFunction
                            { input = leftInferred.node.type_
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = rightInferred.node.type_
                                        , output = resultType
                                        }
                                    )
                            }
                        )
                    )
                )
        )
        (operatorFunctionType
            { path = context.path
            , moduleOriginLookup = context.moduleOriginLookup
            }
            infixOperation.operator
        )
        (infixOperation.left
            |> expressionTypeInfer context
        )
        (infixOperation.right
            |> expressionTypeInfer context
        )


operatorFunctionType :
    { path : List String, moduleOriginLookup : ModuleOriginLookup }
    -> String
    -> Result String (Type TypeVariableFromContext)
operatorFunctionType context operator =
    case operator of
        "|>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = a
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                    , output = b
                                    }
                                )
                        }
                    )
                )

        "<|" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        }
                    )
                )

        ">>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = b
                                                , output = c
                                                }
                                            )
                                    , output =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = c
                                                }
                                            )
                                    }
                                )
                        }
                    )
                )

        "<<" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = b
                                    , output = c
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                    , output =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = c
                                                }
                                            )
                                    }
                                )
                        }
                    )
                )

        "++" ->
            let
                appendable : Type TypeVariableFromContext
                appendable =
                    TypeVariable ( context.path, "appendable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = appendable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = appendable
                                    , output = appendable
                                    }
                                )
                        }
                    )
                )

        "==" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.path, "equatable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = equatable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = equatable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "/=" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.path, "equatable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = equatable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = equatable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "::" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = a
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeListList a
                                    , output = a
                                    }
                                )
                        }
                    )
                )

        "*" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "+" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "-" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "/" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "^" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "<=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        ">=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        ">" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "<" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "//" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsInt
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsInt
                                    , output = typeBasicsInt
                                    }
                                )
                        }
                    )
                )

        "&&" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsBool
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsBool
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "||" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsBool
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsBool
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "|." ->
            Ok
                (if context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( context.path, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( context.path, "problem" )

                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( context.path, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input = typeParserAdvancedParser varContext problem keep
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserAdvancedParser varContext problem ignore
                                        , output = typeParserAdvancedParser varContext problem keep
                                        }
                                    )
                            }
                        )

                 else
                    let
                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( context.path, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input = typeParserParser keep
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserParser ignore
                                        , output = typeParserParser keep
                                        }
                                    )
                            }
                        )
                )

        "|=" ->
            Ok
                (if context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( context.path, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( context.path, "problem" )

                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( context.path, "keep" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                typeParserAdvancedParser
                                    varContext
                                    problem
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = a
                                            , output = b
                                            }
                                        )
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserAdvancedParser varContext problem a
                                        , output = typeParserAdvancedParser varContext problem b
                                        }
                                    )
                            }
                        )

                 else
                    let
                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( context.path, "keep" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                typeParserParser
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = a
                                            , output = b
                                            }
                                        )
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserParser a
                                        , output = typeParserParser b
                                        }
                                    )
                            }
                        )
                )

        "</>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeUrlParserParser a b
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeUrlParserParser b c
                                    , output = typeUrlParserParser a c
                                    }
                                )
                        }
                    )
                )

        "<?>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                query : Type TypeVariableFromContext
                query =
                    TypeVariable ( context.path, "query" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            typeUrlParserParser
                                a
                                (TypeNotVariable
                                    (TypeFunction
                                        { input = query
                                        , output = b
                                        }
                                    )
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeUrlParserQueryParser query
                                    , output = typeUrlParserParser a b
                                    }
                                )
                        }
                    )
                )

        unknownOperator ->
            Err ("unknown operator (" ++ unknownOperator ++ ")")


expressionContextToInPath :
    String
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , partiallyInferredDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , partiallyInferredDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
expressionContextToInPath innermostPathDescription context =
    { containingDeclarationName = context.containingDeclarationName
    , path = innermostPathDescription :: context.path
    , declarationTypes = context.declarationTypes
    , locallyIntroducedExpressionVariables =
        context.locallyIntroducedExpressionVariables
    , partiallyInferredDeclarationTypes =
        context.partiallyInferredDeclarationTypes
    , moduleOriginLookup = context.moduleOriginLookup
    }


{-| Infer types of
value/[`Elm.Syntax.Expression.Function`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Function) declarations
in a module.
-}
valueOrFunctionDeclarations :
    { importedTypes :
        FastDict.Dict
            Elm.Syntax.ModuleName.ModuleName
            ModuleTypes
    , otherModuleDeclaredTypes : ModuleTypes
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List Elm.Syntax.Expression.Function
    ->
        Result
            String
            (List
                { name : String
                , nameRange : Elm.Syntax.Range.Range
                , documentation :
                    Maybe
                        { content : String
                        , range : Elm.Syntax.Range.Range
                        }
                , signature :
                    Maybe
                        { range : Elm.Syntax.Range.Range
                        , nameRange : Elm.Syntax.Range.Range
                        , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                        , annotationTypeRange : Elm.Syntax.Range.Range
                        }
                , parameters :
                    List (TypedNode (Pattern (Type String)) (Type String))
                , result : TypedNode (Expression (Type String)) (Type String)
                , type_ : Type String
                }
            )
valueOrFunctionDeclarations typesAndOriginLookup syntaxDeclarationExpressions =
    syntaxDeclarationExpressions
        |> listMapAndCombineOk
            (\syntaxDeclarationExpression ->
                -- TODO handle partials across declarations
                let
                    implementation : Elm.Syntax.Expression.FunctionImplementation
                    implementation =
                        syntaxDeclarationExpression.declaration |> Elm.Syntax.Node.value

                    declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
                    declarationTypes =
                        typesAndOriginLookup.importedTypes
                            |> FastDict.insert []
                                typesAndOriginLookup.otherModuleDeclaredTypes

                    name : String
                    name =
                        implementation.name |> Elm.Syntax.Node.value
                in
                Result.andThen
                    (\parameters ->
                        let
                            resultTypeVariable : TypeVariableFromContext
                            resultTypeVariable =
                                ( [ name ], "declarationResult" )

                            fullType : Type TypeVariableFromContext
                            fullType =
                                parameters.nodesReverse
                                    |> List.foldl
                                        (\argumentTypedNode soFar ->
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = argumentTypedNode.type_
                                                    , output = soFar
                                                    }
                                                )
                                        )
                                        (TypeVariable resultTypeVariable)
                        in
                        Result.andThen
                            (\resultInferred ->
                                let
                                    resultInferredSubstitutions :
                                        { variableToType :
                                            FastDict.Dict
                                                TypeVariableFromContext
                                                (TypeNotVariable TypeVariableFromContext)
                                        , equivalentVariables : List (FastSet.Set TypeVariableFromContext)
                                        }
                                    resultInferredSubstitutions =
                                        case resultInferred.node.type_ of
                                            TypeNotVariable resultInferredNotVariable ->
                                                { variableToType =
                                                    resultInferred.substitutions.variableToType
                                                        |> FastDict.insert resultTypeVariable
                                                            resultInferredNotVariable
                                                , equivalentVariables =
                                                    resultInferred.substitutions.equivalentVariables
                                                }

                                            TypeVariable resultInferredVariable ->
                                                { variableToType =
                                                    resultInferred.substitutions.variableToType
                                                , equivalentVariables =
                                                    equivalentVariablesMergeWithSetOf2
                                                        resultTypeVariable
                                                        resultInferredVariable
                                                        resultInferred.substitutions.equivalentVariables
                                                }
                                in
                                Result.andThen
                                    (\argumentAndResultAndTypeUnifySubstitutions ->
                                        { name = name
                                        , nameRange = implementation.name |> Elm.Syntax.Node.range
                                        , documentation =
                                            case syntaxDeclarationExpression.documentation of
                                                Nothing ->
                                                    Nothing

                                                Just (Elm.Syntax.Node.Node documentationRange documentationContent) ->
                                                    Just
                                                        { range = documentationRange
                                                        , content = documentationContent
                                                        }
                                        , signature =
                                            case syntaxDeclarationExpression.signature of
                                                Nothing ->
                                                    Nothing

                                                Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                                    Just
                                                        { range = signatureRange
                                                        , nameRange = signature.name |> Elm.Syntax.Node.range
                                                        , annotationType = signature.typeAnnotation |> Elm.Syntax.Node.value
                                                        , annotationTypeRange = signature.typeAnnotation |> Elm.Syntax.Node.range
                                                        }
                                        , result = resultInferred.node
                                        , type_ = fullType
                                        , parameters =
                                            parameters.nodesReverse |> List.reverse
                                        }
                                            |> valueOrFunctionDeclarationSubstituteVariablesByNotVariables
                                                { declarationTypes = declarationTypes
                                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                    resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                , substitutions =
                                                    argumentAndResultAndTypeUnifySubstitutions
                                                }
                                            |> Result.map
                                                declarationValueOrFunctionDisambiguateTypeVariables
                                    )
                                    (variableSubstitutionsMerge declarationTypes
                                        resultInferredSubstitutions
                                        parameters.substitutions
                                    )
                            )
                            (implementation.expression
                                |> expressionTypeInfer
                                    { declarationTypes = declarationTypes
                                    , locallyIntroducedExpressionVariables =
                                        -- elm declarations do not allow "polymorphic recursion"
                                        -- https://github.com/elm/compiler/issues/2275
                                        -- so instead of putting it in partiallyInferredDeclarationTypes
                                        -- we treat it as an introduced variable (sharing the same type variables)
                                        parameters.introducedExpressionVariables
                                            |> FastDict.insert name fullType
                                    , partiallyInferredDeclarationTypes = FastDict.empty
                                    , containingDeclarationName = name
                                    , path = [ "declarationResult", name ]
                                    , moduleOriginLookup = typesAndOriginLookup.moduleOriginLookup
                                    }
                            )
                    )
                    (implementation.arguments
                        |> parameterPatternsTypeInfer
                            { declarationTypes = declarationTypes
                            , path = [ name ]
                            , moduleOriginLookup = typesAndOriginLookup.moduleOriginLookup
                            }
                    )
            )


type alias ValueOrFunctionDeclaration type_ =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation :
        Maybe
            { content : String
            , range : Elm.Syntax.Range.Range
            }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters :
        List (TypedNode (Pattern type_) type_)
    , result : TypedNode (Expression type_) type_
    , type_ : type_
    }


type alias ModuleLevelDeclarationTypesAvailableInModule =
    FastDict.Dict
        -- `[]` means declared in the same module
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes


declarationValueOrFunctionDisambiguateTypeVariables :
    ValueOrFunctionDeclaration (Type TypeVariableFromContext)
    -> ValueOrFunctionDeclaration (Type String)
declarationValueOrFunctionDisambiguateTypeVariables declarationValueOrFunction =
    let
        globalTypeVariableDisambiguationLookup : FastDict.Dict TypeVariableFromContext String
        globalTypeVariableDisambiguationLookup =
            typeVariablesFromContextToDisambiguationLookup
                (declarationValueOrFunction
                    |> declarationValueOrFunctionContainedGlobalTypeVariables identity
                    |> FastSet.map
                        (\( context, name ) ->
                            ( context |> List.reverse |> List.drop 1
                            , name
                            )
                        )
                )
    in
    declarationValueOrFunction
        |> declarationValueOrFunctionMapTypeVariables
            (\( context, name ) ->
                globalTypeVariableDisambiguationLookup
                    |> FastDict.get
                        ( context |> List.reverse |> List.drop 1
                        , name
                        )
                    |> Maybe.withDefault
                        "thisIsABugInDisambiguationPleaseReportToElmSyntaxTypeInfer"
            )


declarationValueOrFunctionContainedGlobalTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> ValueOrFunctionDeclaration type_
    -> FastSet.Set comparableTypeVariable
declarationValueOrFunctionContainedGlobalTypeVariables typedNodeTypeToExtractVariablesFrom declarationValueOrFunction =
    FastSet.union
        (declarationValueOrFunction.parameters
            |> List.foldl
                (\parameter soFar ->
                    FastSet.union
                        (parameter
                            |> patternTypedNodeContainedTypeVariables
                                typedNodeTypeToExtractVariablesFrom
                        )
                        soFar
                )
                FastSet.empty
        )
        (FastSet.union
            (declarationValueOrFunction.type_
                |> typedNodeTypeToExtractVariablesFrom
                |> typeContainedVariables
            )
            (declarationValueOrFunction.result
                |> expressionTypedNodeContainedTypeVariables
                    typedNodeTypeToExtractVariablesFrom
            )
        )


patternTypedNodeContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> TypedNode (Pattern type_) type_
    -> FastSet.Set comparableTypeVariable
patternTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom patternTypedNode =
    FastSet.union
        (patternTypedNode.type_
            |> typedNodeTypeToExtractVariablesFrom
            |> typeContainedVariables
        )
        (patternTypedNode.value
            |> patternContainedTypeVariables
                typedNodeTypeToExtractVariablesFrom
        )


patternContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> Pattern type_
    -> FastSet.Set comparableTypeVariable
patternContainedTypeVariables typedNodeTypeToExtractVariablesFrom pattern =
    case pattern of
        PatternIgnored ->
            FastSet.empty

        PatternUnit ->
            FastSet.empty

        PatternChar _ ->
            FastSet.empty

        PatternString _ ->
            FastSet.empty

        PatternInt _ ->
            FastSet.empty

        PatternVariable _ ->
            FastSet.empty

        PatternParenthesized inParens ->
            patternTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom
                inParens

        PatternAs patternAs ->
            patternTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom
                patternAs.pattern

        PatternTuple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (parts.part1
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )

        PatternTriple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (parts.part1
                        |> patternTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (parts.part2
                        |> patternTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )

        PatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (patternListCons.tail
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )

        PatternListExact elements ->
            elements
                |> listMapAndFastSetsUnify
                    (\element ->
                        element
                            |> patternTypedNodeContainedTypeVariables
                                typedNodeTypeToExtractVariablesFrom
                    )

        PatternVariant patternVariant ->
            patternVariant.values
                |> listMapAndFastSetsUnify
                    (\value ->
                        value
                            |> patternTypedNodeContainedTypeVariables
                                typedNodeTypeToExtractVariablesFrom
                    )

        PatternRecord fields ->
            fields
                |> listMapAndFastSetsUnify
                    (\fieldTypedNode ->
                        fieldTypedNode.type_
                            |> typedNodeTypeToExtractVariablesFrom
                            |> typeContainedVariables
                    )


listMapAndFastSetsUnify : (a -> FastSet.Set comparable) -> List a -> FastSet.Set comparable
listMapAndFastSetsUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


expressionTypedNodeContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> TypedNode (Expression type_) type_
    -> FastSet.Set comparableTypeVariable
expressionTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom expressionTypedNode =
    FastSet.union
        (expressionTypedNode.type_
            |> typedNodeTypeToExtractVariablesFrom
            |> typeContainedVariables
        )
        (expressionTypedNode.value
            |> expressionContainedTypeVariables
                typedNodeTypeToExtractVariablesFrom
        )


expressionContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> Expression type_
    -> FastSet.Set comparableTypeVariable
expressionContainedTypeVariables typedNodeTypeToExtractVariablesFrom expression =
    case expression of
        ExpressionUnit ->
            FastSet.empty

        ExpressionInteger _ ->
            FastSet.empty

        ExpressionFloat _ ->
            FastSet.empty

        ExpressionString _ ->
            FastSet.empty

        ExpressionChar _ ->
            FastSet.empty

        ExpressionReference _ ->
            FastSet.empty

        ExpressionOperatorFunction _ ->
            FastSet.empty

        ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ExpressionNegation negated ->
            expressionTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeContainedTypeVariables typedNodeTypeToExtractVariablesFrom
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            FastSet.union
                (expressionInfixOperation.left
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )

        ExpressionTuple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (parts.part1
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )

        ExpressionTriple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (parts.part1
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (parts.part2
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )

        ExpressionIfThenElse expressionIfThenElse ->
            FastSet.union
                (expressionIfThenElse.condition
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )

        ExpressionList elements ->
            elements
                |> listMapAndFastSetsUnify
                    (\element ->
                        element
                            |> expressionTypedNodeContainedTypeVariables
                                typedNodeTypeToExtractVariablesFrom
                    )

        ExpressionRecord fields ->
            fields
                |> listMapAndFastSetsUnify
                    (\field ->
                        field.value
                            |> expressionTypedNodeContainedTypeVariables
                                typedNodeTypeToExtractVariablesFrom
                    )

        ExpressionCall expressionCall ->
            FastSet.union
                (expressionCall.called
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (expressionCall.argument0
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (expressionCall.argument1Up
                        |> listMapAndFastSetsUnify
                            (\argument ->
                                argument
                                    |> expressionTypedNodeContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                )

        ExpressionLambda expressionLambda ->
            FastSet.union
                (expressionLambda.parameter0
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (expressionLambda.parameter1Up
                        |> listMapAndFastSetsUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                    (expressionLambda.result
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.union
                (expressionRecordUpdate.recordVariable.type_
                    |> typedNodeTypeToExtractVariablesFrom
                    |> typeContainedVariables
                )
                (FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (expressionRecordUpdate.field1Up
                        |> listMapAndFastSetsUnify
                            (\field ->
                                field.value
                                    |> expressionTypedNodeContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                )

        ExpressionCaseOf expressionCaseOf ->
            FastSet.union
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (expressionCaseOf.case0
                        |> expressionCaseOfCaseContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                    (expressionCaseOf.case1Up
                        |> listMapAndFastSetsUnify
                            (\case_ ->
                                case_
                                    |> expressionCaseOfCaseContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                )

        ExpressionLetIn expressionLetIn ->
            FastSet.union
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (FastSet.union
                    (expressionLetIn.declaration1Up
                        |> listMapAndFastSetsUnify
                            (\letDeclaration ->
                                letDeclaration.declaration
                                    |> letDeclarationContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                    (expressionLetIn.result
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )


letDeclarationContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    -> LetDeclaration type_
    -> FastSet.Set comparableTypeVariable
letDeclarationContainedTypeVariables typedNodeTypeToExtractVariablesFrom letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            FastSet.union
                (letDestructuring.pattern
                    |> patternTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )
                (letDestructuring.expression
                    |> expressionTypedNodeContainedTypeVariables
                        typedNodeTypeToExtractVariablesFrom
                )

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            FastSet.union
                (letValueOrFunctionDeclaration.type_
                    |> typedNodeTypeToExtractVariablesFrom
                    |> typeContainedVariables
                )
                (FastSet.union
                    (letValueOrFunctionDeclaration.parameters
                        |> listMapAndFastSetsUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                                        typedNodeTypeToExtractVariablesFrom
                            )
                    )
                    (letValueOrFunctionDeclaration.result
                        |> expressionTypedNodeContainedTypeVariables
                            typedNodeTypeToExtractVariablesFrom
                    )
                )


expressionCaseOfCaseContainedTypeVariables :
    (type_ -> Type comparableTypeVariable)
    ->
        { pattern : TypedNode (Pattern type_) type_
        , result : TypedNode (Expression type_) type_
        }
    -> FastSet.Set comparableTypeVariable
expressionCaseOfCaseContainedTypeVariables typedNodeTypeToExtractVariablesFrom syntaxCase =
    FastSet.union
        (syntaxCase.pattern
            |> patternTypedNodeContainedTypeVariables
                typedNodeTypeToExtractVariablesFrom
        )
        (syntaxCase.result
            |> expressionTypedNodeContainedTypeVariables
                typedNodeTypeToExtractVariablesFrom
        )


declarationValueOrFunctionCondenseEquivalentVariables :
    List (FastSet.Set TypeVariableFromContext)
    -> ValueOrFunctionDeclaration (Type TypeVariableFromContext)
    ->
        Result
            String
            (ValueOrFunctionDeclaration (Type TypeVariableFromContext))
declarationValueOrFunctionCondenseEquivalentVariables equivalentVariables declarationValueOrFunctionAndEquivalentVariables =
    Result.map
        (\lookupCondensedVariable ->
            declarationValueOrFunctionAndEquivalentVariables
                |> declarationValueOrFunctionMapTypeVariables
                    (\variable ->
                        lookupCondensedVariable
                            |> FastDict.get variable
                            |> Maybe.withDefault variable
                    )
        )
        (createEquivalentVariablesToCondensedVariableLookup equivalentVariables)


createEquivalentVariablesToCondensedVariableLookup :
    List (FastSet.Set TypeVariableFromContext)
    -> Result String (FastDict.Dict TypeVariableFromContext TypeVariableFromContext)
createEquivalentVariablesToCondensedVariableLookup equivalentVariables =
    equivalentVariables
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\equivalentVariableSet soFar ->
                Result.map
                    (\unifiedVariable ->
                        equivalentVariableSet
                            |> FastSet.foldl
                                (\variable soFarInSet ->
                                    soFarInSet
                                        |> FastDict.insert variable unifiedVariable
                                )
                                soFar
                    )
                    (equivalentVariablesCreateCondensedVariable equivalentVariableSet)
            )


valueOrFunctionDeclarationSubstituteVariablesByNotVariables :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , usesOfTypeVariablesFromPartiallyInferredDeclarations :
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    , substitutions : VariableSubstitutions
    }
    -> ValueOrFunctionDeclaration (Type TypeVariableFromContext)
    ->
        Result
            String
            (ValueOrFunctionDeclaration (Type TypeVariableFromContext))
valueOrFunctionDeclarationSubstituteVariablesByNotVariables state declarationValueOrFunctionSoFar =
    case state.substitutions.equivalentVariables of
        [] ->
            let
                new :
                    { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations :
                        FastDict.Dict
                            TypeVariableFromContext
                            (TypeNotVariable TypeVariableFromContext)
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                        FastDict.Dict
                            TypeVariableFromContext
                            (FastSet.Set TypeVariableFromContext)
                    }
                new =
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ type_ uses soFar ->
                            uses
                                |> FastSet.foldl
                                    (\useVariable withUsesSoFar ->
                                        let
                                            ( useVariableContext, useVariableName ) =
                                                useVariable

                                            variableNameForUseFromMoreConcreteReplacementType : TypeVariableFromContext -> TypeVariableFromContext
                                            variableNameForUseFromMoreConcreteReplacementType ( moreConcreteReplacementTypeVariableContext, moreConcreteReplacementTypeVariableName ) =
                                                ( "_usedAs"
                                                    :: useVariableName
                                                    :: useVariableContext
                                                    ++ ("_from"
                                                            :: moreConcreteReplacementTypeVariableName
                                                            :: moreConcreteReplacementTypeVariableContext
                                                       )
                                                , "moreConcrete"
                                                )
                                        in
                                        { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                                            withUsesSoFar.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                                                |> FastDict.insert useVariable
                                                    (type_
                                                        |> typeNotVariableMapVariables
                                                            (\replacementTypeVariable ->
                                                                variableNameForUseFromMoreConcreteReplacementType
                                                                    replacementTypeVariable
                                                            )
                                                    )
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            type_
                                                |> typeNotVariableContainedVariables
                                                |> FastSet.foldl
                                                    (\replacementTypeVariable newUsesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                                        newUsesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                                            |> usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert
                                                                replacementTypeVariable
                                                                (variableNameForUseFromMoreConcreteReplacementType
                                                                    replacementTypeVariable
                                                                )
                                                    )
                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        }
                                    )
                                    soFar
                        )
                        (\typeVariableFromPartiallyInferredDeclaration uses soFar ->
                            { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                                soFar.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    |> FastDict.insert typeVariableFromPartiallyInferredDeclaration
                                        uses
                            }
                        )
                        state.substitutions.variableToType
                        state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                        { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        }
            in
            if Basics.not (FastDict.isEmpty new.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations) then
                valueOrFunctionDeclarationSubstituteVariablesByNotVariables
                    { declarationTypes = state.declarationTypes
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        new.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , substitutions =
                        { equivalentVariables = []
                        , variableToType =
                            FastDict.union
                                state.substitutions.variableToType
                                new.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                        }
                    }
                    declarationValueOrFunctionSoFar

            else
                case state.substitutions.variableToType |> FastDict.popMin of
                    Nothing ->
                        declarationValueOrFunctionSoFar
                            |> declarationValueOrFunctionCondenseEquivalentVariables
                                state.substitutions.equivalentVariables

                    Just ( ( replacementVariable, replacementTypeNotVariable ), remainingReplacements ) ->
                        case
                            declarationValueOrFunctionSoFar
                                |> declarationValueOrFunctionSubstituteVariableByNotVariable
                                    state.declarationTypes
                                    { variable = replacementVariable
                                    , type_ = replacementTypeNotVariable
                                    }
                        of
                            Err error ->
                                Err error

                            Ok substituted ->
                                case
                                    remainingReplacements
                                        |> fastDictFoldlWhileOkFrom
                                            variableSubstitutionsNone
                                            (\remainingVariable remainingReplacementTypeNotVariable soFar ->
                                                Result.andThen
                                                    (\replacementTypeSubstituted ->
                                                        variableSubstitutionsMerge3 state.declarationTypes
                                                            replacementTypeSubstituted.substitutions
                                                            { equivalentVariables = []
                                                            , variableToType =
                                                                FastDict.singleton remainingVariable
                                                                    replacementTypeSubstituted.type_
                                                            }
                                                            soFar
                                                    )
                                                    (remainingReplacementTypeNotVariable
                                                        |> typeNotVariableSubstituteVariableByNotVariable
                                                            state.declarationTypes
                                                            { variable = replacementVariable
                                                            , type_ = replacementTypeNotVariable
                                                            }
                                                    )
                                            )
                                of
                                    Err error ->
                                        Err error

                                    Ok remainingVariableToTypeAndSubstitutions ->
                                        case
                                            variableSubstitutionsMerge
                                                state.declarationTypes
                                                substituted.substitutions
                                                remainingVariableToTypeAndSubstitutions
                                        of
                                            Err error ->
                                                Err error

                                            Ok substitutionsAfterSubstitution ->
                                                valueOrFunctionDeclarationSubstituteVariablesByNotVariables
                                                    { declarationTypes = state.declarationTypes
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , substitutions = substitutionsAfterSubstitution
                                                    }
                                                    substituted.declaration

        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                createEquivalentVariablesToCondensedVariableLookup
                    (equivalentVariableSet0 :: equivalentVariableSet1Up)
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    let
                        variableToTypeUsingCondensedOrError : Result String VariableSubstitutions
                        variableToTypeUsingCondensedOrError =
                            state.substitutions.variableToType
                                |> fastDictFoldlWhileOkFrom
                                    variableSubstitutionsNone
                                    (\uncondensedVariable replacementType soFar ->
                                        case variableToCondensedLookup |> FastDict.get uncondensedVariable of
                                            Nothing ->
                                                Ok
                                                    { equivalentVariables = soFar.equivalentVariables
                                                    , variableToType =
                                                        soFar.variableToType
                                                            |> FastDict.insert uncondensedVariable
                                                                (replacementType
                                                                    |> typeNotVariableMapVariables
                                                                        (\variable ->
                                                                            variableToCondensedLookup
                                                                                |> FastDict.get variable
                                                                                |> Maybe.withDefault variable
                                                                        )
                                                                )
                                                    }

                                            Just condensedVariable ->
                                                let
                                                    replacementTypeUsingCondensedVariables : TypeNotVariable TypeVariableFromContext
                                                    replacementTypeUsingCondensedVariables =
                                                        replacementType
                                                            |> typeNotVariableMapVariables
                                                                (\variable ->
                                                                    variableToCondensedLookup
                                                                        |> FastDict.get variable
                                                                        |> Maybe.withDefault variable
                                                                )
                                                in
                                                case soFar.variableToType |> FastDict.get condensedVariable of
                                                    Nothing ->
                                                        Ok
                                                            { equivalentVariables = soFar.equivalentVariables
                                                            , variableToType =
                                                                soFar.variableToType
                                                                    |> FastDict.insert condensedVariable
                                                                        replacementTypeUsingCondensedVariables
                                                            }

                                                    Just existingReplacementTypeForCondensedVariable ->
                                                        Result.andThen
                                                            (\replacementTypeForCondensedVariable ->
                                                                variableSubstitutionsMerge state.declarationTypes
                                                                    replacementTypeForCondensedVariable.substitutions
                                                                    (case replacementTypeForCondensedVariable.type_ of
                                                                        TypeVariable newEquivalentVariable ->
                                                                            { equivalentVariables =
                                                                                soFar.equivalentVariables
                                                                                    |> equivalentVariablesMergeWithSetOf2
                                                                                        condensedVariable
                                                                                        newEquivalentVariable
                                                                            , variableToType =
                                                                                soFar.variableToType
                                                                            }

                                                                        TypeNotVariable replacementTypeForCondensedVariableTypeNotVariable ->
                                                                            { equivalentVariables =
                                                                                soFar.equivalentVariables
                                                                            , variableToType =
                                                                                soFar.variableToType
                                                                                    |> FastDict.insert condensedVariable
                                                                                        replacementTypeForCondensedVariableTypeNotVariable
                                                                            }
                                                                    )
                                                            )
                                                            (typeNotVariableUnify state.declarationTypes
                                                                existingReplacementTypeForCondensedVariable
                                                                replacementTypeUsingCondensedVariables
                                                            )
                                    )
                    in
                    case variableToTypeUsingCondensedOrError of
                        Err error ->
                            Err error

                        Ok variableToTypeUsingCondensed ->
                            let
                                usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed : FastDict.Dict TypeVariableFromContext (FastSet.Set TypeVariableFromContext)
                                usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed =
                                    state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        |> FastDict.foldl
                                            (\partiallyInferredVariableUncondensed usesUncondensed soFar ->
                                                let
                                                    usesCondensed : FastSet.Set TypeVariableFromContext
                                                    usesCondensed =
                                                        usesUncondensed
                                                            |> FastSet.foldl
                                                                (\useUncondensed usesCondensedSoFar ->
                                                                    case variableToCondensedLookup |> FastDict.get useUncondensed of
                                                                        Nothing ->
                                                                            usesCondensedSoFar

                                                                        Just useCondensed ->
                                                                            usesCondensedSoFar
                                                                                |> FastSet.insert useCondensed
                                                                )
                                                                FastSet.empty
                                                in
                                                soFar
                                                    |> FastDict.update
                                                        (case variableToCondensedLookup |> FastDict.get partiallyInferredVariableUncondensed of
                                                            Nothing ->
                                                                partiallyInferredVariableUncondensed

                                                            Just partiallyInferredVariableCondensed ->
                                                                partiallyInferredVariableCondensed
                                                        )
                                                        (\maybeUsesCondensedSoFar ->
                                                            Just
                                                                (case maybeUsesCondensedSoFar of
                                                                    Nothing ->
                                                                        usesCondensed

                                                                    Just usesCondensedSoFar ->
                                                                        FastSet.union
                                                                            usesCondensed
                                                                            usesCondensedSoFar
                                                                )
                                                        )
                                            )
                                            FastDict.empty
                            in
                            valueOrFunctionDeclarationSubstituteVariablesByNotVariables
                                { declarationTypes = state.declarationTypes
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                    usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed
                                , substitutions =
                                    variableToTypeUsingCondensed
                                }
                                (declarationValueOrFunctionSoFar
                                    |> declarationValueOrFunctionMapTypeVariables
                                        (\variable ->
                                            variableToCondensedLookup
                                                |> FastDict.get variable
                                                |> Maybe.withDefault variable
                                        )
                                )


declarationValueOrFunctionSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> ValueOrFunctionDeclaration (Type TypeVariableFromContext)
    ->
        Result
            String
            { declaration : ValueOrFunctionDeclaration (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
declarationValueOrFunctionSubstituteVariableByNotVariable declarationTypes replacement declarationValueOrFunctionSoFar =
    if replacement.type_ |> typeNotVariableContainedVariables |> FastSet.member replacement.variable then
        if replacement.type_ |> typeNotVariableIsEquivalentToTypeVariable declarationTypes then
            -- is ok when type_ is an identity type alias
            Ok
                { declaration = declarationValueOrFunctionSoFar
                , substitutions = variableSubstitutionsNone
                }

        else
            Err
                ("cannot unify the variable "
                    ++ (replacement.variable |> typeVariableFromContextToName)
                    ++ " with the type "
                    ++ (replacement.type_ |> typeNotVariablePrintRoughly)
                    ++ " because that type contains the type variable itself."
                )

    else
        resultAndThen3
            (\argumentsInferred resultInferred typeInferred ->
                Result.map
                    (\fullSubstitutions ->
                        { declaration =
                            { name = declarationValueOrFunctionSoFar.name
                            , nameRange = declarationValueOrFunctionSoFar.nameRange
                            , documentation = declarationValueOrFunctionSoFar.documentation
                            , signature = declarationValueOrFunctionSoFar.signature
                            , parameters =
                                argumentsInferred.nodesReverse
                                    |> List.reverse
                            , result = resultInferred.node
                            , type_ =
                                -- reconstructing the function at the end is faster
                                typeInferred.type_
                            }
                        , substitutions = fullSubstitutions
                        }
                    )
                    (variableSubstitutionsMerge3 declarationTypes
                        argumentsInferred.substitutions
                        resultInferred.substitutions
                        typeInferred.substitutions
                    )
            )
            (declarationValueOrFunctionSoFar.parameters
                |> listFoldlWhileOkFrom
                    { substitutions = variableSubstitutionsNone
                    , nodesReverse = []
                    }
                    (\patternTypedNode soFar ->
                        Result.andThen
                            (\patternSubstituted ->
                                Result.map
                                    (\fullSubstitutions ->
                                        { substitutions = fullSubstitutions
                                        , nodesReverse =
                                            patternSubstituted.node
                                                :: soFar.nodesReverse
                                        }
                                    )
                                    (variableSubstitutionsMerge declarationTypes
                                        patternSubstituted.substitutions
                                        soFar.substitutions
                                    )
                            )
                            (patternTypedNode
                                |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                    replacement
                            )
                    )
            )
            (declarationValueOrFunctionSoFar.result
                |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )
            (declarationValueOrFunctionSoFar.type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )


typeNotVariableIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable variable_
    -> Bool
typeNotVariableIsEquivalentToTypeVariable declarationTypes typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            case declarationTypes |> FastDict.get typeConstruct.moduleOrigin of
                Nothing ->
                    False

                Just originModule ->
                    case originModule.typeAliases |> FastDict.get typeConstruct.name of
                        Nothing ->
                            False

                        Just typeAlias ->
                            typeAlias.type_ |> typeIsEquivalentToTypeVariable declarationTypes

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type variable_
    -> Bool
typeIsEquivalentToTypeVariable declarationTypes type_ =
    case type_ of
        TypeVariable _ ->
            True

        TypeNotVariable typeNotVariable ->
            typeNotVariable
                |> typeNotVariableIsEquivalentToTypeVariable declarationTypes


typePrintRoughly : Type TypeVariableFromContext -> String
typePrintRoughly type_ =
    case type_ of
        TypeVariable variable ->
            variable |> typeVariableFromContextToName

        TypeNotVariable typeNotVariable ->
            typeNotVariablePrintRoughly typeNotVariable


typeNotVariablePrintRoughly : TypeNotVariable TypeVariableFromContext -> String
typeNotVariablePrintRoughly typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typePrintRoughly)
                ++ ") -> ("
                ++ (typeFunction.output |> typePrintRoughly)
                ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part2 |> typePrintRoughly)
                ++ " )"

        TypeConstruct typeConstruct ->
            (typeConstruct.moduleOrigin
                |> String.join "."
            )
                ++ "."
                ++ typeConstruct.name
                ++ " "
                ++ (typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                "(" ++ (argument |> typePrintRoughly) ++ ")"
                            )
                        |> String.join ", "
                   )

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension typeRecordExtension ->
            "{ "
                ++ (typeRecordExtension.recordVariable
                        |> typeVariableFromContextToName
                   )
                ++ " | "
                ++ (typeRecordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"


declarationValueOrFunctionMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> ValueOrFunctionDeclaration (Type typeVariable)
    -> ValueOrFunctionDeclaration (Type changedTypeVariable)
declarationValueOrFunctionMapTypeVariables variableChange declarationValueOrFunctionSoFar =
    { name = declarationValueOrFunctionSoFar.name
    , nameRange = declarationValueOrFunctionSoFar.nameRange
    , documentation = declarationValueOrFunctionSoFar.documentation
    , signature =
        declarationValueOrFunctionSoFar.signature
            |> Maybe.map
                (\signature ->
                    { range = signature.range
                    , annotationType = signature.annotationType
                    , annotationTypeRange = signature.annotationTypeRange
                    , nameRange = signature.nameRange
                    }
                )
    , parameters =
        declarationValueOrFunctionSoFar.parameters
            |> List.map
                (\argument ->
                    argument |> patternTypedNodeMapTypeVariables variableChange
                )
    , result =
        declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeMapTypeVariables variableChange
    , type_ =
        -- reconstructing the function is probably faster
        declarationValueOrFunctionSoFar.type_
            |> typeMapVariables variableChange
    }


expressionTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionTypedNodeSubstituteVariableByNotVariable declarationTypes replacement expression =
    -- IGNORE TCO
    case expression.value of
        ExpressionUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expression
                }

        ExpressionFloat _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expression
                }

        ExpressionChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expression
                }

        ExpressionString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expression
                }

        ExpressionInteger _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionReference _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionOperatorFunction _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionNegation _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionParenthesized _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccess _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccessFunction _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = expression.range
                        , value = expression.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionInfixOperation expressionInfixOperation ->
            resultAndThen3
                (\leftSubstituted rightSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionInfixOperation
                                        { symbol = expressionInfixOperation.symbol
                                        , left = leftSubstituted.node
                                        , right = rightSubstituted.node
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            leftSubstituted.substitutions
                            rightSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTuple expressionTuple ->
            resultAndThen3
                (\part0Substituted part1Substituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionTuple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTuple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTriple expressionTriple ->
            resultAndThen4
                (\part0Substituted part1Substituted part2Substituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionTriple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part2
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen4
                (\conditionSubstituted onTrueSubstituted onFalseSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionTuple
                                        { part0 = conditionSubstituted.node
                                        , part1 = onTrueSubstituted.node
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            conditionSubstituted.substitutions
                            onTrueSubstituted.substitutions
                            onFalseSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionList expressionListElements ->
            resultAndThen2
                (\elementsSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionList
                                        (elementsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionListElements
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\elementNode soFar ->
                            Result.andThen
                                (\elementSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions =
                                                fullSubstitutions
                                            , nodesReverse =
                                                elementSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            elementSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionCall expressionCall ->
            resultAndThen4
                (\calledSubstituted argument0Substituted argument1UpSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionCall
                                        { called = calledSubstituted.node
                                        , argument0 = argument0Substituted.node
                                        , argument1Up =
                                            argument1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            calledSubstituted.substitutions
                            argument0Substituted.substitutions
                            argument1UpSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionCall.called
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecord expressionRecordFields ->
            resultAndThen2
                (\fieldsSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionRecord
                                        (fieldsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            fieldsSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (expressionRecordFields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            resultAndThen3
                (\field0Substituted field1UpSubstituted fullTypeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionRecordUpdate
                                        { recordVariable =
                                            { value = expressionRecordUpdate.recordVariable.value
                                            , range = expressionRecordUpdate.recordVariable.range
                                            , type_ = fullTypeSubstituted.type_
                                            }
                                        , field0 = field0Substituted.node
                                        , field1Up =
                                            field1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = fullTypeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            field0Substituted.substitutions
                            field1UpSubstituted.substitutions
                            fullTypeSubstituted.substitutions
                        )
                )
                (Result.map
                    (\fieldValueSubstituted ->
                        { substitutions = fieldValueSubstituted.substitutions
                        , node =
                            { range = expressionRecordUpdate.field0.range
                            , name = expressionRecordUpdate.field0.name
                            , nameRange = expressionRecordUpdate.field0.nameRange
                            , value = fieldValueSubstituted.node
                            }
                        }
                    )
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionLambda expressionLambda ->
            resultAndThen4
                (\parameter0Substituted parameter1UpSubstituted resultSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionLambda
                                        { parameter0 = parameter0Substituted.node
                                        , parameter1Up =
                                            parameter1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            parameter0Substituted.substitutions
                            parameter1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionLambda.parameter0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLambda.parameter1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLambda.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionCaseOf expressionCaseOf ->
            resultAndThen4
                (\matchedSubstituted case0Substituted case1UpSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionCaseOf
                                        { case0 = case0Substituted.node
                                        , case1Up =
                                            case1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , matchedExpression = matchedSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            matchedSubstituted.substitutions
                            case0Substituted.substitutions
                            case1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (resultAndThen2
                    (\patternSubstituted resultSubstituted ->
                        Result.map
                            (\fullSubstitutions ->
                                { substitutions = fullSubstitutions
                                , node =
                                    { pattern = patternSubstituted.node
                                    , result = resultSubstituted.node
                                    }
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                patternSubstituted.substitutions
                                resultSubstituted.substitutions
                            )
                    )
                    (expressionCaseOf.case0.pattern
                        |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                    (expressionCaseOf.case0.result
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionCaseOf.case1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\case_ soFar ->
                            resultAndThen2
                                (\patternSubstituted resultSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { pattern = patternSubstituted.node
                                                , result = resultSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            patternSubstituted.substitutions
                                            resultSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (case_.pattern
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                                (case_.result
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expression.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionLetIn expressionLetIn ->
            resultAndThen3
                (\declaration0Substituted declaration1UpSubstituted resultSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expression.range
                                , value =
                                    ExpressionLetIn
                                        { declaration0 =
                                            declaration0Substituted.node
                                        , declaration1Up =
                                            declaration1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        }
                                , type_ = resultSubstituted.node.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            declaration0Substituted.substitutions
                            declaration1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                        )
                )
                (expressionLetIn.declaration0
                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLetIn.declaration1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\letDeclarationNode soFar ->
                            Result.andThen
                                (\declarationSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                declarationSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            declarationSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (letDeclarationNode
                                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


letDeclarationSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : LetDeclaration (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , substitutions : VariableSubstitutions
            }
letDeclarationSubstituteVariableByNotVariable declarationTypes replacement letDeclarationAndRange =
    case letDeclarationAndRange.declaration of
        LetDestructuring letDestructuring ->
            resultAndThen2
                (\patternSubstituted expressionSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetDestructuring
                                        { pattern = patternSubstituted.node
                                        , expression = expressionSubstituted.node
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            patternSubstituted.substitutions
                            expressionSubstituted.substitutions
                        )
                )
                (letDestructuring.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letDestructuring.expression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            resultAndThen3
                (\argumentsSubstituted resultSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetValueOrFunctionDeclaration
                                        { parameters =
                                            argumentsSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        , type_ = typeSubstituted.type_
                                        , signature = letValueOrFunction.signature
                                        , nameRange = letValueOrFunction.nameRange
                                        , name = letValueOrFunction.name
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            argumentsSubstituted.substitutions
                            resultSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (letValueOrFunction.parameters
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letValueOrFunction.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


expressionTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Expression (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Expression (Type changedTypeVariable)) (Type changedTypeVariable)
expressionTypedNodeMapTypeVariables typeVariableChange expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


expressionTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Expression type_) type_
    -> TypedNode (Expression changedType) changedType
expressionTypedNodeMapTypes typeVariableChange expressionTypedNode =
    { range = expressionTypedNode.range
    , value =
        expressionTypedNode.value
            |> expressionMapTypes typeVariableChange
    , type_ =
        expressionTypedNode.type_
            |> typeVariableChange
    }


expressionMapTypes :
    (type_ -> changedType)
    -> Expression type_
    -> Expression changedType
expressionMapTypes typeChange expression =
    -- IGNORE TCO
    case expression of
        ExpressionUnit ->
            ExpressionUnit

        ExpressionFloat floatValue ->
            ExpressionFloat floatValue

        ExpressionChar charValue ->
            ExpressionChar charValue

        ExpressionString stringValue ->
            ExpressionString stringValue

        ExpressionInteger expressionNumber ->
            ExpressionInteger expressionNumber

        ExpressionReference reference ->
            ExpressionReference reference

        ExpressionOperatorFunction expressionOperatorFunction ->
            ExpressionOperatorFunction expressionOperatorFunction

        ExpressionRecordAccessFunction fieldName ->
            ExpressionRecordAccessFunction fieldName

        ExpressionNegation inNegation ->
            ExpressionNegation
                (inNegation
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionParenthesized inParens ->
            ExpressionParenthesized
                (inParens
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionRecordAccess expressionRecordAccess ->
            ExpressionRecordAccess
                { record =
                    expressionRecordAccess.record
                        |> expressionTypedNodeMapTypes typeChange
                , fieldName = expressionRecordAccess.fieldName
                , fieldNameRange = expressionRecordAccess.fieldNameRange
                }

        ExpressionInfixOperation expressionInfixOperation ->
            ExpressionInfixOperation
                { symbol = expressionInfixOperation.symbol
                , left =
                    expressionInfixOperation.left
                        |> expressionTypedNodeMapTypes typeChange
                , right =
                    expressionInfixOperation.right
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTuple expressionTuple ->
            ExpressionTuple
                { part0 =
                    expressionTuple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTuple.part1
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTriple expressionTriple ->
            ExpressionTriple
                { part0 =
                    expressionTriple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTriple.part1
                        |> expressionTypedNodeMapTypes typeChange
                , part2 =
                    expressionTriple.part2
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionIfThenElse expressionIfThenElse ->
            ExpressionIfThenElse
                { condition =
                    expressionIfThenElse.condition
                        |> expressionTypedNodeMapTypes typeChange
                , onTrue =
                    expressionIfThenElse.onTrue
                        |> expressionTypedNodeMapTypes typeChange
                , onFalse =
                    expressionIfThenElse.onFalse
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionList expressionListElements ->
            ExpressionList
                (expressionListElements
                    |> List.map
                        (\element ->
                            element
                                |> expressionTypedNodeMapTypes
                                    typeChange
                        )
                )

        ExpressionCall expressionCall ->
            ExpressionCall
                { called =
                    expressionCall.called
                        |> expressionTypedNodeMapTypes typeChange
                , argument0 =
                    expressionCall.argument0
                        |> expressionTypedNodeMapTypes typeChange
                , argument1Up =
                    expressionCall.argument1Up
                        |> List.map
                            (\argument ->
                                argument
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            )
                }

        ExpressionRecord expressionRecordFields ->
            ExpressionRecord
                (expressionRecordFields
                    |> List.map
                        (\field ->
                            { range = field.range
                            , name = field.name
                            , nameRange = field.nameRange
                            , value =
                                field.value
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            }
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            ExpressionRecordUpdate
                { recordVariable =
                    { range = expressionRecordUpdate.recordVariable.range
                    , value = expressionRecordUpdate.recordVariable.value
                    , type_ =
                        expressionRecordUpdate.recordVariable.type_
                            |> typeChange
                    }
                , field0 =
                    { range = expressionRecordUpdate.field0.range
                    , name = expressionRecordUpdate.field0.name
                    , nameRange = expressionRecordUpdate.field0.nameRange
                    , value =
                        expressionRecordUpdate.field0.value
                            |> expressionTypedNodeMapTypes
                                typeChange
                    }
                , field1Up =
                    expressionRecordUpdate.field1Up
                        |> List.map
                            (\field ->
                                { range = field.range
                                , name = field.name
                                , nameRange = field.nameRange
                                , value =
                                    field.value
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                }
                            )
                }

        ExpressionLambda expressionLambda ->
            ExpressionLambda
                { parameter0 =
                    expressionLambda.parameter0
                        |> patternTypedNodeMapTypes typeChange
                , parameter1Up =
                    expressionLambda.parameter1Up
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    expressionLambda.result
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionCaseOf expressionCaseOf ->
            ExpressionCaseOf
                { matchedExpression =
                    expressionCaseOf.matchedExpression
                        |> expressionTypedNodeMapTypes typeChange
                , case0 =
                    { pattern =
                        expressionCaseOf.case0.pattern
                            |> patternTypedNodeMapTypes typeChange
                    , result =
                        expressionCaseOf.case0.result
                            |> expressionTypedNodeMapTypes typeChange
                    }
                , case1Up =
                    expressionCaseOf.case1Up
                        |> List.map
                            (\case_ ->
                                { pattern =
                                    case_.pattern
                                        |> patternTypedNodeMapTypes typeChange
                                , result =
                                    case_.result
                                        |> expressionTypedNodeMapTypes typeChange
                                }
                            )
                }

        ExpressionLetIn expressionLetIn ->
            ExpressionLetIn
                { declaration0 =
                    { range = expressionLetIn.declaration0.range
                    , declaration =
                        expressionLetIn.declaration0.declaration
                            |> letDeclarationMapTypes typeChange
                    }
                , declaration1Up =
                    expressionLetIn.declaration1Up
                        |> List.map
                            (\letDeclarationAndRange ->
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    letDeclarationAndRange.declaration
                                        |> letDeclarationMapTypes typeChange
                                }
                            )
                , result =
                    expressionLetIn.result
                        |> expressionTypedNodeMapTypes typeChange
                }


letDeclarationMapTypes :
    (type_ -> changedType)
    -> LetDeclaration type_
    -> LetDeclaration changedType
letDeclarationMapTypes typeChange expressionLetDeclaration =
    case expressionLetDeclaration of
        LetDestructuring letDestructuring ->
            LetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> patternTypedNodeMapTypes typeChange
                , expression =
                    letDestructuring.expression
                        |> expressionTypedNodeMapTypes typeChange
                }

        LetValueOrFunctionDeclaration letValueOrFunction ->
            LetValueOrFunctionDeclaration
                { signature =
                    letValueOrFunction.signature
                        |> Maybe.map
                            (\signature ->
                                { nameRange = signature.nameRange
                                , range = signature.range
                                , annotationType = signature.annotationType
                                , annotationTypeRange = signature.annotationTypeRange
                                }
                            )
                , nameRange = letValueOrFunction.nameRange
                , name = letValueOrFunction.name
                , parameters =
                    letValueOrFunction.parameters
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    letValueOrFunction.result
                        |> expressionTypedNodeMapTypes typeChange
                , type_ =
                    letValueOrFunction.type_
                        |> typeChange
                }


patternTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
patternTypedNodeSubstituteVariableByNotVariable declarationTypes replacement patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternInt _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternIgnored ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternVariable _ ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = patternTypedNode.value
                        , type_ = substituted.type_
                        }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternParenthesized inParensSubstituted.node
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (inParens
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternAs patternAs ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value =
                            PatternAs
                                { pattern = inParensSubstituted.node
                                , variable =
                                    { range = patternAs.variable.range
                                    , value = patternAs.variable.value
                                    , type_ = inParensSubstituted.node.type_
                                    }
                                }
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (patternAs.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternListCons patternListCons ->
            resultAndThen3
                (\headSubstituted tailSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListCons
                                        { head = headSubstituted.node
                                        , tail = tailSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            headSubstituted.substitutions
                            tailSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternListCons.head
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListCons.tail
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTuple patternTuple ->
            resultAndThen3
                (\part0Substituted part1Substituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternTuple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTuple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTriple patternTriple ->
            resultAndThen4
                (\part0Substituted part1Substituted part2Substituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTriple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        , part2 = part2Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternTriple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part2
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternRecord patternRecordFields ->
            resultAndThen2
                (\fieldsSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternRecord
                                        (fieldsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            fieldsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternRecordFields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldTypeSubstituted ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { substitutions = substitutionsWithField
                                            , nodesReverse =
                                                { value = fieldNode.value
                                                , range = fieldNode.range
                                                , type_ = fieldTypeSubstituted.type_
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldTypeSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.type_
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternListExact patternListElement ->
            resultAndThen2
                (\elementsSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListExact
                                        (elementsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternListElement
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\elementNode soFar ->
                            Result.andThen
                                (\fieldSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodesReverse =
                                                fieldSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternVariant patternVariant ->
            resultAndThen2
                (\elementsSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternVariant
                                        { qualification = patternVariant.qualification
                                        , name = patternVariant.name
                                        , moduleOrigin = patternVariant.moduleOrigin
                                        , values =
                                            elementsSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternVariant.values
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


patternTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Pattern (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Pattern (Type changedTypeVariable)) (Type changedTypeVariable)
patternTypedNodeMapTypeVariables typeVariableChange patternTypedNode =
    patternTypedNode
        |> patternTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


patternTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Pattern type_) type_
    -> TypedNode (Pattern changedType) changedType
patternTypedNodeMapTypes typeVariableChange patternTypedNode =
    { range = patternTypedNode.range
    , value =
        patternTypedNode.value
            |> patternMapTypes typeVariableChange
    , type_ =
        patternTypedNode.type_
            |> typeVariableChange
    }


patternMapTypes :
    (type_ -> changedType)
    -> Pattern type_
    -> Pattern changedType
patternMapTypes typeChange pattern =
    -- IGNORE TCO
    case pattern of
        PatternUnit ->
            PatternUnit

        PatternChar charValue ->
            PatternChar charValue

        PatternString stringValue ->
            PatternString stringValue

        PatternInt patternInt ->
            PatternInt patternInt

        PatternIgnored ->
            PatternIgnored

        PatternVariable variable ->
            PatternVariable variable

        PatternParenthesized inParens ->
            PatternParenthesized
                (inParens
                    |> patternTypedNodeMapTypes typeChange
                )

        PatternAs patternAs ->
            let
                patternWithTypeWithVariablesChanged : TypedNode (Pattern changedType) changedType
                patternWithTypeWithVariablesChanged =
                    patternAs.pattern
                        |> patternTypedNodeMapTypes typeChange
            in
            PatternAs
                { pattern = patternWithTypeWithVariablesChanged
                , variable =
                    { range = patternAs.variable.range
                    , value = patternAs.variable.value
                    , type_ = patternWithTypeWithVariablesChanged.type_
                    }
                }

        PatternListCons patternListCons ->
            PatternListCons
                { head =
                    patternListCons.head
                        |> patternTypedNodeMapTypes typeChange
                , tail =
                    patternListCons.tail
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTuple patternTuple ->
            PatternTuple
                { part0 =
                    patternTuple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTuple.part1
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTriple patternTriple ->
            PatternTriple
                { part0 =
                    patternTriple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTriple.part1
                        |> patternTypedNodeMapTypes typeChange
                , part2 =
                    patternTriple.part2
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternRecord patternRecordFields ->
            PatternRecord
                (patternRecordFields
                    |> List.map
                        (\field ->
                            { value = field.value
                            , range = field.range
                            , type_ =
                                field.type_ |> typeChange
                            }
                        )
                )

        PatternListExact patternListElement ->
            PatternListExact
                (patternListElement
                    |> List.map
                        (\element ->
                            element
                                |> patternTypedNodeMapTypes
                                    typeChange
                        )
                )

        PatternVariant patternVariant ->
            PatternVariant
                { qualification = patternVariant.qualification
                , name = patternVariant.name
                , moduleOrigin = patternVariant.moduleOrigin
                , values =
                    patternVariant.values
                        |> List.map
                            (\argument ->
                                argument
                                    |> patternTypedNodeMapTypes
                                        typeChange
                            )
                }


equivalentVariablesCreateCondensedVariable : FastSet.Set TypeVariableFromContext -> Result String TypeVariableFromContext
equivalentVariablesCreateCondensedVariable set =
    case set |> FastSet.toList of
        [] ->
            Err "implementation bug: equivalent variables set is empty"

        [ onlyVariable ] ->
            Ok onlyVariable

        variable0 :: variable1 :: variable2Up ->
            Result.map
                (\unifiedConstraint ->
                    ( -- creating a new variable safely
                      (variable0 :: variable1 :: variable2Up)
                        |> List.map
                            (\( context, name ) ->
                                name :: context
                            )
                        |> List.sort
                        |> List.intersperse [ "_and" ]
                        |> List.concat
                    , variable0
                        |> typeVariableFromContextName
                        |> typeVariableNameReplaceMaybeConstraint unifiedConstraint
                    )
                )
                ((variable0 :: variable1 :: variable2Up)
                    |> listFoldlWhileOkFrom Nothing
                        (\variable soFar ->
                            maybeTypeVariableConstraintMerge
                                (variable
                                    |> typeVariableFromContextName
                                    |> typeVariableConstraint
                                )
                                soFar
                        )
                )


typeVariableConstraintToString : TypeVariableConstraint -> String
typeVariableConstraintToString constraint =
    case constraint of
        TypeVariableConstraintNumber ->
            "number"

        TypeVariableConstraintAppendable ->
            "appendable"

        TypeVariableConstraintComparable ->
            "comparable"

        TypeVariableConstraintCompappend ->
            "compappend"


typeVariableNameReplaceMaybeConstraint : Maybe TypeVariableConstraint -> String -> String
typeVariableNameReplaceMaybeConstraint maybeConstraint typeVariableNameWithPotentialConstraint =
    let
        typeVariableNameStripConstraint : String
        typeVariableNameStripConstraint =
            case typeVariableNameWithPotentialConstraint |> typeVariableConstraint of
                Nothing ->
                    typeVariableNameWithPotentialConstraint

                Just constraint ->
                    String.dropLeft
                        (constraint |> typeVariableConstraintToString |> String.length)
                        typeVariableNameWithPotentialConstraint
                        |> stringFirstCharToLower
    in
    case maybeConstraint of
        Nothing ->
            typeVariableNameStripConstraint

        Just constraint ->
            (constraint |> typeVariableConstraintToString)
                ++ (typeVariableNameStripConstraint |> stringFirstCharToUpper)


fastDictFoldlWhileOkFrom : ok -> (key -> value -> ok -> Result err ok) -> FastDict.Dict key value -> Result err ok
fastDictFoldlWhileOkFrom initialFolded reduceToResult fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value soFarOrError ->
                case soFarOrError of
                    Err error ->
                        Err error |> FastDict.Stop

                    Ok soFar ->
                        case reduceToResult key value soFar of
                            Err error ->
                                Err error |> FastDict.Stop

                            Ok foldedWithEntry ->
                                Ok foldedWithEntry |> FastDict.Continue
            )
            (Ok initialFolded)


fastDictMapAndSmallestJust : (key -> value -> Maybe ok) -> FastDict.Dict key value -> Maybe ok
fastDictMapAndSmallestJust keyValueToMaybe fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value _ ->
                case keyValueToMaybe key value of
                    Just foldedWithEntry ->
                        Just foldedWithEntry |> FastDict.Stop

                    Nothing ->
                        Nothing |> FastDict.Continue
            )
            Nothing


parameterPatternsTypeInfer :
    { path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , nodesReverse :
                List
                    (TypedNode
                        (Pattern (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                    )
            }
parameterPatternsTypeInfer context parameterPatterns =
    parameterPatterns
        |> listFoldlWhileOkFrom
            { substitutions = variableSubstitutionsNone
            , introducedExpressionVariables = FastDict.empty
            , nodesReverse = []
            , index = 0
            }
            (\pattern soFar ->
                Result.andThen
                    (\patternInferred ->
                        Result.map
                            (\substitutionsWithPattern ->
                                { index = soFar.index + 1
                                , substitutions = substitutionsWithPattern
                                , nodesReverse =
                                    patternInferred.node
                                        :: soFar.nodesReverse
                                , introducedExpressionVariables =
                                    FastDict.union
                                        (patternInferred.introducedExpressionVariables
                                            |> FastDict.map
                                                (\_ introduced ->
                                                    introduced |> TypeVariable
                                                )
                                        )
                                        soFar.introducedExpressionVariables
                                }
                            )
                            (variableSubstitutionsMerge context.declarationTypes
                                soFar.substitutions
                                patternInferred.substitutions
                            )
                    )
                    (pattern
                        |> patternTypeInfer
                            (context
                                |> patternContextToInPath
                                    ("parameter" ++ (soFar.index |> String.fromInt))
                            )
                    )
            )
        |> Result.map
            (\folded ->
                { substitutions = folded.substitutions
                , introducedExpressionVariables =
                    folded.introducedExpressionVariables
                , nodesReverse = folded.nodesReverse
                }
            )


{-| Extract all known types
from module [metadata](https://dark.elm.dmy.fr/packages/elm/project-metadata-utils/latest/),
usually from parsing the `docs.json` of a dependency.

For elm-syntax modules, use [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)

-}
moduleInterfaceToTypes :
    Elm.Docs.Module
    -> { errors : List String, types : ModuleTypes }
moduleInterfaceToTypes moduleInterface =
    let
        typeAliases :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { type_ : Type String, parameters : List String }
            }
        typeAliases =
            moduleInterface.aliases
                |> List.foldl
                    (\typeAliasDeclarationInterface soFar ->
                        case
                            typeAliasDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            typeAliasDeclarationInterface.name
                                            { type_ = type_
                                            , parameters = typeAliasDeclarationInterface.args
                                            }
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }

        choiceTypes :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (List (Type String))
                    }
            }
        choiceTypes =
            moduleInterface.unions
                |> List.foldl
                    (\declarationChoiceType soFar ->
                        case
                            declarationChoiceType.tags
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\( variantName, variantValueInterfaces ) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        variantName
                                                        variantValues
                                            )
                                            (variantValueInterfaces
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue |> interfaceToType
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            declarationChoiceType.name
                                            { parameters =
                                                declarationChoiceType.args
                                            , variants = variants
                                            }
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }

        signatures : { errors : List String, types : FastDict.Dict String (Type String) }
        signatures =
            moduleInterface.values
                |> List.foldl
                    (\valueOrFunctionDeclarationInterface soFar ->
                        case
                            valueOrFunctionDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            valueOrFunctionDeclarationInterface.name
                                            type_
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }
    in
    { errors =
        typeAliases.errors
            ++ choiceTypes.errors
            ++ signatures.errors
    , types =
        { typeAliases = typeAliases.types
        , choiceTypes = choiceTypes.types
        , signatures = signatures.types
        }
    }


interfaceToType : Elm.Type.Type -> Result String (Type String)
interfaceToType typeInterface =
    -- IGNORE TCO
    case typeInterface of
        Elm.Type.Var name ->
            Ok (TypeVariable name)

        Elm.Type.Lambda functionInput functionOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (functionInput |> interfaceToType)
                (functionOutput |> interfaceToType)

        Elm.Type.Tuple parts ->
            case parts of
                [] ->
                    Ok (TypeNotVariable TypeUnit)

                [ inParens ] ->
                    inParens |> interfaceToType

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (tuplePart1 |> interfaceToType)
                        (tuplePart0 |> interfaceToType)

                [ triplePart0, triplePart1, triplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (triplePart0 |> interfaceToType)
                        (triplePart1 |> interfaceToType)
                        (triplePart2 |> interfaceToType)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Type.Type reference argumentInterfaces ->
            case reference |> String.split "." |> List.reverse of
                referenceName :: referenceModulePartLast :: referenceModulePartBeforeLastDown ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin =
                                        (referenceModulePartLast :: referenceModulePartBeforeLastDown)
                                            |> List.reverse
                                    , name = referenceName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentInterfaces |> listMapAndCombineOk interfaceToType)

                [ _ ] ->
                    Err "invalid reference"

                [] ->
                    Err "invalid reference"

        Elm.Type.Record fieldInterfaces Nothing ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )

        Elm.Type.Record fieldInterfaces (Just extendedRecordVariable) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { fields = fields
                            , recordVariable = extendedRecordVariable
                            }
                        )
                )
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )


{-| Extract all known types
from declarations within a module.
No effort is being made to infer types at this stage.

For dependency modules, use [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

-}
moduleDeclarationsToTypes :
    ModuleOriginLookup
    -> List Elm.Syntax.Declaration.Declaration
    -> { types : ModuleTypes, errors : List String }
moduleDeclarationsToTypes moduleOriginLookup declarations =
    declarations
        |> List.foldl
            (\declaration soFar ->
                case declaration of
                    Elm.Syntax.Declaration.InfixDeclaration _ ->
                        soFar

                    Elm.Syntax.Declaration.Destructuring _ _ ->
                        { errors =
                            "destructuring at the module level is invalid syntax"
                                :: soFar.errors
                        , types = soFar.types
                        }

                    Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                        case declarationValueOrFunction.signature of
                            Nothing ->
                                soFar

                            Just (Elm.Syntax.Node.Node _ declarationValueOrFunctionSignature) ->
                                case
                                    declarationValueOrFunctionSignature.typeAnnotation
                                        |> Elm.Syntax.Node.value
                                        |> syntaxToType moduleOriginLookup
                                of
                                    Err error ->
                                        { errors = error :: soFar.errors
                                        , types = soFar.types
                                        }

                                    Ok type_ ->
                                        { errors = soFar.errors
                                        , types =
                                            { signatures =
                                                soFar.types.signatures
                                                    |> FastDict.insert
                                                        (declarationValueOrFunctionSignature.name |> Elm.Syntax.Node.value)
                                                        type_
                                            , typeAliases = soFar.types.typeAliases
                                            , choiceTypes = soFar.types.choiceTypes
                                            }
                                        }

                    Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                        case
                            declarationTypeAlias.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases =
                                        soFar.types.typeAliases
                                            |> FastDict.insert
                                                (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationTypeAlias.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , type_ = type_
                                                }
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }

                    Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                        case
                            declarationChoiceType.constructors
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\(Elm.Syntax.Node.Node _ variant) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        (variant.name |> Elm.Syntax.Node.value)
                                                        variantValues
                                            )
                                            (variant.arguments
                                                |> listMapAndCombineOk
                                                    (\(Elm.Syntax.Node.Node _ variantValue) ->
                                                        variantValue |> syntaxToType moduleOriginLookup
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes =
                                        soFar.types.choiceTypes
                                            |> FastDict.insert
                                                (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationChoiceType.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , variants = variants
                                                }
                                    }
                                }

                    Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                        case
                            declarationPortSignature.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures =
                                        soFar.types.signatures
                                            |> FastDict.insert
                                                (declarationPortSignature.name |> Elm.Syntax.Node.value)
                                                type_
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }
            )
            { types =
                { signatures = FastDict.empty
                , typeAliases = FastDict.empty
                , choiceTypes = FastDict.empty
                }
            , errors = []
            }


typeVariablesFromContextToDisambiguationLookup :
    FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookup variables =
    disambiguateInto FastDict.empty variables


disambiguateInto :
    FastDict.Dict TypeVariableFromContext String
    -> FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
disambiguateInto soFar variables =
    case variables |> FastSet.popMin of
        Nothing ->
            soFar

        Just ( variable, remainingVariables ) ->
            let
                ( context, name ) =
                    variable

                alreadyExists : String -> Bool
                alreadyExists toDisambiguate =
                    soFar
                        |> fastDictAny
                            (\soFarVariableAsString ->
                                soFarVariableAsString == toDisambiguate
                            )

                variableAsDisambiguatedString : String
                variableAsDisambiguatedString =
                    case ( context, name ) |> variableFromContextFindUnambiguousWithLeastContext alreadyExists of
                        Just nameWithMinimalContextAsString ->
                            nameWithMinimalContextAsString

                        Nothing ->
                            variable
                                |> typeVariableFromContextToName
                                |> nameDisambiguateBy alreadyExists
            in
            disambiguateInto
                (soFar
                    |> FastDict.insert variable
                        variableAsDisambiguatedString
                )
                remainingVariables


variableFromContextFindUnambiguousWithLeastContext :
    (String -> Bool)
    -> TypeVariableFromContext
    -> Maybe String
variableFromContextFindUnambiguousWithLeastContext alreadyExists variable =
    -- IGNORE TCO
    -- elm's tail call elimination does not account for closure dependencies
    -- so nameIfAlreadyExists will refer to a mutated variableAsString
    -- https://github.com/elm/compiler/issues/2017
    -- https://ellie-app.com/t7MMYPSJsNGa1
    let
        variableAsString : String
        variableAsString =
            variable |> typeVariableFromContextToName
    in
    if alreadyExists variableAsString then
        Nothing

    else
        let
            ( context, name ) =
                variable
        in
        Just
            (case context of
                [] ->
                    name

                _ :: nextContext ->
                    case
                        ( nextContext, name )
                            |> variableFromContextFindUnambiguousWithLeastContext
                                alreadyExists
                    of
                        Just nameWithLeastContext ->
                            nameWithLeastContext

                        Nothing ->
                            variableAsString
            )


typeVariableFromContextToName : TypeVariableFromContext -> String
typeVariableFromContextToName ( context, name ) =
    (name
        |> String.replace "_" ""
    )
        ++ (context
                |> List.map
                    (\part ->
                        part
                            |> String.replace "_" ""
                            |> stringFirstCharToUpper
                    )
                |> String.concat
           )


nameDisambiguateBy : (String -> Bool) -> String -> String
nameDisambiguateBy alreadyExists currentName =
    if alreadyExists currentName then
        nameDisambiguateBy alreadyExists (currentName ++ "_")

    else
        currentName


fastDictAny : (value -> Bool) -> FastDict.Dict key_ value -> Bool
fastDictAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.value
                    || state.left ()
                    || state.right ()
            )


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


resultAndThen3 :
    (a -> b -> c -> Result error d)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
resultAndThen3 abToResult aResult bResult cResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            abToResult a b c


resultAndThen4 :
    (a -> b -> c -> d -> Result error e)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
    -> Result error e
resultAndThen4 abToResult aResult bResult cResult dResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            case dResult of
                                Err error ->
                                    Err error

                                Ok d ->
                                    abToResult a b c d


elmCoreTypesGeneratedFromDocsJson :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypesGeneratedFromDocsJson =
    FastDict.fromList
        [ ( [ "Array" ]
          , { signatures =
                FastDict.fromList
                    [ ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Array" ]
                                , name = "Array"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "initialize"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "push"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toIndexedList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Array"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Basics" ]
          , { signatures =
                FastDict.fromList
                    [ ( "abs"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "acos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "always"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "asin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "ceiling"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "clamp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "number"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "number"
                                                        , output =
                                                            TypeVariable
                                                                "number"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "compare"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Order"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "degrees"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "e"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "floor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "isInfinite"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isNaN"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "logBase"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "max"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "min"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "modBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "never"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Never"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "not"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pi"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "radians"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remainderBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "round"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sqrt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "tan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "truncate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "turns"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bool"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "True", [] ), ( "False", [] ) ]
                        }
                      )
                    , ( "Float"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Int"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Never"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Order"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "LT", [] ), ( "EQ", [] ), ( "GT", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Bitwise" ]
          , { signatures =
                FastDict.fromList
                    [ ( "and"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "complement"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "or"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftLeftBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightZfBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Char" ]
          , { signatures =
                FastDict.fromList
                    [ ( "fromCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlpha"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlphaNum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isHexDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isOctDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Char"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Debug" ]
          , { signatures =
                FastDict.fromList
                    [ ( "log"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toString"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "todo"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Dict" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Dict" ]
                                , name = "Dict"
                                , arguments =
                                    [ TypeVariable "k"
                                    , TypeVariable "v"
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "v"
                                                        , part1 =
                                                            TypeVariable
                                                                "comparable"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keys"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "merge"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "result"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "comparable"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "a"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "comparable"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Dict"
                                                                                    ]
                                                                                , name =
                                                                                    "Dict"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "comparable"
                                                                                    , TypeVariable
                                                                                        "a"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Dict"
                                                                                                ]
                                                                                            , name =
                                                                                                "Dict"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "comparable"
                                                                                                , TypeVariable
                                                                                                    "b"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "v"
                                                        , part1 =
                                                            TypeVariable
                                                                "k"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "update"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "values"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Dict"
                      , { parameters = [ "k", "v" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "List" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concatMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "drop"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filterMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "head"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersperse"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maximum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "minimum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "product"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "range"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sort"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Order"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "tail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "take"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unzip"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "b"
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.singleton
                    "List"
                    { parameters = [ "a" ], variants = FastDict.empty }
            }
          )
        , ( [ "Maybe" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Maybe"
                      , { parameters = [ "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Just"
                                  , [ TypeVariable "a" ]
                                  )
                                , ( "Nothing", [] )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform" ]
          , { signatures =
                FastDict.fromList
                    [ ( "sendToApp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sendToSelf"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "worker"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecord
                                            (FastDict.fromList
                                                [ ( "init"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "flags"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeTuple
                                                                        { part0 =
                                                                            TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        [ "Platform"
                                                                                        , "Cmd"
                                                                                        ]
                                                                                    , name =
                                                                                        "Cmd"
                                                                                    , arguments =
                                                                                        [ TypeVariable
                                                                                            "msg"
                                                                                        ]
                                                                                    }
                                                                                )
                                                                        , part1 =
                                                                            TypeVariable
                                                                                "model"
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "subscriptions"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "model"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeConstruct
                                                                        { moduleOrigin =
                                                                            [ "Platform"
                                                                            , "Sub"
                                                                            ]
                                                                        , name =
                                                                            "Sub"
                                                                        , arguments =
                                                                            [ TypeVariable
                                                                                "msg"
                                                                            ]
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "update"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "msg"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            TypeVariable
                                                                                "model"
                                                                        , output =
                                                                            TypeNotVariable
                                                                                (TypeTuple
                                                                                    { part0 =
                                                                                        TypeNotVariable
                                                                                            (TypeConstruct
                                                                                                { moduleOrigin =
                                                                                                    [ "Platform"
                                                                                                    , "Cmd"
                                                                                                    ]
                                                                                                , name =
                                                                                                    "Cmd"
                                                                                                , arguments =
                                                                                                    [ TypeVariable
                                                                                                        "msg"
                                                                                                    ]
                                                                                                }
                                                                                            )
                                                                                    , part1 =
                                                                                        TypeVariable
                                                                                            "model"
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Program"
                                            , arguments =
                                                [ TypeVariable
                                                    "flags"
                                                , TypeVariable
                                                    "model"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "ProcessId"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Program"
                      , { parameters = [ "flags", "model", "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Router"
                      , { parameters = [ "appMsg", "selfMsg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Task"
                      , { parameters = [ "err", "ok" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Cmd" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Cmd" ]
                                            , name = "Cmd"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Cmd" ]
                                , name = "Cmd"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Cmd"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Sub" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Sub" ]
                                            , name = "Sub"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Sub" ]
                                , name = "Sub"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Sub"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Process" ]
          , { signatures =
                FastDict.fromList
                    [ ( "kill"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Process" ]
                                            , name = "Id"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sleep"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "spawn"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "y"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Process" ]
                                                        , name = "Id"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Id"
                      , { parameters = []
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "ProcessId"
                                    , arguments = []
                                    }
                                )
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Result" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "value"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "value"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Result" ]
                                            , name = "Result"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Result"
                      , { parameters = [ "error", "value" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Ok"
                                  , [ TypeVariable "value" ]
                                  )
                                , ( "Err"
                                  , [ TypeVariable "error" ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Set" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Set" ]
                                , name = "Set"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable2"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable2"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Set"
                      , { parameters = [ "t" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "String" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "contains"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "endsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromChar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexes"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indices"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "join"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "left"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lines"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pad"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replace"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "right"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "startsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trim"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uncons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Char"
                                                                        ]
                                                                    , name =
                                                                        "Char"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "words"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "String"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Task" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attempt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "onError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "perform"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Never"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Task"
                      , { parameters = [ "x", "a" ]
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "Task"
                                    , arguments =
                                        [ TypeVariable "x"
                                        , TypeVariable "a"
                                        ]
                                    }
                                )
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Tuple" ]
          , { signatures =
                FastDict.fromList
                    [ ( "first"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "b"
                                            , part1 =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "mapBoth"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "b"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "a"
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "y"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "x"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapFirst"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "b"
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "b"
                                                        , part1 =
                                                            TypeVariable
                                                                "x"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapSecond"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "b"
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "y"
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pair"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "b"
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "second"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "b"
                                            , part1 =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                , output = TypeVariable "b"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        ]
