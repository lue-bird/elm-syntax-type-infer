module ElmSyntaxTypeInfer exposing
    ( valueAndFunctionDeclarations
    , ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
    , ModuleOriginLookup, importsToModuleOriginLookup
    , TypedNode, Expression(..), LetDeclaration(..), Pattern(..), Base10Or16(..)
    , Type(..), TypeNotVariable(..)
    )

{-| Add type information to the nodes
of an [elm-syntax](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/) tree.

@docs valueAndFunctionDeclarations

## context

@docs ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
@docs ModuleOriginLookup, importsToModuleOriginLookup


## syntax

@docs TypedNode, Expression, LetDeclaration, Pattern, Base10Or16
@docs Type, TypeNotVariable

If you are interested in exposing helpers like `expressionMapType`,
[open an issue](https://github.com/lue-bird/elm-syntax-type-infer/issues/new)

-}

import DictByTypeVariableFromContext exposing (DictByTypeVariableFromContext)
import Elm.Docs
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.Import
import Elm.Syntax.ModuleName
import Elm.Syntax.Node
import Elm.Syntax.Pattern
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import Elm.Type
import FastDict
import Set exposing (Set)
import TypeVariableFromContext


{-| Known types of members in a module.
Create with [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)
-}
type alias ModuleTypes =
    { signatures :
        -- value, function, port
        FastDict.Dict String Type
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : Type
            , recordFieldOrder : Maybe (List String)
            }
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List Type)
            }
    }


{-| [`ModuleTypes`](#ModuleTypes) exposed in `elm/core`.

Please _always_ start with [`elmCoreTypes`](#elmCoreTypes)
and add further module info with [`FastDict.union`](https://dark.elm.dmy.fr/packages/miniBill/elm-fast-dict/latest/FastDict#union)
using [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

And if for some reason you already know used dependencies at compile time,
you can re-use the [code generator used for these elm/core types](https://github.com/lue-bird/elm-syntax-type-infer/tree/main/codegen)

-}
elmCoreTypes :
    FastDict.Dict
        String
        ModuleTypes
elmCoreTypes =
    elmCoreTypesGeneratedFromDocsJson


{-| When syntax _introduces_ type variables from another "context" (another (let) declaration, another branch, another element, ...)
we need to differentiate these from variables in the current "context"

For example,

    ( 0, 1 )
    -- ( number, number )
    ( identity, List.map identity )
    -- ( a -> a, List a -> List a )

would be incorrect inferences because
the `number` in `0` and `1` or `a` in `identity` and `List.map` are not related
and can be different types.
So in practice these are

    ( 0, 1 )
    -- ( ( { ... 3 }, "number" ), ( { ... 6 }, "number" ) )

    ( identity, List.map identity )
    -- ( ( { ... 3 }, "a" ) -> ( { ... 3 }, "a" )
    -- , List ( { ... 15 }, "a" ) -> List ( { ... 15 }, "a" )
    -- )

Here { ... 3 } refers to the use range with n as the start column.


This system of tracking origin ranges by itself is arguably
worse than a simple ast path or similar
but it has the unique advantage that it allows us to quickly
find out which let value/function type variable
is "forall" (as in: should be instantiated on use) or not
by checking whether its range extends to outside the let declaration body.
There might be some other way to track this but I couldn't think of one.

-}
type alias TypeVariableFromContext =
    { useRange : Elm.Syntax.Range.Range
    , name : String
    }


type TypeVariableConstraint
    = TypeVariableConstraintNumber
    | TypeVariableConstraintAppendable
    | TypeVariableConstraintComparable
    | TypeVariableConstraintCompappend


typeVariableConstraint : String -> Maybe TypeVariableConstraint
typeVariableConstraint variableName =
    if variableName |> String.startsWith "number" then
        justTypeVariableConstraintNumber

    else
        -- small optimization because they are all equal in length
        case variableName |> String.slice 0 10 of
            "appendable" ->
                justTypeVariableConstraintAppendable

            "comparable" ->
                justTypeVariableConstraintComparable

            "compappend" ->
                justTypeVariableConstraintCompappend

            _ ->
                Nothing


justTypeVariableConstraintCompappend : Maybe TypeVariableConstraint
justTypeVariableConstraintCompappend =
    Just TypeVariableConstraintCompappend


justTypeVariableConstraintComparable : Maybe TypeVariableConstraint
justTypeVariableConstraintComparable =
    Just TypeVariableConstraintComparable


justTypeVariableConstraintAppendable : Maybe TypeVariableConstraint
justTypeVariableConstraintAppendable =
    Just TypeVariableConstraintAppendable


justTypeVariableConstraintNumber : Maybe TypeVariableConstraint
justTypeVariableConstraintNumber =
    Just TypeVariableConstraintNumber


maybeTypeVariableConstraintMerge : Maybe TypeVariableConstraint -> Maybe TypeVariableConstraint -> Result String (Maybe TypeVariableConstraint)
maybeTypeVariableConstraintMerge a b =
    case a of
        Nothing ->
            Ok b

        Just aConstraint ->
            case b of
                Nothing ->
                    Ok (Just aConstraint)

                Just bConstraint ->
                    Result.map Just
                        (typeVariableConstraintMerge aConstraint bConstraint)


typeVariableConstraintMerge : TypeVariableConstraint -> TypeVariableConstraint -> Result String TypeVariableConstraint
typeVariableConstraintMerge a b =
    case a of
        TypeVariableConstraintNumber ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintCompappend ->
                    Err "number and compappend variables cannot be unified"

        TypeVariableConstraintAppendable ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintAppendable

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintComparable ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintComparable

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintCompappend ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and compappend variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend


okTypeVariableConstraintCompappend : Result error_ TypeVariableConstraint
okTypeVariableConstraintCompappend =
    Ok TypeVariableConstraintCompappend


okTypeVariableConstraintComparable : Result error_ TypeVariableConstraint
okTypeVariableConstraintComparable =
    Ok TypeVariableConstraintComparable


okTypeVariableConstraintNumber : Result error_ TypeVariableConstraint
okTypeVariableConstraintNumber =
    Ok TypeVariableConstraintNumber


okTypeVariableConstraintAppendable : Result error_ TypeVariableConstraint
okTypeVariableConstraintAppendable =
    Ok TypeVariableConstraintAppendable


{-| Type information attached to expressions and patterns,
see [`TypedNode`](#TypedNode).

This is different from [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)
in that it doesn't contain
information unrelated to type inference like ranges, qualification levels or parens.

Importantly, it also contains the overarching ranges
of all places where the specific type variables are used.
This is useful to for example find out whether a variable in a let declaration type
is "forall" or inherited from the surrounding context
(if the use range is fully included in the let declaration range it's forall, otherwise inherited).

-}
type Type
    = TypeVariable
        { useRange : Elm.Syntax.Range.Range
        , name : String
        }
    | TypeNotVariable TypeNotVariable


{-| [`Type`](#Type) except the variable case
-}
type TypeNotVariable
    = TypeUnit
    | TypeConstruct
        { moduleOrigin : String
        , name : String
        , arguments : List Type
        }
    | TypeTuple
        { part0 : Type
        , part1 : Type
        }
    | TypeTriple
        { part0 : Type
        , part1 : Type
        , part2 : Type
        }
    | TypeRecord (FastDict.Dict String Type)
    | TypeRecordExtension
        { recordVariable :
            { useRange : Elm.Syntax.Range.Range
            , name : String
            }
        , fields : FastDict.Dict String Type
        }
    | TypeFunction
        { input : Type
        , output : Type
        }


typeMapVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> Type
    -> Type
typeMapVariables variableMap type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariable (variable |> variableMap)

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariable
                    |> typeNotVariableMapVariables variableMap
                )


typeNotVariableMapVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> TypeNotVariable
    -> TypeNotVariable
typeNotVariableMapVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            TypeUnit

        TypeFunction typeFunction ->
            TypeFunction
                { input = typeFunction.input |> typeMapVariables variableMap
                , output = typeFunction.output |> typeMapVariables variableMap
                }

        TypeTuple typeTuple ->
            TypeTuple
                { part0 = typeTuple.part0 |> typeMapVariables variableMap
                , part1 = typeTuple.part1 |> typeMapVariables variableMap
                }

        TypeTriple typeTriple ->
            TypeTriple
                { part0 = typeTriple.part0 |> typeMapVariables variableMap
                , part1 = typeTriple.part1 |> typeMapVariables variableMap
                , part2 = typeTriple.part2 |> typeMapVariables variableMap
                }

        TypeConstruct typeConstruct ->
            TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> typeMapVariables variableMap
                            )
                }

        TypeRecord typeRecordFields ->
            TypeRecord
                (typeRecordFields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> typeMapVariables variableMap
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable =
                    typeRecordExtension.recordVariable
                        |> variableMap
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
                }


type alias TypeVariableFromContextSet =
    DictByTypeVariableFromContext ()


typeMapVariablesAndCollectResultingVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> Type
    ->
        { type_ : Type
        , containedVariables : TypeVariableFromContextSet
        }
typeMapVariablesAndCollectResultingVariables variableMap type_ =
    case type_ of
        TypeVariable variable ->
            let
                variableMapped : TypeVariableFromContext
                variableMapped =
                    variable |> variableMap
            in
            { type_ = TypeVariable variableMapped
            , containedVariables = DictByTypeVariableFromContext.singleton variableMapped ()
            }

        TypeNotVariable typeNotVariable ->
            let
                typeNotVariableMapped :
                    { type_ : TypeNotVariable
                    , containedVariables : TypeVariableFromContextSet
                    }
                typeNotVariableMapped =
                    typeNotVariable
                        |> typeNotVariableMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ = TypeNotVariable typeNotVariableMapped.type_
            , containedVariables = typeNotVariableMapped.containedVariables
            }


typeUnitContainedVariablesEmpty :
    { type_ : TypeNotVariable
    , containedVariables : TypeVariableFromContextSet
    }
typeUnitContainedVariablesEmpty =
    { type_ = TypeUnit
    , containedVariables = DictByTypeVariableFromContext.empty
    }


typeNotVariableMapVariablesAndCollectResultingVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> TypeNotVariable
    ->
        { type_ : TypeNotVariable
        , containedVariables : TypeVariableFromContextSet
        }
typeNotVariableMapVariablesAndCollectResultingVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            typeUnitContainedVariablesEmpty

        TypeFunction typeFunction ->
            let
                inputMapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                inputMapped =
                    typeFunction.input |> typeMapVariablesAndCollectResultingVariables variableMap

                outputMapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                outputMapped =
                    typeFunction.output |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeFunction
                    { input = inputMapped.type_
                    , output = outputMapped.type_
                    }
            , containedVariables =
                DictByTypeVariableFromContext.setUnion
                    inputMapped.containedVariables
                    outputMapped.containedVariables
            }

        TypeTuple typeTuple ->
            let
                part0Mapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                part0Mapped =
                    typeTuple.part0 |> typeMapVariablesAndCollectResultingVariables variableMap

                part1Mapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                part1Mapped =
                    typeTuple.part1 |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeTuple
                    { part0 = part0Mapped.type_
                    , part1 = part1Mapped.type_
                    }
            , containedVariables =
                DictByTypeVariableFromContext.setUnion
                    part0Mapped.containedVariables
                    part1Mapped.containedVariables
            }

        TypeTriple typeTriple ->
            let
                part0Mapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                part0Mapped =
                    typeTriple.part0 |> typeMapVariablesAndCollectResultingVariables variableMap

                part1Mapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                part1Mapped =
                    typeTriple.part1 |> typeMapVariablesAndCollectResultingVariables variableMap

                part2Mapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                part2Mapped =
                    typeTriple.part2 |> typeMapVariablesAndCollectResultingVariables variableMap
            in
            { type_ =
                TypeTriple
                    { part0 = part0Mapped.type_
                    , part1 = part1Mapped.type_
                    , part2 = part2Mapped.type_
                    }
            , containedVariables =
                part0Mapped.containedVariables
                    |> DictByTypeVariableFromContext.setUnion part1Mapped.containedVariables
                    |> DictByTypeVariableFromContext.setUnion part2Mapped.containedVariables
            }

        TypeConstruct typeConstruct ->
            let
                argumentsMapped : { types : List Type, containedVariables : TypeVariableFromContextSet }
                argumentsMapped =
                    typeConstruct.arguments
                        |> List.foldr
                            (\argument soFar ->
                                let
                                    argumentMapped : { type_ : Type, containedVariables : TypeVariableFromContextSet }
                                    argumentMapped =
                                        argument |> typeMapVariablesAndCollectResultingVariables variableMap
                                in
                                { types = argumentMapped.type_ :: soFar.types
                                , containedVariables =
                                    DictByTypeVariableFromContext.setUnion
                                        soFar.containedVariables
                                        argumentMapped.containedVariables
                                }
                            )
                            typedListEmptyContainedVariablesEmpty
            in
            { type_ =
                TypeConstruct
                    { moduleOrigin = typeConstruct.moduleOrigin
                    , name = typeConstruct.name
                    , arguments = argumentsMapped.types
                    }
            , containedVariables = argumentsMapped.containedVariables
            }

        TypeRecord typeRecordFields ->
            let
                fieldsMapped : FastDict.Dict String Type
                fieldsMapped =
                    typeRecordFields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
            in
            { type_ = TypeRecord fieldsMapped
            , containedVariables =
                fieldsMapped
                    |> FastDict.foldl
                        (\_ value soFar ->
                            DictByTypeVariableFromContext.setUnion soFar
                                (value |> typeContainedVariables)
                        )
                        DictByTypeVariableFromContext.empty
            }

        TypeRecordExtension typeRecordExtension ->
            let
                recordVariableMapped : TypeVariableFromContext
                recordVariableMapped =
                    typeRecordExtension.recordVariable
                        |> variableMap

                fieldsMapped : FastDict.Dict String Type
                fieldsMapped =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
            in
            { type_ =
                TypeRecordExtension
                    { recordVariable = recordVariableMapped
                    , fields = fieldsMapped
                    }
            , containedVariables =
                fieldsMapped
                    |> FastDict.foldl
                        (\_ value soFar ->
                            DictByTypeVariableFromContext.setUnion soFar
                                (value |> typeContainedVariables)
                        )
                        (DictByTypeVariableFromContext.singleton recordVariableMapped ())
            }


typedListEmptyContainedVariablesEmpty :
    { types : List Type
    , containedVariables : TypeVariableFromContextSet
    }
typedListEmptyContainedVariablesEmpty =
    { types = []
    , containedVariables = DictByTypeVariableFromContext.empty
    }


typeContainedVariables :
    Type
    -> TypeVariableFromContextSet
typeContainedVariables type_ =
    case type_ of
        TypeVariable variable ->
            DictByTypeVariableFromContext.singleton variable ()

        TypeNotVariable typeNotVariable ->
            typeNotVariableContainedVariables typeNotVariable


typeNotVariableContainedVariables :
    TypeNotVariable
    -> TypeVariableFromContextSet
typeNotVariableContainedVariables typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            DictByTypeVariableFromContext.empty

        TypeFunction typeFunction ->
            DictByTypeVariableFromContext.setUnion
                (typeFunction.input |> typeContainedVariables)
                (typeFunction.output |> typeContainedVariables)

        TypeTuple typeTuple ->
            DictByTypeVariableFromContext.setUnion
                (typeTuple.part0 |> typeContainedVariables)
                (typeTuple.part1 |> typeContainedVariables)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeContainedVariables)
                |> DictByTypeVariableFromContext.setUnion
                    (typeTriple.part1 |> typeContainedVariables)
                |> DictByTypeVariableFromContext.setUnion
                    (typeTriple.part2 |> typeContainedVariables)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToTypeVariableFromContextSetsAndUnify typeContainedVariables

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        DictByTypeVariableFromContext.setUnion soFar
                            (value |> typeContainedVariables)
                    )
                    DictByTypeVariableFromContext.empty

        TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        DictByTypeVariableFromContext.setUnion soFar
                            (value |> typeContainedVariables)
                    )
                    (DictByTypeVariableFromContext.singleton typeRecordExtension.recordVariable ())


typeContainsVariable :
    TypeVariableFromContext
    -> Type
    -> Bool
typeContainsVariable variableToCheckFor type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariableFromContext.equals variableToCheckFor variable

        TypeNotVariable typeNotVariable ->
            typeNotVariableContainsVariable variableToCheckFor typeNotVariable


typeNotVariableContainsVariable :
    TypeVariableFromContext
    -> TypeNotVariable
    -> Bool
typeNotVariableContainsVariable variableToCheckFor typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            False

        TypeFunction typeFunction ->
            (typeFunction.input |> typeContainsVariable variableToCheckFor)
                || (typeFunction.output |> typeContainsVariable variableToCheckFor)

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeContainsVariable variableToCheckFor)
                || (typeTuple.part1 |> typeContainsVariable variableToCheckFor)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeContainsVariable variableToCheckFor)
                || (typeTriple.part1 |> typeContainsVariable variableToCheckFor)
                || (typeTriple.part2 |> typeContainsVariable variableToCheckFor)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any
                    (\argument ->
                        argument |> typeContainsVariable variableToCheckFor
                    )

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> fastDictAny
                    (\value ->
                        value |> typeContainsVariable variableToCheckFor
                    )

        TypeRecordExtension typeRecordExtension ->
            TypeVariableFromContext.equals
                typeRecordExtension.recordVariable
                variableToCheckFor
                || (typeRecordExtension.fields
                        |> fastDictAny
                            (\value ->
                                value |> typeContainsVariable variableToCheckFor
                            )
                   )


{-| How to map names and symbols used in a module to their origin module.
Create with [`importsToModuleOriginLookup`](#importsToModuleOriginLookup).

Contains variants, type alias names, choice type names, port names, value/function declaration names
and whether `(|.)` and or `(|=)` are imported from `Parser.Advanced`.

Also contains locally declared names when available.

Type- and expression/pattern-level members
are separated since you can for example have a local `List` variant
while also using an (implicitly) imported `List` type.

-}
type alias ModuleOriginLookup =
    { references :
        FastDict.Dict
            -- qualification
            String
            (FastDict.Dict
                -- name
                String
                String
            )
    , typeConstructs :
        FastDict.Dict
            -- qualification
            String
            (FastDict.Dict
                -- name
                String
                String
            )
    , keepOperatorIsExposedFromParserAdvanced : Bool
    , ignoreOperatorIsExposedFromParserAdvanced : Bool
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports, see [`ModuleOriginLookup`](#ModuleOriginLookup).

Requires all exposed [`ModuleTypes`](#ModuleTypes)
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleOriginLookup :
    FastDict.Dict String ModuleTypes
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleOriginLookup
importsToModuleOriginLookup modulesTypes imports =
    let
        importsNormal :
            List
                { moduleName : String
                , alias : Maybe String
                , typeExposes : List String
                , referenceExposes : List String
                }
        importsNormal =
            imports
                |> List.foldl
                    (\(Elm.Syntax.Node.Node _ syntaxImport) importNormalsSoFar ->
                        (syntaxImport |> importToNormal modulesTypes)
                            :: importNormalsSoFar
                    )
                    implicitImports
                |> importsCombine

        operatorIsExposedFromParserAdvanced : String -> Bool
        operatorIsExposedFromParserAdvanced operator =
            importsNormal
                |> List.any
                    (\syntaxImport ->
                        case syntaxImport.moduleName of
                            "Parser.Advanced" ->
                                syntaxImport.referenceExposes
                                    |> List.any
                                        (\syntaxExpose ->
                                            (syntaxExpose == operator)
                                                || (syntaxExpose == ("(" ++ operator ++ ")"))
                                        )

                            _ ->
                                False
                    )
    in
    importsNormal
        |> List.foldl
            (\syntaxImport soFar ->
                case modulesTypes |> FastDict.get syntaxImport.moduleName of
                    Nothing ->
                        soFar

                    Just moduleTypes ->
                        let
                            moduleAliasOrFullName : String
                            moduleAliasOrFullName =
                                case syntaxImport.alias of
                                    Nothing ->
                                        syntaxImport.moduleName

                                    Just importAlias ->
                                        importAlias
                        in
                        { keepOperatorIsExposedFromParserAdvanced =
                            soFar.keepOperatorIsExposedFromParserAdvanced
                        , ignoreOperatorIsExposedFromParserAdvanced =
                            soFar.ignoreOperatorIsExposedFromParserAdvanced
                        , references =
                            soFar.references
                                |> FastDict.update ""
                                    (\exposedReferencesSoFar ->
                                        syntaxImport.referenceExposes
                                            |> List.foldl
                                                (\expose referencesSoFarAndImportExposed ->
                                                    referencesSoFarAndImportExposed
                                                        |> FastDict.insert expose
                                                            syntaxImport.moduleName
                                                )
                                                (exposedReferencesSoFar
                                                    |> Maybe.withDefault FastDict.empty
                                                )
                                            |> Just
                                    )
                                |> FastDict.insert moduleAliasOrFullName
                                    (moduleTypes.choiceTypes
                                        |> FastDict.foldl
                                            (\_ choiceType variantNamesSoFar ->
                                                choiceType.variants
                                                    |> FastDict.foldl
                                                        (\variantName _ soFarAndVariantNamesOfCurrentChoiceType ->
                                                            soFarAndVariantNamesOfCurrentChoiceType
                                                                |> FastDict.insert
                                                                    variantName
                                                                    syntaxImport.moduleName
                                                        )
                                                        variantNamesSoFar
                                            )
                                            (moduleTypes.signatures
                                                |> FastDict.foldl
                                                    (\reference _ referenceNamesSoFar ->
                                                        referenceNamesSoFar
                                                            |> FastDict.insert
                                                                reference
                                                                syntaxImport.moduleName
                                                    )
                                                    (moduleTypes.typeAliases
                                                        |> FastDict.foldl
                                                            (\typeAliasName typeAliasInfo recordTypeALiasNamesSoFar ->
                                                                case typeAliasInfo.recordFieldOrder of
                                                                    Nothing ->
                                                                        recordTypeALiasNamesSoFar

                                                                    Just _ ->
                                                                        recordTypeALiasNamesSoFar
                                                                            |> FastDict.insert
                                                                                typeAliasName
                                                                                syntaxImport.moduleName
                                                            )
                                                            FastDict.empty
                                                    )
                                            )
                                    )
                        , typeConstructs =
                            soFar.typeConstructs
                                |> FastDict.update ""
                                    (\typeConstructsExposedSoFar ->
                                        syntaxImport.typeExposes
                                            |> List.foldl
                                                (\expose typeConstructsSoFarAndImportExposed ->
                                                    typeConstructsSoFarAndImportExposed
                                                        |> FastDict.insert expose
                                                            syntaxImport.moduleName
                                                )
                                                (typeConstructsExposedSoFar
                                                    |> Maybe.withDefault FastDict.empty
                                                )
                                            |> Just
                                    )
                                |> FastDict.insert moduleAliasOrFullName
                                    (moduleTypes.choiceTypes
                                        |> FastDict.foldl
                                            (\choiceTypeName _ variantNamesSoFar ->
                                                variantNamesSoFar
                                                    |> FastDict.insert
                                                        choiceTypeName
                                                        syntaxImport.moduleName
                                            )
                                            (moduleTypes.typeAliases
                                                |> FastDict.foldl
                                                    (\typeAliasName _ referenceNamesSoFar ->
                                                        referenceNamesSoFar
                                                            |> FastDict.insert
                                                                typeAliasName
                                                                syntaxImport.moduleName
                                                    )
                                                    FastDict.empty
                                            )
                                    )
                        }
            )
            { references = FastDict.empty
            , typeConstructs = FastDict.empty
            , keepOperatorIsExposedFromParserAdvanced =
                operatorIsExposedFromParserAdvanced "|."
            , ignoreOperatorIsExposedFromParserAdvanced =
                operatorIsExposedFromParserAdvanced "|="
            }


importToNormal :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Elm.Syntax.Import.Import
    ->
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importToNormal modulesTypes syntaxImport =
    let
        importModuleName : String
        importModuleName =
            syntaxImport.moduleName
                |> Elm.Syntax.Node.value
                |> moduleNameToString
    in
    { moduleName = importModuleName
    , alias =
        syntaxImport.moduleAlias
            |> Maybe.map
                (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                    syntaxAlias |> String.join "."
                )
    , typeExposes =
        case syntaxImport.exposingList of
            Nothing ->
                []

            Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                case modulesTypes |> FastDict.get importModuleName of
                    Nothing ->
                        []

                    Just moduleTypes ->
                        case syntaxExposing of
                            Elm.Syntax.Exposing.All _ ->
                                moduleTypes.choiceTypes
                                    |> FastDict.foldl
                                        (\choiceTypeName _ soFar ->
                                            choiceTypeName :: soFar
                                        )
                                        (moduleTypes.typeAliases |> FastDict.keys)

                            Elm.Syntax.Exposing.Explicit exposes ->
                                exposes
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ expose) ->
                                            case expose of
                                                Elm.Syntax.Exposing.InfixExpose _ ->
                                                    Nothing

                                                Elm.Syntax.Exposing.FunctionExpose _ ->
                                                    Nothing

                                                Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                    Just name

                                                Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                    Just choiceTypeExpose.name
                                        )
    , referenceExposes =
        case syntaxImport.exposingList of
            Nothing ->
                []

            Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                case modulesTypes |> FastDict.get importModuleName of
                    Nothing ->
                        []

                    Just moduleTypes ->
                        case syntaxExposing of
                            Elm.Syntax.Exposing.All _ ->
                                moduleTypes.typeAliases
                                    |> FastDict.foldl
                                        (\typeAliasName info soFar ->
                                            case info.recordFieldOrder of
                                                Nothing ->
                                                    soFar

                                                Just _ ->
                                                    typeAliasName :: soFar
                                        )
                                        (moduleTypes.choiceTypes
                                            |> FastDict.foldl
                                                (\_ choiceTypeInfo soFar ->
                                                    choiceTypeInfo.variants
                                                        |> FastDict.foldl
                                                            (\variantName _ soFarWithVariants ->
                                                                variantName :: soFarWithVariants
                                                            )
                                                            soFar
                                                )
                                                (moduleTypes.signatures |> FastDict.keys)
                                        )

                            Elm.Syntax.Exposing.Explicit exposes ->
                                exposes
                                    |> List.foldl
                                        (\(Elm.Syntax.Node.Node _ expose) namesSoFar ->
                                            case expose of
                                                Elm.Syntax.Exposing.TypeOrAliasExpose opaqueTypeOrTypeAliasName ->
                                                    case moduleTypes.typeAliases |> FastDict.get opaqueTypeOrTypeAliasName of
                                                        Nothing ->
                                                            namesSoFar

                                                        Just typeAlias ->
                                                            case typeAlias.recordFieldOrder of
                                                                Nothing ->
                                                                    namesSoFar

                                                                Just _ ->
                                                                    opaqueTypeOrTypeAliasName :: namesSoFar

                                                Elm.Syntax.Exposing.InfixExpose operator ->
                                                    operator :: namesSoFar

                                                Elm.Syntax.Exposing.FunctionExpose name ->
                                                    name :: namesSoFar

                                                Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                    case choiceTypeExpose.open of
                                                        Nothing ->
                                                            namesSoFar

                                                        Just _ ->
                                                            case moduleTypes.choiceTypes |> FastDict.get choiceTypeExpose.name of
                                                                Nothing ->
                                                                    namesSoFar

                                                                Just choiceTypeDeclared ->
                                                                    choiceTypeDeclared.variants
                                                                        |> FastDict.foldl
                                                                            (\name _ namesSoFarWithVariantNames ->
                                                                                name :: namesSoFarWithVariantNames
                                                                            )
                                                                            namesSoFar
                                        )
                                        []
    }


implicitImports :
    List
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
implicitImports =
    [ { moduleName = "Basics"
      , alias = Nothing
      , typeExposes = [ "Int", "Float", "Order", "Bool", "Never" ]
      , referenceExposes =
            [ "(+)"
            , "(-)"
            , "(*)"
            , "(/)"
            , "(//)"
            , "(^)"
            , "toFloat"
            , "round"
            , "floor"
            , "ceiling"
            , "truncate"
            , "(==)"
            , "(/=)"
            , "(<)"
            , "(>)"
            , "(<=)"
            , "(>=)"
            , "max"
            , "min"
            , "compare"
            , "LT"
            , "EQ"
            , "GT"
            , "True"
            , "False"
            , "not"
            , "(&&)"
            , "(||)"
            , "xor"
            , "(++)"
            , "modBy"
            , "remainderBy"
            , "negate"
            , "abs"
            , "clamp"
            , "sqrt"
            , "logBase"
            , "e"
            , "pi"
            , "cos"
            , "sin"
            , "tan"
            , "acos"
            , "asin"
            , "atan"
            , "atan2"
            , "degrees"
            , "radians"
            , "turns"
            , "toPolar"
            , "fromPolar"
            , "isNaN"
            , "isInfinite"
            , "identity"
            , "always"
            , "(<|)"
            , "(|>)"
            , "(<<)"
            , "(>>)"
            , "never"
            ]
      }
    , { moduleName = "List", alias = Nothing, typeExposes = [ "List" ], referenceExposes = [ "(::)" ] }
    , { moduleName = "Maybe", alias = Nothing, typeExposes = [ "Maybe" ], referenceExposes = [ "Just", "Nothing" ] }
    , { moduleName = "Result", alias = Nothing, typeExposes = [ "Result" ], referenceExposes = [ "Ok", "Err" ] }
    , { moduleName = "String", alias = Nothing, typeExposes = [ "String" ], referenceExposes = [] }
    , { moduleName = "Char", alias = Nothing, typeExposes = [ "Char" ], referenceExposes = [] }
    , { moduleName = "Tuple", alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = "Debug", alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = "Platform", alias = Nothing, typeExposes = [ "Program" ], referenceExposes = [] }
    , { moduleName = "Platform.Cmd", alias = Just "Cmd", typeExposes = [ "Cmd" ], referenceExposes = [] }
    , { moduleName = "Platform.Sub", alias = Just "Sub", typeExposes = [ "Sub" ], referenceExposes = [] }
    ]


importsCombine :
    List
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importsMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importsMerge :
    { moduleName : String
    , alias : Maybe String
    , typeExposes : List String
    , referenceExposes : List String
    }
    ->
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        { moduleName : String
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importsMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , typeExposes =
        exposingCombine earlier.typeExposes later.typeExposes
    , referenceExposes =
        exposingCombine earlier.referenceExposes later.referenceExposes
    }


exposingCombine : List String -> List String -> List String
exposingCombine a b =
    listAppendFastButInReverseOrder a b
        |> exposeListToNormal


exposeListToNormal :
    List String
    -> List String
exposeListToNormal syntaxExposeList =
    syntaxExposeList
        |> List.sort
        |> exposesCombine


exposesCombine : List String -> List String
exposesCombine syntaxExposes =
    exposesCombineFrom [] syntaxExposes


exposesCombineFrom : List String -> List String -> List String
exposesCombineFrom soFar syntaxExposes =
    case syntaxExposes of
        [] ->
            soFar

        [ onlyExpose ] ->
            onlyExpose :: soFar

        expose0 :: expose1 :: expose2Up ->
            case Basics.compare expose0 expose1 of
                EQ ->
                    exposesCombineFrom soFar (expose0 :: expose2Up)

                LT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)

                GT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)


syntaxToType :
    FastDict.Dict
        -- qualification
        String
        (FastDict.Dict
            -- name
            String
            String
        )
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String Type
syntaxToType typeConstructModuleOriginLookup syntaxTypeNode =
    syntaxToTypeInRootRange typeConstructModuleOriginLookup
        (syntaxTypeNode |> Elm.Syntax.Node.range)
        syntaxTypeNode


syntaxToTypeInRootRange :
    FastDict.Dict
        -- qualification
        String
        (FastDict.Dict
            -- name
            String
            String
        )
    -> Elm.Syntax.Range.Range
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String Type
syntaxToTypeInRootRange typeConstructModuleOriginLookup rootRange syntaxTypeNode =
    -- IGNORE TCO
    case syntaxTypeNode |> Elm.Syntax.Node.value of
        Elm.Syntax.TypeAnnotation.Unit ->
            okTypeUnit

        Elm.Syntax.TypeAnnotation.GenericType variableName ->
            Ok
                (TypeVariable
                    { useRange = rootRange
                    , name = variableName
                    }
                )

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( qualificationAsDotSeparated, unqualifiedName )) argumentNodes ->
            let
                qualification : String
                qualification =
                    qualificationAsDotSeparated |> String.join "."
            in
            case
                typeConstructModuleOriginLookup
                    |> FastDict.get qualification
                    |> Maybe.andThen
                        (\lookupInModule ->
                            lookupInModule |> FastDict.get unqualifiedName
                        )
            of
                Nothing ->
                    Err
                        (case qualificationAsDotSeparated of
                            [] ->
                                "could not find imported/local declaration for "
                                    ++ unqualifiedName

                            _ :: _ ->
                                "could not find imported declaration for "
                                    ++ qualifiedToString
                                        { qualification = qualification
                                        , name = unqualifiedName
                                        }
                        )

                Just originModule ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = originModule
                                    , name = unqualifiedName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentNodes
                            |> listMapAndCombineOk
                                (\argument ->
                                    argument
                                        |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                            rootRange
                                )
                        )

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [] ->
                    okTypeUnit

                [ inParens ] ->
                    inParens
                        |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                            rootRange

                [ syntaxPart0, syntaxPart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (syntaxPart0
                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                rootRange
                        )
                        (syntaxPart1
                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                rootRange
                        )

                [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (syntaxPart0
                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                rootRange
                        )
                        (syntaxPart1
                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                rootRange
                        )
                        (syntaxPart2
                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                rootRange
                        )

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.TypeAnnotation.Record recordFields ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (recordFields
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue
                                    |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                        rootRange
                                )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariableName) (Elm.Syntax.Node.Node _ recordExtensionFields) ->
            case recordExtensionFields of
                [] ->
                    Err "record extension by 0 fields is invalid syntax"

                field0 :: field1Up ->
                    Result.map
                        (\fields ->
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable =
                                        { useRange = rootRange
                                        , name = recordVariableName
                                        }
                                    , fields = fields
                                    }
                                )
                        )
                        ((field0 :: field1Up)
                            |> listFoldlWhileOkFrom
                                FastDict.empty
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    Result.map
                                        (\fieldValueType ->
                                            soFar |> FastDict.insert fieldName fieldValueType
                                        )
                                        (fieldValue
                                            |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                                                rootRange
                                        )
                                )
                        )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (syntaxInput
                    |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                        rootRange
                )
                (syntaxOutput
                    |> syntaxToTypeInRootRange typeConstructModuleOriginLookup
                        rootRange
                )


qualifiedToString :
    { qualification : String, name : String }
    -> String
qualifiedToString reference =
    case reference.qualification of
        "" ->
            reference.name

        qualificationAliasOrModuleName ->
            qualificationAliasOrModuleName
                ++ "."
                ++ reference.name


typeSubstituteVariable :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { variable : TypeVariableFromContext
        , type_ : Type
        }
    -> Type
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariable context replacement type_ =
    case replacement.type_ of
        TypeVariable argumentVariable ->
            Ok
                { type_ =
                    type_
                        |> typeMapVariables
                            (\variable ->
                                if TypeVariableFromContext.equals variable replacement.variable then
                                    argumentVariable

                                else
                                    variable
                            )
                , substitutions = variableSubstitutionsNone
                }

        TypeNotVariable argumentNotVariable ->
            type_
                |> typeSubstituteVariableByType context
                    (\variable ->
                        if TypeVariableFromContext.equals variable replacement.variable then
                            Just (TypeNotVariable argumentNotVariable)

                        else
                            Nothing
                    )
                |> Result.map
                    (\substituted ->
                        { type_ = substituted.type_
                        , substitutions = substituted.substitutions
                        }
                    )


typeApplyVariableSubstitutions :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> Type
    -> Result String Type
typeApplyVariableSubstitutions context substitutions originalType =
    if
        (substitutions.variableToType |> DictByTypeVariableFromContext.isEmpty)
            && (substitutions.equivalentVariables |> List.isEmpty)
    then
        Ok originalType

    else
        case
            createBatchOfSubstitutionsToApply
                context
                substitutions
        of
            Err error ->
                Err error

            Ok batchOfSubstitutionsToApply ->
                case
                    originalType
                        |> typeSubstituteVariableByType
                            context
                            batchOfSubstitutionsToApply.substituteVariableByType
                of
                    Err error ->
                        Err error

                    Ok substitutedType ->
                        if substitutedType.unchanged then
                            Ok originalType

                        else
                            case
                                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                    substitutedType.substitutions.variableToType
                                    substitutedType.substitutions.equivalentVariables
                                    batchOfSubstitutionsToApply.newEquivalentVariables
                            of
                                Err error ->
                                    Err error

                                Ok withNewEquivalentVariables ->
                                    typeApplyVariableSubstitutions context
                                        withNewEquivalentVariables
                                        substitutedType.type_


typeSubstituteVariableByType :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> Type
    ->
        Result
            String
            { unchanged : Bool
            , type_ : Type
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariableByType context replacement type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable typeVariable ->
            case replacement typeVariable of
                Nothing ->
                    Ok
                        { unchanged = True
                        , type_ = type_
                        , substitutions = variableSubstitutionsNone
                        }

                Just replacementType ->
                    case replacementType of
                        TypeVariable replacementTypeVariable ->
                            Ok
                                { unchanged = typeVariable == replacementTypeVariable
                                , type_ = replacementType
                                , substitutions = variableSubstitutionsNone
                                }

                        TypeNotVariable replacementTypeNotVariable ->
                            case typeVariable.name |> typeVariableConstraint of
                                Nothing ->
                                    Ok
                                        { unchanged = False
                                        , type_ = replacementType
                                        , substitutions = variableSubstitutionsNone
                                        }

                                Just constraint ->
                                    case constraint of
                                        TypeVariableConstraintNumber ->
                                            if
                                                replacementTypeNotVariable
                                                    |> typeNotVariableIsNumber context.declarationTypes
                                            then
                                                Ok
                                                    { unchanged = False
                                                    , type_ = replacementType
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Err
                                                    ("("
                                                        ++ (context.range |> rangeToInfoString)
                                                        ++ ") "
                                                        ++ "cannot unify number type variable with types other than Int/Float, found: "
                                                        ++ (replacementType |> typeToInfoString)
                                                    )

                                        TypeVariableConstraintAppendable ->
                                            if
                                                replacementTypeNotVariable
                                                    |> typeNotVariableIsAppendable context.declarationTypes
                                            then
                                                Ok
                                                    { unchanged = False
                                                    , type_ = replacementType
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Err
                                                    ("("
                                                        ++ (context.range |> rangeToInfoString)
                                                        ++ ") "
                                                        ++ "cannot unify appendable type variable with types other than String/List _"
                                                    )

                                        TypeVariableConstraintComparable ->
                                            if
                                                replacementTypeNotVariable
                                                    |> typeNotVariableIsComparable context.declarationTypes
                                            then
                                                Ok
                                                    { unchanged = False
                                                    , type_ = replacementType
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Err
                                                    ("("
                                                        ++ (context.range |> rangeToInfoString)
                                                        ++ ") "
                                                        ++ "cannot unify comparable type variable with types other than Int/Float/String/Time.Posix/List of comparable/tuple of comparables/triple of comparable"
                                                    )

                                        TypeVariableConstraintCompappend ->
                                            if
                                                replacementTypeNotVariable
                                                    |> typeNotVariableIsCompappend context.declarationTypes
                                            then
                                                Ok
                                                    { unchanged = False
                                                    , type_ = replacementType
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Err
                                                    ("("
                                                        ++ (context.range |> rangeToInfoString)
                                                        ++ ") "
                                                        ++ "cannot unify compappend type variable with types other than String/List of comparable"
                                                    )

        TypeNotVariable typeNotVariable ->
            case
                typeNotVariable
                    |> typeNotVariableSubstituteVariableByType context
                        replacement
            of
                Err error ->
                    Err error

                Ok typeNotVariableSubstituted ->
                    Ok
                        { unchanged = typeNotVariableSubstituted.unchanged
                        , type_ = TypeNotVariable typeNotVariableSubstituted.type_
                        , substitutions = typeNotVariableSubstituted.substitutions
                        }


typeToInfoString : Type -> String
typeToInfoString type_ =
    case type_ of
        TypeVariable typeVariable ->
            typeVariable |> typeVariableFromContextToInfoString

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableToInfoString


typeVariableFromContextToInfoString : TypeVariableFromContext -> String
typeVariableFromContextToInfoString typeVariableFromContext =
    typeVariableFromContext.name
        ++ "("
        ++ (typeVariableFromContext.useRange |> rangeToInfoString)
        ++ ")"


typeNotVariableToInfoString : TypeNotVariable -> String
typeNotVariableToInfoString typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typeToInfoString)
                ++ " -> "
                ++ (typeFunction.output |> typeToInfoString)
                ++ ")"

        TypeConstruct typeConstruct ->
            let
                typeReferenceAsString : String
                typeReferenceAsString =
                    qualifiedToString
                        { qualification = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
            in
            case typeConstruct.arguments of
                [] ->
                    typeReferenceAsString

                argument0 :: argument1Up ->
                    "("
                        ++ typeReferenceAsString
                        ++ (argument0
                                :: argument1Up
                                |> List.map (\argument -> " " ++ (argument |> typeToInfoString))
                                |> String.concat
                           )
                        ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ ", "
                ++ (parts.part2 |> typeToInfoString)
                ++ " )"

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension recordExtension ->
            "{ "
                ++ (recordExtension.recordVariable |> typeVariableFromContextToInfoString)
                ++ " | "
                ++ (recordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"


allUnchangedTrueArgumentsListEmptySubstitutionsEmpty :
    { allUnchanged : Bool
    , arguments : List Type
    , substitutions : VariableSubstitutions
    }
allUnchangedTrueArgumentsListEmptySubstitutionsEmpty =
    { allUnchanged = True
    , arguments = []
    , substitutions = variableSubstitutionsNone
    }


typeNotVariableSubstituteVariableByType :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> TypeNotVariable
    ->
        Result
            String
            { unchanged : Bool
            , type_ : TypeNotVariable
            , substitutions : VariableSubstitutions
            }
typeNotVariableSubstituteVariableByType context replacement typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            Ok
                { unchanged = True
                , type_ = typeNotVariable
                , substitutions = variableSubstitutionsNone
                }

        TypeConstruct typeChoiceConstruct ->
            case typeChoiceConstruct.arguments of
                [] ->
                    Ok
                        { unchanged = True
                        , type_ = typeNotVariable
                        , substitutions = variableSubstitutionsNone
                        }

                argument0 :: argument1Up ->
                    Result.map
                        (\argumentsSubstituted ->
                            { unchanged = argumentsSubstituted.allUnchanged
                            , type_ =
                                if argumentsSubstituted.allUnchanged then
                                    typeNotVariable

                                else
                                    TypeConstruct
                                        { moduleOrigin = typeChoiceConstruct.moduleOrigin
                                        , name = typeChoiceConstruct.name
                                        , arguments = argumentsSubstituted.arguments
                                        }
                            , substitutions = argumentsSubstituted.substitutions
                            }
                        )
                        ((argument0 :: argument1Up)
                            |> listFoldrWhileOkFrom
                                allUnchangedTrueArgumentsListEmptySubstitutionsEmpty
                                (\argument soFar ->
                                    Result.andThen
                                        (\argumentSubstituted ->
                                            if argumentSubstituted.unchanged then
                                                Ok
                                                    { allUnchanged = soFar.allUnchanged
                                                    , arguments =
                                                        argument :: soFar.arguments
                                                    , substitutions = variableSubstitutionsNone
                                                    }

                                            else
                                                Result.map
                                                    (\substitutionsWithArgument ->
                                                        { allUnchanged = False
                                                        , arguments =
                                                            argumentSubstituted.type_
                                                                :: soFar.arguments
                                                        , substitutions = substitutionsWithArgument
                                                        }
                                                    )
                                                    (variableSubstitutionsMerge context
                                                        argumentSubstituted.substitutions
                                                        soFar.substitutions
                                                    )
                                        )
                                        (argument
                                            |> typeSubstituteVariableByType context
                                                replacement
                                        )
                                )
                        )

        TypeTuple typeTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsPart01 ->
                                { unchanged = False
                                , type_ =
                                    TypeTuple
                                        { part0 = part0Substituted.type_
                                        , part1 = part1Substituted.type_
                                        }
                                , substitutions = substitutionsPart01
                                }
                            )
                            (variableSubstitutionsMerge context
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (typeTuple.part0
                    |> typeSubstituteVariableByType context
                        replacement
                )
                (typeTuple.part1
                    |> typeSubstituteVariableByType context
                        replacement
                )

        TypeTriple typeTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsPart01 ->
                                { unchanged = False
                                , type_ =
                                    TypeTriple
                                        { part0 = part0Substituted.type_
                                        , part1 = part1Substituted.type_
                                        , part2 = part2Substituted.type_
                                        }
                                , substitutions = substitutionsPart01
                                }
                            )
                            (variableSubstitutionsMerge3 context
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (typeTriple.part0
                    |> typeSubstituteVariableByType context
                        replacement
                )
                (typeTriple.part1
                    |> typeSubstituteVariableByType context
                        replacement
                )
                (typeTriple.part2
                    |> typeSubstituteVariableByType context
                        replacement
                )

        TypeRecord typeRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    if fieldsSubstituted.allUnchanged then
                        { unchanged = True
                        , type_ = typeNotVariable
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = fieldsSubstituted.substitutions
                        , type_ = TypeRecord fieldsSubstituted.types
                        }
                )
                (typeRecordFields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmptyAllUnchangedTrue
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName fieldValue
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithValue ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithValue
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert fieldName valueSubstituted.type_
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByType context
                                        replacement
                                )
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            Result.andThen
                (\fieldsSubstituted ->
                    case replacement typeRecordExtension.recordVariable of
                        Nothing ->
                            if fieldsSubstituted.allUnchanged then
                                Ok
                                    { unchanged = True
                                    , type_ = typeNotVariable
                                    , substitutions = variableSubstitutionsNone
                                    }

                            else
                                Ok
                                    { unchanged = False
                                    , substitutions = fieldsSubstituted.substitutions
                                    , type_ =
                                        TypeRecordExtension
                                            { recordVariable = typeRecordExtension.recordVariable
                                            , fields = fieldsSubstituted.types
                                            }
                                    }

                        Just recordVariableReplacement ->
                            case recordVariableReplacement of
                                TypeVariable recordVariableReplacementVariable ->
                                    Ok
                                        { unchanged = False
                                        , substitutions = fieldsSubstituted.substitutions
                                        , type_ =
                                            TypeRecordExtension
                                                { recordVariable = recordVariableReplacementVariable
                                                , fields = fieldsSubstituted.types
                                                }
                                        }

                                TypeNotVariable recordVariableReplacementTypeNotVariable ->
                                    case recordVariableReplacementTypeNotVariable of
                                        TypeRecord replacementRecordFields ->
                                            Result.map
                                                (\fieldsMerged ->
                                                    { unchanged = False
                                                    , substitutions = fieldsMerged.substitutions
                                                    , type_ = TypeRecord fieldsMerged.types
                                                    }
                                                )
                                                (FastDict.merge
                                                    (\name value soFarOrError ->
                                                        Result.map
                                                            (\soFar ->
                                                                { substitutions = soFar.substitutions
                                                                , types = soFar.types |> FastDict.insert name value
                                                                }
                                                            )
                                                            soFarOrError
                                                    )
                                                    (\name valueSubstituted valueReplacement soFarOrError ->
                                                        Result.andThen
                                                            (\soFar ->
                                                                Result.andThen
                                                                    (\valueUnified ->
                                                                        Result.map
                                                                            (\fullSubstitutions ->
                                                                                { substitutions = fullSubstitutions
                                                                                , types =
                                                                                    soFar.types
                                                                                        |> FastDict.insert name valueUnified.type_
                                                                                }
                                                                            )
                                                                            (variableSubstitutionsMerge context
                                                                                soFar.substitutions
                                                                                valueUnified.substitutions
                                                                            )
                                                                    )
                                                                    (typeUnify context
                                                                        valueSubstituted
                                                                        valueReplacement
                                                                    )
                                                            )
                                                            soFarOrError
                                                    )
                                                    (\name value soFarOrError ->
                                                        Result.map
                                                            (\soFar ->
                                                                { substitutions = soFar.substitutions
                                                                , types =
                                                                    soFar.types
                                                                        |> FastDict.insert name value
                                                                }
                                                            )
                                                            soFarOrError
                                                    )
                                                    fieldsSubstituted.types
                                                    replacementRecordFields
                                                    (Ok
                                                        { substitutions = fieldsSubstituted.substitutions
                                                        , types = FastDict.empty
                                                        }
                                                    )
                                                )

                                        TypeRecordExtension replacementRecordExtension ->
                                            Result.map
                                                (\fieldsMerged ->
                                                    { unchanged = False
                                                    , substitutions = fieldsMerged.substitutions
                                                    , type_ =
                                                        TypeRecordExtension
                                                            { recordVariable = replacementRecordExtension.recordVariable
                                                            , fields = fieldsMerged.types
                                                            }
                                                    }
                                                )
                                                (FastDict.merge
                                                    (\name value soFarOrError ->
                                                        Result.map
                                                            (\soFar ->
                                                                { substitutions = soFar.substitutions
                                                                , types = soFar.types |> FastDict.insert name value
                                                                }
                                                            )
                                                            soFarOrError
                                                    )
                                                    (\name valueSubstituted valueReplacement soFarOrError ->
                                                        Result.andThen
                                                            (\soFar ->
                                                                Result.andThen
                                                                    (\valueUnified ->
                                                                        Result.map
                                                                            (\fullSubstitutions ->
                                                                                { substitutions = fullSubstitutions
                                                                                , types =
                                                                                    soFar.types
                                                                                        |> FastDict.insert name valueUnified.type_
                                                                                }
                                                                            )
                                                                            (variableSubstitutionsMerge context
                                                                                soFar.substitutions
                                                                                valueUnified.substitutions
                                                                            )
                                                                    )
                                                                    (typeUnify context
                                                                        valueSubstituted
                                                                        valueReplacement
                                                                    )
                                                            )
                                                            soFarOrError
                                                    )
                                                    (\name value soFarOrError ->
                                                        Result.map
                                                            (\soFar ->
                                                                { substitutions = soFar.substitutions
                                                                , types = soFar.types |> FastDict.insert name value
                                                                }
                                                            )
                                                            soFarOrError
                                                    )
                                                    fieldsSubstituted.types
                                                    replacementRecordExtension.fields
                                                    (Ok
                                                        { substitutions = fieldsSubstituted.substitutions
                                                        , types = FastDict.empty
                                                        }
                                                    )
                                                )

                                        TypeUnit ->
                                            Err
                                                ("("
                                                    ++ (context.range |> rangeToInfoString)
                                                    ++ ") "
                                                    ++ "cannot unify record extension type variable with types other than record/record extension"
                                                )

                                        TypeConstruct _ ->
                                            Err
                                                ("("
                                                    ++ (context.range |> rangeToInfoString)
                                                    ++ ") "
                                                    ++ "cannot unify record extension type variable with types other than record/record extension"
                                                )

                                        TypeTuple _ ->
                                            Err
                                                ("("
                                                    ++ (context.range |> rangeToInfoString)
                                                    ++ ") "
                                                    ++ "cannot unify record extension type variable with types other than record/record extension"
                                                )

                                        TypeTriple _ ->
                                            Err
                                                ("("
                                                    ++ (context.range |> rangeToInfoString)
                                                    ++ ") "
                                                    ++ "cannot unify record extension type variable with types other than record/record extension"
                                                )

                                        TypeFunction _ ->
                                            Err
                                                ("("
                                                    ++ (context.range |> rangeToInfoString)
                                                    ++ ") "
                                                    ++ "cannot unify record extension type variable with types other than record/record extension"
                                                )
                )
                (typeRecordExtension.fields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmptyAllUnchangedTrue
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName fieldValue
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithValue ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithValue
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert fieldName valueSubstituted.type_
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByType context
                                        replacement
                                )
                        )
                )

        TypeFunction typeFunction ->
            resultAndThen2
                (\inputSubstituted outputSubstituted ->
                    if inputSubstituted.unchanged && outputSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , type_ = typeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\substitutionsInputOutput ->
                                { unchanged = False
                                , type_ =
                                    TypeFunction
                                        { input = inputSubstituted.type_
                                        , output = outputSubstituted.type_
                                        }
                                , substitutions = substitutionsInputOutput
                                }
                            )
                            (variableSubstitutionsMerge context
                                inputSubstituted.substitutions
                                outputSubstituted.substitutions
                            )
                )
                (typeFunction.input
                    |> typeSubstituteVariableByType context
                        replacement
                )
                (typeFunction.output
                    |> typeSubstituteVariableByType context
                        replacement
                )


substitutionsNoneTypesDictEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , types : FastDict.Dict String Type
    }
substitutionsNoneTypesDictEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , types = FastDict.empty
    }


typeIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type
    -> Bool
typeIsNumber declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable.name |> typeVariableConstraint of
                Nothing ->
                    False

                Just constraint ->
                    case constraint of
                        TypeVariableConstraintAppendable ->
                            True

                        TypeVariableConstraintCompappend ->
                            True

                        TypeVariableConstraintComparable ->
                            False

                        TypeVariableConstraintNumber ->
                            False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsNumber declarationTypes
                typeNotVariable


typeNotVariableIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable
    -> Bool
typeNotVariableIsNumber declarationTypes type_ =
    case type_ of
        TypeConstruct typeConstruct ->
            case typeConstruct.moduleOrigin of
                "Basics" ->
                    case typeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            typeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsNumber declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type
    -> Bool
typeIsAppendable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable.name |> typeVariableConstraint of
                Nothing ->
                    False

                Just constraint ->
                    case constraint of
                        TypeVariableConstraintAppendable ->
                            True

                        TypeVariableConstraintCompappend ->
                            True

                        TypeVariableConstraintComparable ->
                            False

                        TypeVariableConstraintNumber ->
                            False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsAppendable declarationTypes
                typeNotVariable


typeNotVariableIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable
    -> Bool
typeNotVariableIsAppendable declarationTypes type_ =
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                "String" ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                "List" ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsAppendable declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type
    -> Bool
typeIsComparable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable.name |> typeVariableConstraint of
                Nothing ->
                    False

                Just constraint ->
                    case constraint of
                        TypeVariableConstraintAppendable ->
                            False

                        TypeVariableConstraintCompappend ->
                            True

                        TypeVariableConstraintComparable ->
                            True

                        TypeVariableConstraintNumber ->
                            True

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsComparable declarationTypes
                typeNotVariable


typeNotVariableIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable
    -> Bool
typeNotVariableIsComparable declarationTypes typeNotVariable =
    -- IGNORE TCO
    case typeNotVariable of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                "String" ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                "Basics" ->
                    case variableReplacementTypeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                "Time" ->
                    case variableReplacementTypeConstruct.name of
                        "Posix" ->
                            True

                        _ ->
                            False

                "List" ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsComparable declarationTypes
                                deAliasedTypeConstruct

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeIsComparable declarationTypes)
                && (typeTuple.part1 |> typeIsComparable declarationTypes)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeIsComparable declarationTypes)
                && (typeTriple.part1 |> typeIsComparable declarationTypes)
                && (typeTriple.part2 |> typeIsComparable declarationTypes)

        TypeUnit ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type
    -> Bool
typeIsCompappend declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable.name |> typeVariableConstraint of
                Nothing ->
                    False

                Just constraint ->
                    case constraint of
                        TypeVariableConstraintAppendable ->
                            False

                        TypeVariableConstraintCompappend ->
                            True

                        TypeVariableConstraintComparable ->
                            False

                        TypeVariableConstraintNumber ->
                            False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsCompappend declarationTypes
                typeNotVariable


typeNotVariableIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable
    -> Bool
typeNotVariableIsCompappend declarationTypes type_ =
    -- IGNORE TCO
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                "Basics" ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                "List" ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias
                            { declarationTypes = declarationTypes
                            , range =
                                -- dummy
                                Elm.Syntax.Range.empty
                            }
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsCompappend declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeConstructFullyExpandIfAlias :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { name : String
        , arguments : List Type
        , moduleOrigin : String
        }
    -> Maybe Type
typeConstructFullyExpandIfAlias context typeConstructToExpand =
    case context.declarationTypes |> FastDict.get typeConstructToExpand.moduleOrigin of
        Nothing ->
            Nothing

        Just aOriginModuleTypes ->
            case aOriginModuleTypes.typeAliases |> FastDict.get typeConstructToExpand.name of
                Nothing ->
                    Nothing

                Just originAliasDeclaration ->
                    let
                        substitutionsToApplyToOriginAliasType :
                            { parameterToVariable : FastDict.Dict String TypeVariableFromContext
                            , parameterToTypeNotVariable : DictByTypeVariableFromContext TypeNotVariable
                            }
                        substitutionsToApplyToOriginAliasType =
                            listFoldl2From
                                parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty
                                originAliasDeclaration.parameters
                                typeConstructToExpand.arguments
                                (\parameterName argument soFar ->
                                    case argument of
                                        TypeVariable argumentVariable ->
                                            { parameterToVariable =
                                                soFar.parameterToVariable
                                                    |> FastDict.insert parameterName argumentVariable
                                            , parameterToTypeNotVariable = soFar.parameterToTypeNotVariable
                                            }

                                        TypeNotVariable argumentTypeNotVariable ->
                                            { parameterToVariable = soFar.parameterToVariable
                                            , parameterToTypeNotVariable =
                                                soFar.parameterToTypeNotVariable
                                                    |> DictByTypeVariableFromContext.insertNoReplace
                                                        { useRange = Elm.Syntax.Range.empty
                                                        , name = parameterName
                                                        }
                                                        argumentTypeNotVariable
                                            }
                                )

                        aliasTypeWithVariableArgumentsFilledIn : Type
                        aliasTypeWithVariableArgumentsFilledIn =
                            originAliasDeclaration.type_
                                |> typeMapVariables
                                    (\parameterVariable ->
                                        case
                                            substitutionsToApplyToOriginAliasType.parameterToVariable
                                                |> FastDict.get parameterVariable.name
                                        of
                                            Just variable ->
                                                variable

                                            Nothing ->
                                                { useRange = Elm.Syntax.Range.empty
                                                , name = parameterVariable.name
                                                }
                                    )
                    in
                    if
                        substitutionsToApplyToOriginAliasType.parameterToTypeNotVariable
                            |> DictByTypeVariableFromContext.isEmpty
                    then
                        Just aliasTypeWithVariableArgumentsFilledIn

                    else
                        case
                            aliasTypeWithVariableArgumentsFilledIn
                                |> typeSubstituteVariableByType context
                                    (\variable ->
                                        substitutionsToApplyToOriginAliasType.parameterToTypeNotVariable
                                            |> DictByTypeVariableFromContext.get variable
                                            |> Maybe.map TypeNotVariable
                                    )
                        of
                            Ok typeAliasWithSomeVariablesSubstitutedByTypes ->
                                Just typeAliasWithSomeVariablesSubstitutedByTypes.type_

                            Err _ ->
                                Nothing


parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty :
    { parameterToVariable : FastDict.Dict String TypeVariableFromContext
    , parameterToTypeNotVariable : DictByTypeVariableFromContext TypeNotVariable
    }
parameterToVariableDictEmptyParameterToTypeNotVariableDictEmpty =
    { parameterToVariable = FastDict.empty
    , parameterToTypeNotVariable = DictByTypeVariableFromContext.empty
    }


{-| All you need to turn a generic type with variables
into a concrete type with all the info we've inferred already.

While variable types in context get passed down,
variable substitutions get passed all the way to the top and only get processed there.

-}
type alias VariableSubstitutions =
    { equivalentVariables :
        List EquivalentTypeVariableSet
    , variableToType :
        DictByTypeVariableFromContext TypeNotVariable
    }


type alias EquivalentTypeVariableSet =
    { constraint : Maybe TypeVariableConstraint
    , overarchingUseRange : Elm.Syntax.Range.Range
    , variables : TypeVariableFromContextSet
    }


variableSubstitutionsNone : VariableSubstitutions
variableSubstitutionsNone =
    { equivalentVariables = []
    , variableToType = DictByTypeVariableFromContext.empty
    }


variableSubstitutionsMerge :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge context a b =
    -- IGNORE TCO
    -- TODO inline to get rid of Result.maps
    if a.variableToType |> DictByTypeVariableFromContext.isEmpty then
        case a.equivalentVariables of
            [] ->
                Ok b

            _ :: _ ->
                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                    b.variableToType
                    a.equivalentVariables
                    b.equivalentVariables

    else if b.variableToType |> DictByTypeVariableFromContext.isEmpty then
        case b.equivalentVariables of
            [] ->
                Ok a

            _ :: _ ->
                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                    a.variableToType
                    a.equivalentVariables
                    b.equivalentVariables

    else
        DictByTypeVariableFromContext.merge
            (\variable aType soFarOrError ->
                Result.map
                    (\soFar ->
                        { variableToType =
                            soFar.variableToType
                                |> DictByTypeVariableFromContext.insertNoReplace variable aType
                        , equivalentVariables =
                            soFar.equivalentVariables
                        }
                    )
                    soFarOrError
            )
            (\variable aType bType soFarOrError ->
                Result.andThen
                    (\soFar ->
                        Result.andThen
                            (\abTypesUnified ->
                                Result.andThen
                                    (\substitutionsWithAB ->
                                        case abTypesUnified.type_ of
                                            TypeVariable abUnifiedVariable ->
                                                Result.map
                                                    (\equivalentVariables ->
                                                        { equivalentVariables = equivalentVariables
                                                        , variableToType =
                                                            substitutionsWithAB.variableToType
                                                        }
                                                    )
                                                    (substitutionsWithAB.equivalentVariables
                                                        |> equivalentVariablesMergeWithSetOf2
                                                            variable
                                                            abUnifiedVariable
                                                    )

                                            TypeNotVariable abUnifiedNotVariable ->
                                                Ok
                                                    { equivalentVariables = substitutionsWithAB.equivalentVariables
                                                    , variableToType =
                                                        substitutionsWithAB.variableToType
                                                            |> DictByTypeVariableFromContext.insertNoReplace variable abUnifiedNotVariable
                                                    }
                                    )
                                    (variableSubstitutionsMerge context
                                        soFar
                                        abTypesUnified.substitutions
                                    )
                            )
                            (typeNotVariableUnify context aType bType)
                    )
                    soFarOrError
            )
            (\variable bType soFarOrError ->
                Result.map
                    (\soFar ->
                        { variableToType =
                            soFar.variableToType
                                |> DictByTypeVariableFromContext.insertNoReplace variable bType
                        , equivalentVariables =
                            soFar.equivalentVariables
                        }
                    )
                    soFarOrError
            )
            a.variableToType
            b.variableToType
            (equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                DictByTypeVariableFromContext.empty
                a.equivalentVariables
                b.equivalentVariables
            )


variableSubstitutionsMerge3 :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge3 context a b c =
    variableSubstitutionsMerge context a b
        |> Result.andThen
            (\abSubstitutions ->
                variableSubstitutionsMerge context
                    abSubstitutions
                    c
            )


variableSubstitutionsMerge4 :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge4 context a b c d =
    variableSubstitutionsMerge3
        context
        a
        b
        c
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    context
                    abcSubstitutions
                    d
            )


equivalentVariablesMergeWithSetOf2 :
    TypeVariableFromContext
    -> TypeVariableFromContext
    -> List EquivalentTypeVariableSet
    -> Result String (List EquivalentTypeVariableSet)
equivalentVariablesMergeWithSetOf2 aEquivalentVariable bEquivalentVariable equivalentVariables =
    if TypeVariableFromContext.equals aEquivalentVariable bEquivalentVariable then
        Ok equivalentVariables

    else
        equivalentVariablesMergeWithSetOf2Into []
            aEquivalentVariable
            bEquivalentVariable
            equivalentVariables


equivalentVariablesMergeWithSetOf2Into :
    List EquivalentTypeVariableSet
    -> TypeVariableFromContext
    -> TypeVariableFromContext
    -> List EquivalentTypeVariableSet
    -> Result String (List EquivalentTypeVariableSet)
equivalentVariablesMergeWithSetOf2Into soFar aEquivalentVariable bEquivalentVariable equivalentVariables =
    case equivalentVariables of
        [] ->
            Result.map
                (\abConstraint ->
                    { variables =
                        DictByTypeVariableFromContext.twoDistinct aEquivalentVariable () bEquivalentVariable ()
                    , constraint = abConstraint
                    , overarchingUseRange =
                        rangeOverarching
                            aEquivalentVariable.useRange
                            bEquivalentVariable.useRange
                    }
                        :: soFar
                )
                (maybeTypeVariableConstraintMerge
                    (aEquivalentVariable.name |> typeVariableConstraint)
                    (bEquivalentVariable.name |> typeVariableConstraint)
                )

        equivalentVariablesSet0 :: equivalentVariablesSet1Up ->
            if equivalentVariablesSet0 |> equivalentTypeVariableFromContextSetContains aEquivalentVariable then
                Result.map
                    (\unifiedConstraint ->
                        { variables =
                            equivalentVariablesSet0.variables
                                |> DictByTypeVariableFromContext.insertNoReplace bEquivalentVariable ()
                        , constraint = unifiedConstraint
                        , overarchingUseRange =
                            rangeOverarching
                                equivalentVariablesSet0.overarchingUseRange
                                bEquivalentVariable.useRange
                        }
                            :: listAppendFastButInReverseOrder
                                soFar
                                equivalentVariablesSet1Up
                    )
                    (maybeTypeVariableConstraintMerge
                        equivalentVariablesSet0.constraint
                        (bEquivalentVariable.name |> typeVariableConstraint)
                    )

            else if equivalentVariablesSet0 |> equivalentTypeVariableFromContextSetContains bEquivalentVariable then
                Result.map
                    (\unifiedConstraint ->
                        { variables =
                            equivalentVariablesSet0.variables
                                |> DictByTypeVariableFromContext.insertNoReplace aEquivalentVariable ()
                        , constraint = unifiedConstraint
                        , overarchingUseRange =
                            rangeOverarching
                                equivalentVariablesSet0.overarchingUseRange
                                aEquivalentVariable.useRange
                        }
                            :: listAppendFastButInReverseOrder
                                soFar
                                equivalentVariablesSet1Up
                    )
                    (maybeTypeVariableConstraintMerge
                        equivalentVariablesSet0.constraint
                        (aEquivalentVariable.name |> typeVariableConstraint)
                    )

            else
                equivalentVariablesMergeWithSetOf2Into
                    (equivalentVariablesSet0 :: soFar)
                    aEquivalentVariable
                    bEquivalentVariable
                    equivalentVariablesSet1Up


listAppendFastButInReverseOrder : List a -> List a -> List a
listAppendFastButInReverseOrder aList bList =
    case aList of
        [] ->
            bList

        aHead :: aTail ->
            listAppendFastButInReverseOrder aTail (aHead :: bList)


equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType :
    DictByTypeVariableFromContext TypeNotVariable
    -> List EquivalentTypeVariableSet
    -> List EquivalentTypeVariableSet
    -> Result String VariableSubstitutions
equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType variableToType a b =
    case a of
        [] ->
            Ok
                { variableToType = variableToType
                , equivalentVariables = b
                }

        _ :: _ ->
            case b of
                [] ->
                    Ok
                        { variableToType = variableToType
                        , equivalentVariables = a
                        }

                _ :: _ ->
                    Result.map
                        (\mergedIntoA ->
                            { variableToType = variableToType
                            , equivalentVariables =
                                listAppendFastButInReverseOrder
                                    mergedIntoA.sets
                                    mergedIntoA.bRemaining
                            }
                        )
                        (a
                            |> listFoldlWhileOkFrom
                                { sets = [], bRemaining = b }
                                (\aEquivalentVariableSet soFar ->
                                    case
                                        soFar.bRemaining
                                            |> listMapAndFirstJustAndRemainingAnyOrder
                                                (\bEquivalentVariableSet ->
                                                    if
                                                        equivalentTypeVariableSetShareElements
                                                            aEquivalentVariableSet
                                                            bEquivalentVariableSet
                                                    then
                                                        Just bEquivalentVariableSet

                                                    else
                                                        Nothing
                                                )
                                    of
                                        Nothing ->
                                            Ok
                                                { sets = aEquivalentVariableSet :: soFar.sets
                                                , bRemaining = soFar.bRemaining
                                                }

                                        Just bEquivalentVariableSetAndRemaining ->
                                            Result.map
                                                (\unifiedConstraint ->
                                                    { sets =
                                                        { variables =
                                                            DictByTypeVariableFromContext.setUnion
                                                                aEquivalentVariableSet.variables
                                                                bEquivalentVariableSetAndRemaining.value.variables
                                                        , constraint = unifiedConstraint
                                                        , overarchingUseRange =
                                                            rangeOverarching
                                                                aEquivalentVariableSet.overarchingUseRange
                                                                bEquivalentVariableSetAndRemaining.value.overarchingUseRange
                                                        }
                                                            :: soFar.sets
                                                    , bRemaining = bEquivalentVariableSetAndRemaining.remaining
                                                    }
                                                )
                                                (maybeTypeVariableConstraintMerge
                                                    aEquivalentVariableSet.constraint
                                                    bEquivalentVariableSetAndRemaining.value.constraint
                                                )
                                )
                        )


equivalentTypeVariableSetShareElements :
    EquivalentTypeVariableSet
    -> EquivalentTypeVariableSet
    -> Bool
equivalentTypeVariableSetShareElements a b =
    rangeAreOverlapping a.overarchingUseRange b.overarchingUseRange
        && (a.variables
                |> DictByTypeVariableFromContext.any
                    (\aKey () ->
                        b |> equivalentTypeVariableFromContextSetContains aKey
                    )
           )


rangeAreOverlapping : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeAreOverlapping a b =
    locationGreaterOrEqualThan a.end b.start
        && locationGreaterOrEqualThan b.end a.start


locationGreaterOrEqualThan : Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location -> Bool
locationGreaterOrEqualThan a b =
    (a.row - b.row > 0)
        || ((a.row - b.row == 0)
                && (a.column - b.column >= 0)
           )


equivalentTypeVariableFromContextSetContains :
    TypeVariableFromContext
    -> EquivalentTypeVariableSet
    -> Bool
equivalentTypeVariableFromContextSetContains variableToCheckInclusionFor equivalentTypeVariableFromContextSet =
    (equivalentTypeVariableFromContextSet.overarchingUseRange
        |> rangeIncludesRange variableToCheckInclusionFor.useRange
    )
        && (equivalentTypeVariableFromContextSet.variables
                |> DictByTypeVariableFromContext.member variableToCheckInclusionFor
           )


listMapAndFirstJustAndRemainingAnyOrder :
    (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAnyOrder elementToMaybe list =
    listMapAndFirstJustAndRemainingAndOrderWithBefore [] elementToMaybe list


listMapAndFirstJustAndRemainingAndOrderWithBefore :
    List a
    -> (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAndOrderWithBefore elementsBeforeReverse elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybe of
                Just headValue ->
                    Just
                        { value = headValue
                        , remaining =
                            listAppendFastButInReverseOrder
                                elementsBeforeReverse
                                tail
                        }

                Nothing ->
                    listMapAndFirstJustAndRemainingAndOrderWithBefore
                        (head :: elementsBeforeReverse)
                        elementToMaybe
                        tail


typeUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Type
    -> Type
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeUnify context a b =
    -- TODO optimize away Result.maps
    case a of
        TypeNotVariable aTypeNotVariable ->
            case b of
                TypeVariable bVariableName ->
                    Result.map
                        (\substitutions ->
                            { type_ = a
                            , substitutions = substitutions
                            }
                        )
                        (variableSubstitutionsFromVariableToTypeNotVariableOrError
                            context.declarationTypes
                            bVariableName
                            aTypeNotVariable
                        )

                TypeNotVariable bTypeNotVariable ->
                    typeNotVariableUnify context
                        aTypeNotVariable
                        bTypeNotVariable

        TypeVariable aVariable ->
            case b of
                TypeVariable bVariable ->
                    Result.map
                        (\abEquivalentVariablesSubstitutions ->
                            { type_ = a
                            , substitutions =
                                abEquivalentVariablesSubstitutions
                            }
                        )
                        (variableSubstitutionsFrom2EquivalentVariables
                            aVariable
                            bVariable
                        )

                TypeNotVariable bTypeNotVariable ->
                    Result.map
                        (\substitutions ->
                            { type_ = b
                            , substitutions = substitutions
                            }
                        )
                        (variableSubstitutionsFromVariableToTypeNotVariableOrError
                            context.declarationTypes
                            aVariable
                            bTypeNotVariable
                        )


typeNotVariableUnifyWithType :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable
    -> Type
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnifyWithType context aTypeNotVariable b =
    case b of
        TypeVariable bVariableName ->
            Result.map
                (\substitutions ->
                    { type_ = TypeNotVariable aTypeNotVariable
                    , substitutions = substitutions
                    }
                )
                (variableSubstitutionsFromVariableToTypeNotVariableOrError
                    context.declarationTypes
                    bVariableName
                    aTypeNotVariable
                )

        TypeNotVariable bTypeNotVariable ->
            typeNotVariableUnify context
                aTypeNotVariable
                bTypeNotVariable


typeUnifyWithTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Type
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List Type
        }
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeUnifyWithTypeConstruct context a bTypeConstruct =
    case a of
        TypeNotVariable aTypeNotVariable ->
            typeNotVariableUnifyWithTypeConstruct
                context
                aTypeNotVariable
                bTypeConstruct

        TypeVariable aVariable ->
            let
                bTypeNotVariable : TypeNotVariable
                bTypeNotVariable =
                    TypeConstruct bTypeConstruct
            in
            -- TODO inline to avoid Result.map
            Result.map
                (\substitutions ->
                    { type_ = TypeNotVariable bTypeNotVariable
                    , substitutions = substitutions
                    }
                )
                (variableSubstitutionsFromVariableToTypeNotVariableOrError
                    context.declarationTypes
                    aVariable
                    bTypeNotVariable
                )


typeUnifyWithBasicsBool :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Type
    ->
        Result
            String
            VariableSubstitutions
typeUnifyWithBasicsBool context a =
    case a of
        TypeNotVariable aTypeNotVariable ->
            case aTypeNotVariable of
                TypeConstruct aTypeConstruct ->
                    if
                        case aTypeConstruct.name of
                            "Bool" ->
                                case aTypeConstruct.moduleOrigin of
                                    "Basics" ->
                                        True

                                    _ ->
                                        False

                            _ ->
                                False
                    then
                        okVariableSubstitutionsNone

                    else
                        case typeUnifyWithTryToExpandTypeConstruct context aTypeConstruct typeNotVariableBasicsBool of
                            Just result ->
                                result |> Result.map .substitutions

                            Nothing ->
                                Err
                                    ("("
                                        ++ (context.range |> rangeToInfoString)
                                        ++ ") "
                                        ++ "choice type "
                                        ++ qualifiedToString
                                            { qualification = aTypeConstruct.moduleOrigin
                                            , name = aTypeConstruct.name
                                            }
                                        ++ " cannot be unified be with a choice type with a different name: Basics.Bool"
                                    )

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

                TypeTuple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

                TypeTriple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type Basics.Bool cannot be unified be with a choice type with a different name: Basics.Bool"
                        )

        TypeVariable aVariable ->
            variableSubstitutionsFromVariableToTypeNotVariableOrError
                context.declarationTypes
                aVariable
                typeNotVariableBasicsBool


typeNotVariableUnifyWithTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List Type
        }
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnifyWithTypeConstruct context aTypeNotVariable bTypeConstruct =
    case aTypeNotVariable of
        TypeConstruct aTypeConstruct ->
            if
                (bTypeConstruct.name == aTypeConstruct.name)
                    && (bTypeConstruct.moduleOrigin == aTypeConstruct.moduleOrigin)
            then
                case aTypeConstruct.arguments of
                    [] ->
                        Ok
                            { type_ = TypeNotVariable aTypeNotVariable
                            , substitutions = variableSubstitutionsNone
                            }

                    _ :: _ ->
                        Result.map
                            (\argumentsABUnified ->
                                { type_ =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = bTypeConstruct.moduleOrigin
                                            , name = bTypeConstruct.name
                                            , arguments =
                                                argumentsABUnified.argumentsReverse
                                                    |> List.reverse
                                            }
                                        )
                                , substitutions = argumentsABUnified.substitutions
                                }
                            )
                            (listFoldl2WhileOkFrom
                                argumentsReverseListEmptySubstitutionsNone
                                bTypeConstruct.arguments
                                aTypeConstruct.arguments
                                (\aArgument bArgument soFar ->
                                    Result.andThen
                                        (\argumentTypeUnifiedAndSubstitutions ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { argumentsReverse =
                                                        argumentTypeUnifiedAndSubstitutions.type_
                                                            :: soFar.argumentsReverse
                                                    , substitutions =
                                                        substitutionsWithArgument
                                                    }
                                                )
                                                (variableSubstitutionsMerge context
                                                    soFar.substitutions
                                                    argumentTypeUnifiedAndSubstitutions.substitutions
                                                )
                                        )
                                        (typeUnify context aArgument bArgument)
                                )
                            )

            else
                case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                    Just result ->
                        result

                    Nothing ->
                        case typeUnifyWithTryToExpandTypeConstruct context aTypeConstruct (TypeConstruct bTypeConstruct) of
                            Just result ->
                                result

                            Nothing ->
                                Err
                                    ("("
                                        ++ (context.range |> rangeToInfoString)
                                        ++ ") "
                                        ++ "choice type "
                                        ++ qualifiedToString
                                            { qualification = bTypeConstruct.moduleOrigin
                                            , name = bTypeConstruct.name
                                            }
                                        ++ " cannot be unified be with a choice type with a different name: "
                                        ++ (TypeConstruct aTypeConstruct |> typeNotVariableToInfoString)
                                    )

        TypeUnit ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeTuple _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeTriple _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeRecord _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeRecordExtension _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )

        TypeFunction _ ->
            case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct aTypeNotVariable of
                Just result ->
                    result

                Nothing ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "choice type "
                            ++ qualifiedToString
                                { qualification = bTypeConstruct.moduleOrigin
                                , name = bTypeConstruct.name
                                }
                            ++ " cannot be unified with types other than choice type/type alias"
                        )


variableSubstitutionsFromVariableToTypeNotVariableOrError :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeVariableFromContext
    -> TypeNotVariable
    -> Result String VariableSubstitutions
variableSubstitutionsFromVariableToTypeNotVariableOrError declarationTypes replacementVariable replacementTypeNotVariable =
    if replacementTypeNotVariable |> typeNotVariableContainsVariable replacementVariable then
        if replacementTypeNotVariable |> typeNotVariableIsEquivalentToTypeVariable declarationTypes then
            -- is ok when type is an identity type alias
            okVariableSubstitutionsNone

        else
            Err
                ("cannot unify the variable "
                    ++ (replacementVariable |> typeVariableFromContextToInfoString)
                    ++ " with the type "
                    ++ (replacementTypeNotVariable |> typeNotVariableToInfoString)
                    ++ " because that type contains the type variable itself."
                )

    else
        Ok
            { equivalentVariables = []
            , variableToType =
                DictByTypeVariableFromContext.singleton replacementVariable
                    replacementTypeNotVariable
            }


okVariableSubstitutionsNone : Result error_ VariableSubstitutions
okVariableSubstitutionsNone =
    Ok variableSubstitutionsNone


typeNotVariableUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> TypeNotVariable
    -> TypeNotVariable
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnify context a bNotVariable =
    case a of
        TypeUnit ->
            case bNotVariable of
                TypeUnit ->
                    okTypeUnitSubstitutionsNone

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "unit (`()`) cannot be unified with types other than unit"
                                )

                TypeTuple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeTriple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "unit (`()`) cannot be unified with types other than unit"
                        )

        TypeConstruct aTypeConstruct ->
            typeNotVariableUnifyWithTypeConstruct context
                bNotVariable
                aTypeConstruct

        TypeTuple aTuple ->
            case bNotVariable of
                TypeTuple bTuple ->
                    resultAndThen2
                        (\part0ABUnified part1ABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0ABUnified.type_
                                                , part1 = part1ABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge context
                                    part0ABUnified.substitutions
                                    part1ABUnified.substitutions
                                )
                        )
                        (typeUnify context aTuple.part0 bTuple.part0)
                        (typeUnify context aTuple.part1 bTuple.part1)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                                )

                TypeTriple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "tuple (`( ..., ... )`) cannot be unified with types other than tuple"
                        )

        TypeTriple aTriple ->
            case bNotVariable of
                TypeTriple bTriple ->
                    resultAndThen3
                        (\part0ABUnified part1ABUnified part2ABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0ABUnified.type_
                                                , part1 = part1ABUnified.type_
                                                , part2 = part2ABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge3 context
                                    part0ABUnified.substitutions
                                    part1ABUnified.substitutions
                                    part2ABUnified.substitutions
                                )
                        )
                        (typeUnify context aTriple.part0 bTriple.part0)
                        (typeUnify context aTriple.part1 bTriple.part1)
                        (typeUnify context aTriple.part1 bTriple.part1)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                                )

                TypeTuple _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeRecord _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeRecordExtension _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

                TypeFunction _ ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"
                        )

        TypeRecord aRecord ->
            case bNotVariable of
                TypeRecord bRecord ->
                    typeRecordUnify context aRecord bRecord

                TypeRecordExtension bRecordExtension ->
                    typeRecordExtensionUnifyWithRecord context
                        bRecordExtension
                        aRecord

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                        )

                TypeTriple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                        )

                TypeFunction bTypeFunction ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record "
                            ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                        )

        TypeRecordExtension aRecordExtension ->
            case bNotVariable of
                TypeRecord bRecord ->
                    typeRecordExtensionUnifyWithRecord context
                        aRecordExtension
                        bRecord

                TypeRecordExtension bRecordExtension ->
                    typeRecordExtensionUnifyWithRecordExtension context
                        aRecordExtension
                        bRecordExtension

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                        )

                TypeTriple bParts ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                        )

                TypeFunction bTypeFunction ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "record extension "
                            ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than record or record extension, found: "
                            ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                        )

        TypeFunction aFunction ->
            case bNotVariable of
                TypeFunction bFunction ->
                    resultAndThen2
                        (\inputABUnified outputABUnified ->
                            Result.map
                                (\substitutionsABMerged ->
                                    { type_ =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = inputABUnified.type_
                                                , output = outputABUnified.type_
                                                }
                                            )
                                    , substitutions = substitutionsABMerged
                                    }
                                )
                                (variableSubstitutionsMerge context
                                    inputABUnified.substitutions
                                    outputABUnified.substitutions
                                )
                        )
                        (typeUnify context aFunction.input bFunction.input)
                        (typeUnify context aFunction.output bFunction.output)

                TypeUnit ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeUnit |> typeNotVariableToInfoString)
                        )

                TypeConstruct bTypeConstruct ->
                    case typeUnifyWithTryToExpandTypeConstruct context bTypeConstruct a of
                        Just result ->
                            result

                        Nothing ->
                            Err
                                ("("
                                    ++ (context.range |> rangeToInfoString)
                                    ++ ") "
                                    ++ "function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                TypeTuple bTypeTuple ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeTuple bTypeTuple |> typeNotVariableToInfoString)
                        )

                TypeTriple bTypeTriple ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeTriple bTypeTriple |> typeNotVariableToInfoString)
                        )

                TypeRecord bTypeRecord ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeRecord bTypeRecord |> typeNotVariableToInfoString)
                        )

                TypeRecordExtension bTypeRecordExtension ->
                    Err
                        ("("
                            ++ (context.range |> rangeToInfoString)
                            ++ ") "
                            ++ "function "
                            ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                            ++ " cannot be unified with types other than function: "
                            ++ (TypeRecordExtension bTypeRecordExtension |> typeNotVariableToInfoString)
                        )


argumentsReverseListEmptySubstitutionsNone :
    { argumentsReverse : List argument_
    , substitutions : VariableSubstitutions
    }
argumentsReverseListEmptySubstitutionsNone =
    { argumentsReverse = []
    , substitutions = variableSubstitutionsNone
    }


okTypeUnitSubstitutionsNone : Result error_ { type_ : Type, substitutions : VariableSubstitutions }
okTypeUnitSubstitutionsNone =
    Ok
        { type_ = typeUnit
        , substitutions = variableSubstitutionsNone
        }


typeUnifyWithTryToExpandTypeConstruct :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List Type
        }
    -> TypeNotVariable
    ->
        Maybe
            (Result
                String
                { substitutions : VariableSubstitutions
                , type_ : Type
                }
            )
typeUnifyWithTryToExpandTypeConstruct context aTypeConstructToExpand b =
    case context.declarationTypes |> FastDict.get aTypeConstructToExpand.moduleOrigin of
        Nothing ->
            Just
                (Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "could not find declaration types in the origin module of the type construct "
                        ++ qualifiedToString
                            { qualification = aTypeConstructToExpand.moduleOrigin
                            , name = aTypeConstructToExpand.name
                            }
                    )
                )

        Just aOriginModuleTypes ->
            case aOriginModuleTypes.typeAliases |> FastDict.get aTypeConstructToExpand.name of
                Nothing ->
                    Nothing

                Just aOriginAliasDeclaration ->
                    let
                        prefix : String
                        prefix =
                            "parameter"
                                ++ (aTypeConstructToExpand.moduleOrigin |> String.replace "." "")
                                ++ aTypeConstructToExpand.name
                    in
                    Result.andThen
                        (\constructedAliasedType ->
                            Result.andThen
                                (\constructedAliasedTypeUnifiedWithB ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { type_ = constructedAliasedTypeUnifiedWithB.type_
                                            , substitutions = fullSubstitutions
                                            }
                                        )
                                        (variableSubstitutionsMerge context
                                            constructedAliasedTypeUnifiedWithB.substitutions
                                            constructedAliasedType.substitutions
                                        )
                                )
                                (typeNotVariableUnifyWithType context
                                    b
                                    constructedAliasedType.type_
                                )
                        )
                        (listFoldl2WhileOkFrom
                            { type_ =
                                aOriginAliasDeclaration.type_
                                    |> typeMapVariables
                                        (\aliasVariable ->
                                            { useRange = context.range
                                            , name = prefix ++ (aliasVariable.name |> stringFirstCharToUpper)
                                            }
                                        )
                            , substitutions = variableSubstitutionsNone
                            }
                            aOriginAliasDeclaration.parameters
                            aTypeConstructToExpand.arguments
                            (\parameterName argument constructedAliasedTypeSoFar ->
                                Result.andThen
                                    (\afterSubstitution ->
                                        Result.map
                                            (\substitutionsSoFarAndAfterSubstitution ->
                                                { type_ = afterSubstitution.type_
                                                , substitutions = substitutionsSoFarAndAfterSubstitution
                                                }
                                            )
                                            (variableSubstitutionsMerge context
                                                constructedAliasedTypeSoFar.substitutions
                                                afterSubstitution.substitutions
                                            )
                                    )
                                    (constructedAliasedTypeSoFar.type_
                                        |> typeSubstituteVariable context
                                            { variable =
                                                { useRange = context.range
                                                , name = prefix ++ (parameterName |> stringFirstCharToUpper)
                                                }
                                            , type_ = argument
                                            }
                                    )
                            )
                        )
                        |> Just


typeRecordUnify :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> FastDict.Dict String Type
    -> FastDict.Dict String Type
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeRecordUnify context aFields bFields =
    Result.map
        (\fieldsUnified ->
            { type_ =
                TypeNotVariable
                    (TypeRecord fieldsUnified.fieldsUnified)
            , substitutions = fieldsUnified.substitutions
            }
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            aFields
            bFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecord :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String Type
        }
    -> FastDict.Dict String Type
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecord context recordExtension recordFields =
    Result.andThen
        (\fieldsUnified ->
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeNotVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
                (variableSubstitutionsMerge context
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        DictByTypeVariableFromContext.singleton
                            recordExtension.recordVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("("
                        ++ (context.range |> rangeToInfoString)
                        ++ ") "
                        ++ "record extension with the field `"
                        ++ name
                        ++ "` cannot be unified with a record that does not have this field. The record extension is `"
                        ++ (TypeRecordExtension recordExtension |> typeNotVariableToInfoString)
                        ++ "` and the record is `"
                        ++ (TypeRecord recordFields |> typeNotVariableToInfoString)
                        ++ "`"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            recordExtension.fields
            recordFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecordExtension :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String Type
        }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String Type
        }
    ->
        Result
            String
            { type_ : Type
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecordExtension context aRecordExtension bRecordExtension =
    Result.andThen
        (\forFields ->
            let
                newBaseVariable : TypeVariableFromContext
                newBaseVariable =
                    { useRange =
                        rangeOverarching
                            aRecordExtension.recordVariable.useRange
                            bRecordExtension.recordVariable.useRange
                    , name = aRecordExtension.recordVariable.name
                    }
            in
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeNotVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields = forFields.fieldsUnified
                                }
                            )
                    }
                )
                (resultAndThen2
                    (\aRecordVariableSubstitutions bRecordVariableSubstitutions ->
                        variableSubstitutionsMerge3 context
                            forFields.substitutions
                            aRecordVariableSubstitutions
                            bRecordVariableSubstitutions
                    )
                    (if forFields.bOnly |> FastDict.isEmpty then
                        variableSubstitutionsFrom2EquivalentVariables
                            aRecordExtension.recordVariable
                            newBaseVariable

                     else
                        variableSubstitutionsFromVariableToTypeNotVariableOrError context.declarationTypes
                            aRecordExtension.recordVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields = forFields.bOnly
                                }
                            )
                    )
                    (if forFields.aOnly |> FastDict.isEmpty then
                        variableSubstitutionsFrom2EquivalentVariables
                            bRecordExtension.recordVariable
                            newBaseVariable

                     else
                        variableSubstitutionsFromVariableToTypeNotVariableOrError context.declarationTypes
                            bRecordExtension.recordVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields = forFields.aOnly
                                }
                            )
                    )
                )
        )
        (FastDict.merge
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        , aOnly =
                            soFar.aOnly |> FastDict.insert name value
                        , bOnly = soFar.bOnly
                        }
                    )
                    soFarOrError
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                , aOnly = soFar.aOnly
                                , bOnly = soFar.bOnly
                                }
                            )
                            (variableSubstitutionsMerge context
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify context aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        , aOnly = soFar.aOnly
                        , bOnly =
                            soFar.bOnly |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            aRecordExtension.fields
            bRecordExtension.fields
            okFieldsUnifiedEmptySubstitutionsNoneAOnlyDictEmptyBOnlyDictEmpty
        )


okFieldsUnifiedEmptySubstitutionsNoneAOnlyDictEmptyBOnlyDictEmpty :
    Result
        error_
        { fieldsUnified : FastDict.Dict String Type
        , substitutions : VariableSubstitutions
        , aOnly : FastDict.Dict String Type
        , bOnly : FastDict.Dict String Type
        }
okFieldsUnifiedEmptySubstitutionsNoneAOnlyDictEmptyBOnlyDictEmpty =
    Ok
        { fieldsUnified = FastDict.empty
        , substitutions = variableSubstitutionsNone
        , aOnly = FastDict.empty
        , bOnly = FastDict.empty
        }


okFieldsUnifiedEmptySubstitutionsNone :
    Result
        error_
        { fieldsUnified : FastDict.Dict String Type
        , substitutions : VariableSubstitutions
        }
okFieldsUnifiedEmptySubstitutionsNone =
    Ok
        { fieldsUnified = FastDict.empty
        , substitutions = variableSubstitutionsNone
        }


{-| A part in the syntax tree with an attached

  - [range](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Range#Range) in the source
  - global [`Type`](#Type): concretely inferred,
    influenced by other branches and value/function (let) declaration type annotations

-}
type alias TypedNode value =
    { range : Elm.Syntax.Range.Range
    , type_ : Type
    , value : value
    }


{-| Like [`Elm.Syntax.Expression.Expression`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Expression)
but its sub-nodes are [`TypedNode`](#TypedNode)s.

Be aware when trying to match references that they are split into multiple variants:
  - `ExpressionReference` (for let/module declared value/function or port or pattern variable use)
  - `ExpressionReferenceVariant`
  - `ExpressionReferenceRecordTypeAliasConstructorFunction`

-}
type Expression
    = ExpressionUnit
    | ExpressionInteger
        { base : Base10Or16
        , value : Int
        }
    | ExpressionFloat Float
    | ExpressionString String
    | ExpressionChar Char
    | ExpressionReference
        { moduleOrigin :
            -- `""` for pattern variable and let declaration uses
            String
        , qualification :
            -- `""` for no qualification
            String
        , name : String
        }
    | ExpressionReferenceVariant
        { moduleOrigin : String
        , choiceTypeName : String
        , qualification :
            -- `""` for no qualification
            String
        , name : String
        }
    | ExpressionReferenceRecordTypeAliasConstructorFunction
        { moduleOrigin : String
        , qualification :
            -- `""` for no qualification
            String
        , name : String
        }
    | ExpressionOperatorFunction
        { moduleOrigin : String
        , symbol : String
        }
    | ExpressionRecordAccessFunction String
    | ExpressionNegation (TypedNode Expression)
    | ExpressionParenthesized (TypedNode Expression)
    | ExpressionTuple
        { part0 : TypedNode Expression
        , part1 : TypedNode Expression
        }
    | ExpressionTriple
        { part0 : TypedNode Expression
        , part1 : TypedNode Expression
        , part2 : TypedNode Expression
        }
    | ExpressionRecordAccess
        { record : TypedNode Expression
        , fieldNameRange : Elm.Syntax.Range.Range
        , fieldName : String
        }
    | ExpressionInfixOperation
        { operator :
            { moduleOrigin : String
            , symbol : String
            , type_ : Type
            }
        , left : TypedNode Expression
        , right : TypedNode Expression
        }
    | ExpressionIfThenElse
        { condition : TypedNode Expression
        , onTrue : TypedNode Expression
        , onFalse : TypedNode Expression
        }
    | ExpressionList (List (TypedNode Expression))
    | ExpressionCall
        { called : TypedNode Expression
        , argument0 : TypedNode Expression
        , argument1Up : List (TypedNode Expression)
        }
    | ExpressionRecord
        (List
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode Expression
            }
        )
    | ExpressionRecordUpdate
        { recordVariable :
            TypedNode
                { moduleOrigin : String
                , name :
                    -- `""` for pattern variable and let declaration uses
                    String
                }
        , field0 :
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode Expression
            }
        , field1Up :
            List
                { range : Elm.Syntax.Range.Range
                , name : String
                , nameRange : Elm.Syntax.Range.Range
                , value : TypedNode Expression
                }
        }
    | ExpressionLambda
        { parameter0 : TypedNode Pattern
        , parameter1Up : List (TypedNode Pattern)
        , result : TypedNode Expression
        }
    | ExpressionCaseOf
        { matched : TypedNode Expression
        , case0 :
            { pattern : TypedNode Pattern
            , result : TypedNode Expression
            }
        , case1Up :
            List
                { pattern : TypedNode Pattern
                , result : TypedNode Expression
                }
        }
    | ExpressionLetIn
        { declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration
            }
        , declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration
                }
        , result : TypedNode Expression
        }


{-| Like [`Elm.Syntax.Expression.LetDeclaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#LetDeclaration)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type LetDeclaration
    = LetDestructuring
        { pattern : TypedNode Pattern
        , expression : TypedNode Expression
        }
    | LetValueOrFunctionDeclaration
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType :
                    -- variables names in here might not correspond
                    -- with those in .type_
                    Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (TypedNode Pattern)
        , result : TypedNode Expression
        , type_ : Type
        }


{-| Like [`Elm.Syntax.Pattern.Pattern`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern#Pattern)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Pattern
    = PatternIgnored
    | PatternVariable String
    | PatternParenthesized (TypedNode Pattern)
    | PatternAs
        { pattern : TypedNode Pattern
        , variable : TypedNode String
        }
    | PatternUnit
    | PatternChar Char
    | PatternString String
    | PatternInt { base : Base10Or16, value : Int }
    | PatternTuple
        { part0 : TypedNode Pattern
        , part1 : TypedNode Pattern
        }
    | PatternTriple
        { part0 : TypedNode Pattern
        , part1 : TypedNode Pattern
        , part2 : TypedNode Pattern
        }
    | PatternRecord (List (TypedNode String))
    | PatternListCons
        { head : TypedNode Pattern
        , tail : TypedNode Pattern
        }
    | PatternListExact (List (TypedNode Pattern))
    | PatternVariant
        { moduleOrigin : String
        , choiceTypeName : String
        , qualification :
            -- `""` for no qualification
            String
        , name : String
        , values : List (TypedNode Pattern)
        }


{-| Either decimal or hexadecimal.
Used by [`PatternInt`](#Pattern) and [`ExpressionInteger`](#Expression)
-}
type Base10Or16
    = Base10
    | Base16


typeBasicsFloat : Type
typeBasicsFloat =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Float"
            , arguments = []
            }
        )


typeBasicsBool : Type
typeBasicsBool =
    TypeNotVariable typeNotVariableBasicsBool


typeNotVariableBasicsBool : TypeNotVariable
typeNotVariableBasicsBool =
    TypeConstruct typeConstructBasicsBool


typeConstructBasicsBool :
    { moduleOrigin : String
    , name : String
    , arguments : List Type
    }
typeConstructBasicsBool =
    { moduleOrigin = "Basics"
    , name = "Bool"
    , arguments = []
    }


typeBasicsInt : Type
typeBasicsInt =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Int"
            , arguments = []
            }
        )


typeStringString : Type
typeStringString =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


typeCharChar : Type
typeCharChar =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeListList : Type -> Type
typeListList a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "List"
            , name = "List"
            , arguments = [ a ]
            }
        )


typeParserParser : Type -> Type
typeParserParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Parser"
            , name = "Parser"
            , arguments = [ a ]
            }
        )


typeParserAdvancedParser : Type -> Type -> Type -> Type
typeParserAdvancedParser context problem value =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Parser.Advanced"
            , name = "Parser"
            , arguments = [ context, problem, value ]
            }
        )


typeUrlParserParser : Type -> Type -> Type
typeUrlParserParser a b =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Url.Parser"
            , name = "Parser"
            , arguments = [ a, b ]
            }
        )


typeUrlParserQueryParser : Type -> Type
typeUrlParserQueryParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = "Url.Parser.Query"
            , name = "Parser"
            , arguments = [ a ]
            }
        )


patternTypedNodeIntroducedVariables :
    TypedNode Pattern
    -> FastDict.Dict String Type
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            FastDict.empty

        PatternIgnored ->
            FastDict.empty

        PatternInt _ ->
            FastDict.empty

        PatternString _ ->
            FastDict.empty

        PatternChar _ ->
            FastDict.empty

        PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        PatternRecord fieldVariables ->
            fieldVariables
                |> List.foldl
                    (\fieldVariable soFar ->
                        soFar
                            |> FastDict.insert fieldVariable.value
                                fieldVariable.type_
                    )
                    FastDict.empty

        PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern |> patternTypedNodeIntroducedVariables)

        PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        PatternListCons listCons ->
            FastDict.union
                (listCons.head |> patternTypedNodeIntroducedVariables)
                (listCons.tail |> patternTypedNodeIntroducedVariables)

        PatternTuple parts ->
            FastDict.union
                (parts.part0 |> patternTypedNodeIntroducedVariables)
                (parts.part1 |> patternTypedNodeIntroducedVariables)

        PatternTriple parts ->
            (parts.part0 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part1 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part2 |> patternTypedNodeIntroducedVariables)

        PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables

        PatternVariant variant ->
            variant.values
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables


patternTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
    -> Result String (TypedNode Pattern)
patternTypeInfer context (Elm.Syntax.Node.Node fullRange pattern) =
    -- IGNORE TCO
    case pattern of
        Elm.Syntax.Pattern.FloatPattern _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "float patterns are invalid syntax"
                )

        Elm.Syntax.Pattern.AllPattern ->
            Ok
                { range = fullRange
                , value = PatternIgnored
                , type_ =
                    TypeVariable
                        { useRange = fullRange, name = "ignored" }
                }

        Elm.Syntax.Pattern.UnitPattern ->
            Ok
                { range = fullRange
                , value = PatternUnit
                , type_ = typeUnit
                }

        Elm.Syntax.Pattern.CharPattern charValue ->
            Ok
                { range = fullRange
                , value = PatternChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Pattern.IntPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base10, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.HexPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base16, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.StringPattern stringValue ->
            Ok
                { range = fullRange
                , value = PatternString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Pattern.VarPattern variableName ->
            Ok
                { range = fullRange
                , value = PatternVariable variableName
                , type_ = TypeVariable { useRange = fullRange, name = variableName }
                }

        Elm.Syntax.Pattern.ParenthesizedPattern parenthesizedInParens ->
            Result.map
                (\inParens ->
                    { range = fullRange
                    , value = PatternParenthesized inParens
                    , type_ = inParens.type_
                    }
                )
                (parenthesizedInParens
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.AsPattern innerPatternNode (Elm.Syntax.Node.Node variableNameRange variableName) ->
            Result.map
                (\inner ->
                    { range = fullRange
                    , value =
                        PatternAs
                            { pattern = inner
                            , variable =
                                { value = variableName
                                , range = variableNameRange
                                , type_ = inner.type_
                                }
                            }
                    , type_ = inner.type_
                    }
                )
                (innerPatternNode
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.TuplePattern parts ->
            case parts of
                [] ->
                    -- should be handled by UnitPattern
                    Ok
                        { range = fullRange
                        , value = PatternUnit
                        , type_ = typeUnit
                        }

                [ parenthesizedInParens ] ->
                    -- should be handled by ParenthesizedPattern
                    Result.map
                        (\inParens ->
                            { range = fullRange
                            , value = PatternParenthesized inParens
                            , type_ = inParens.type_
                            }
                        )
                        (parenthesizedInParens
                            |> patternTypeInfer context
                        )

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            { range = fullRange
                            , value =
                                PatternTuple
                                    { part0 = part0
                                    , part1 = part1
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)

                [ tuplePart0, tuplePart1, tuplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            { range = fullRange
                            , value =
                                PatternTriple
                                    { part0 = part0
                                    , part1 = part1
                                    , part2 = part2
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        , part2 = part2.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)
                        (tuplePart2 |> patternTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "too many tuple parts"
                        )

        Elm.Syntax.Pattern.RecordPattern recordFields ->
            let
                fieldTypedNodes : List (TypedNode String)
                fieldTypedNodes =
                    recordFields
                        |> List.map
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) ->
                                { range = fieldRange
                                , value = fieldName
                                , type_ =
                                    TypeVariable
                                        { useRange = fieldRange
                                        , name = fieldName
                                        }
                                }
                            )
            in
            Ok
                { range = fullRange
                , value = PatternRecord fieldTypedNodes
                , type_ =
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable =
                                { useRange = fullRange, name = "record" }
                            , fields =
                                fieldTypedNodes
                                    |> List.foldl
                                        (\fieldVariable soFar ->
                                            soFar
                                                |> FastDict.insert fieldVariable.value
                                                    fieldVariable.type_
                                        )
                                        FastDict.empty
                            }
                        )
                }

        Elm.Syntax.Pattern.UnConsPattern headNode tailNode ->
            resultAndThen2
                (\headInferred tailInferred ->
                    Result.andThen
                        (\fullListTypeUnified ->
                            Result.map2
                                (\headAfterUnification tailAfterUnification ->
                                    { range = fullRange
                                    , value =
                                        PatternListCons
                                            { head = headAfterUnification
                                            , tail = tailAfterUnification
                                            }
                                    , type_ = fullListTypeUnified.type_
                                    }
                                )
                                (headInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                                (tailInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                        )
                        (typeUnifyWithTypeConstruct
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                            tailInferred.type_
                            { moduleOrigin = "List"
                            , name = "List"
                            , arguments = [ headInferred.type_ ]
                            }
                        )
                )
                (headNode |> patternTypeInfer context)
                (tailNode |> patternTypeInfer context)

        Elm.Syntax.Pattern.ListPattern elementNodes ->
            case elementNodes of
                [] ->
                    Ok
                        { range = fullRange
                        , value = patternListExactEmpty
                        , type_ =
                            typeListList
                                (TypeVariable
                                    { useRange = fullRange, name = "element" }
                                )
                        }

                head :: tail ->
                    Result.andThen
                        (\headInferred ->
                            let
                                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                                typeContext =
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                            in
                            Result.andThen
                                (\tailInferredAndUnifiedElementType ->
                                    Result.map2
                                        (\headInferredAfterUnification tailInferredAfterUnification ->
                                            { range = fullRange
                                            , value =
                                                PatternListExact
                                                    (headInferredAfterUnification :: tailInferredAfterUnification)
                                            , type_ =
                                                typeListList tailInferredAndUnifiedElementType.unifiedElementType
                                            }
                                        )
                                        (headInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                tailInferredAndUnifiedElementType.substitutions
                                        )
                                        (tailInferredAndUnifiedElementType.nodes
                                            |> listFoldrWhileOkFrom []
                                                (\tailElementInferred tailAfterUnificationSoFar ->
                                                    Result.map
                                                        (\tailElementAfterUnification ->
                                                            tailElementAfterUnification
                                                                :: tailAfterUnificationSoFar
                                                        )
                                                        (tailElementInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                tailInferredAndUnifiedElementType.substitutions
                                                        )
                                                )
                                        )
                                )
                                (tail
                                    |> listFoldrWhileOkFrom
                                        { nodes = []
                                        , unifiedElementType = headInferred.type_
                                        , substitutions = variableSubstitutionsNone
                                        }
                                        (\tailElementNode soFar ->
                                            Result.andThen
                                                (\tailElementInferred ->
                                                    Result.andThen
                                                        (\unifiedElementTypeSoFarWithTailElement ->
                                                            Result.map
                                                                (\substitutionsSoFarWithUnifyingTailElement ->
                                                                    { nodes = tailElementInferred :: soFar.nodes
                                                                    , substitutions = substitutionsSoFarWithUnifyingTailElement
                                                                    , unifiedElementType = unifiedElementTypeSoFarWithTailElement.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge typeContext
                                                                    soFar.substitutions
                                                                    unifiedElementTypeSoFarWithTailElement.substitutions
                                                                )
                                                        )
                                                        (typeUnify typeContext
                                                            soFar.unifiedElementType
                                                            tailElementInferred.type_
                                                        )
                                                )
                                                (tailElementNode |> patternTypeInfer context)
                                        )
                                )
                        )
                        (head |> patternTypeInfer context)

        Elm.Syntax.Pattern.NamedPattern qualified values ->
            let
                qualification : String
                qualification =
                    qualified.moduleName |> moduleNameToString

                moduleOriginInfoOrError :
                    Result
                        String
                        { name : String
                        , declarationTypes : ModuleTypes
                        }
                moduleOriginInfoOrError =
                    case
                        context.moduleOriginLookup.references
                            |> FastDict.get qualification
                            |> Maybe.andThen
                                (\inModuleLookup ->
                                    inModuleLookup |> FastDict.get qualified.name
                                )
                    of
                        Nothing ->
                            Err
                                ("("
                                    ++ (fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no module origin found for the pattern variant "
                                    ++ qualifiedToString
                                        { qualification = qualification
                                        , name = qualified.name
                                        }
                                )

                        Just moduleOrigin ->
                            case context.declarationTypes |> FastDict.get moduleOrigin of
                                Nothing ->
                                    Err
                                        ("("
                                            ++ (fullRange |> rangeToInfoString)
                                            ++ ") "
                                            ++ "no declaration types found at the module origin of the variant reference "
                                            ++ qualifiedToString
                                                { qualification = moduleOrigin
                                                , name = qualified.name
                                                }
                                        )

                                Just moduleOriginDeclarationTypes ->
                                    Ok
                                        { name = moduleOrigin
                                        , declarationTypes = moduleOriginDeclarationTypes
                                        }
            in
            case moduleOriginInfoOrError of
                Err error ->
                    Err error

                Ok moduleOriginInfo ->
                    case
                        moduleOriginInfo.declarationTypes.choiceTypes
                            |> fastDictMapAndSmallestJust
                                (\choiceTypeName choiceTypeInfo ->
                                    choiceTypeInfo.variants
                                        |> FastDict.get qualified.name
                                        |> Maybe.map
                                            (\variantParameters ->
                                                { variantParameters = variantParameters
                                                , choiceTypeName = choiceTypeName
                                                , choiceTypeParameters = choiceTypeInfo.parameters
                                                }
                                            )
                                )
                    of
                        Nothing ->
                            Err
                                ("("
                                    ++ (fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no choice type found at the module origin with the variant reference "
                                    ++ qualifiedToString
                                        { qualification = moduleOriginInfo.name
                                        , name = qualified.name
                                        }
                                )

                        Just variant ->
                            patternVariantTypeInfer context
                                { fullRange = fullRange
                                , qualification = qualification
                                , moduleOrigin = moduleOriginInfo.name
                                , name = qualified.name
                                , variantValueTypes = variant.variantParameters
                                , choiceTypeName = variant.choiceTypeName
                                , choiceTypeParameters = variant.choiceTypeParameters
                                , values = values
                                }


patternListExactEmpty : Pattern
patternListExactEmpty =
    PatternListExact []


patternVariantTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , moduleOrigin : String
        , qualification : String
        , name : String
        , choiceTypeName : String
        , choiceTypeParameters : List String
        , variantValueTypes : List Type
        , values : List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
        }
    -> Result String (TypedNode Pattern)
patternVariantTypeInfer context patternVariant =
    Result.map
        (\valuesAndResultTypeUnified ->
            { range = patternVariant.fullRange
            , value =
                PatternVariant
                    { moduleOrigin = patternVariant.moduleOrigin
                    , choiceTypeName = patternVariant.choiceTypeName
                    , qualification = patternVariant.qualification
                    , name = patternVariant.name
                    , values =
                        valuesAndResultTypeUnified.valuesReverse
                            |> List.reverse
                    }
            , type_ = valuesAndResultTypeUnified.resultType
            }
        )
        (listFoldl2WhileOkFrom
            { valuesReverse = []
            , resultType =
                TypeNotVariable
                    (TypeConstruct
                        { moduleOrigin = patternVariant.moduleOrigin
                        , name = patternVariant.choiceTypeName
                        , arguments =
                            patternVariant.choiceTypeParameters
                                |> List.map
                                    (\parameter ->
                                        TypeVariable
                                            { useRange = patternVariant.fullRange
                                            , name = parameter
                                            }
                                    )
                        }
                    )
            }
            patternVariant.variantValueTypes
            patternVariant.values
            (\typeInVariant argumentPattern soFar ->
                Result.andThen
                    (\valueInferred ->
                        let
                            typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                            typeContext =
                                { declarationTypes = context.declarationTypes
                                , range = patternVariant.fullRange
                                }
                        in
                        Result.andThen
                            (\valueTypeUnified ->
                                Result.map2
                                    (\resultTypeAfterUnification valueInferredAfterUnification ->
                                        { resultType =
                                            resultTypeAfterUnification
                                        , valuesReverse =
                                            valueInferredAfterUnification
                                                :: soFar.valuesReverse
                                        }
                                    )
                                    (soFar.resultType
                                        |> typeApplyVariableSubstitutions
                                            typeContext
                                            valueTypeUnified.substitutions
                                    )
                                    (valueInferred
                                        |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                            valueTypeUnified.substitutions
                                    )
                            )
                            (typeUnify typeContext
                                valueInferred.type_
                                (typeInVariant
                                    |> typeMapVariables
                                        (\variable ->
                                            { useRange = patternVariant.fullRange
                                            , name = variable.name
                                            }
                                        )
                                )
                            )
                    )
                    (argumentPattern |> patternTypeInfer context)
            )
        )


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


expressionTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    -> Result String (TypedNode Expression)
expressionTypeInfer context (Elm.Syntax.Node.Node fullRange expression) =
    -- IGNORE TCO
    case expression of
        Elm.Syntax.Expression.UnitExpr ->
            Ok
                { range = fullRange
                , value = ExpressionUnit
                , type_ = typeUnit
                }

        Elm.Syntax.Expression.Integer intValue ->
            Ok
                { range = fullRange
                , value = ExpressionInteger { base = Base10, value = intValue }
                , type_ =
                    TypeVariable
                        { useRange = fullRange, name = "number" }
                }

        Elm.Syntax.Expression.Hex intValue ->
            Ok
                { range = fullRange
                , value = ExpressionInteger { base = Base16, value = intValue }
                , type_ =
                    TypeVariable
                        { useRange = fullRange, name = "number" }
                }

        Elm.Syntax.Expression.Floatable floatValue ->
            Ok
                { range = fullRange
                , value = ExpressionFloat floatValue
                , type_ = typeBasicsFloat
                }

        Elm.Syntax.Expression.Literal stringValue ->
            Ok
                { range = fullRange
                , value = ExpressionString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Expression.CharLiteral charValue ->
            Ok
                { range = fullRange
                , value = ExpressionChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Expression.PrefixOperator operator ->
            Result.map
                (\operatorInferred ->
                    { range = fullRange
                    , value =
                        ExpressionOperatorFunction
                            { symbol = operator
                            , moduleOrigin = operatorInferred.moduleOrigin
                            }
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input = operatorInferred.leftType
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = operatorInferred.rightType
                                            , output = operatorInferred.resultType
                                            }
                                        )
                                }
                            )
                    }
                )
                (operatorFunctionType
                    { moduleOriginLookup = context.moduleOriginLookup
                    , range = fullRange
                    }
                    operator
                )

        Elm.Syntax.Expression.FunctionOrValue qualificationDotSeparated name ->
            expressionReferenceTypeInfer context
                { fullRange = fullRange
                , qualification = qualificationDotSeparated |> String.join "."
                , name = name
                }

        Elm.Syntax.Expression.RecordAccessFunction dotFieldName ->
            let
                fieldName : String
                fieldName =
                    dotFieldName |> String.dropLeft 1

                fieldValueType : Type
                fieldValueType =
                    TypeVariable
                        { useRange =
                            { start =
                                { row = fullRange.start.row
                                , column = fullRange.start.column + 1
                                }
                            , end = fullRange.end
                            }
                        , name = fieldName
                        }
            in
            Ok
                { range = fullRange
                , value =
                    ExpressionRecordAccessFunction fieldName
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeRecordExtension
                                        { recordVariable =
                                            { useRange = fullRange
                                            , name = "record"
                                            }
                                        , fields =
                                            FastDict.singleton fieldName
                                                fieldValueType
                                        }
                                    )
                            , output = fieldValueType
                            }
                        )
                }

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            Result.map
                (\inParensInferred ->
                    { range = fullRange
                    , value = ExpressionParenthesized inParensInferred
                    , type_ = inParensInferred.type_
                    }
                )
                (inParens
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.Negation negated ->
            Result.andThen
                (\negatedInferred ->
                    Result.andThen
                        (\substitutionsFromUnifyingNegatedWithNumber ->
                            { range = fullRange
                            , value = ExpressionNegation negatedInferred
                            , type_ = negatedInferred.type_
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    substitutionsFromUnifyingNegatedWithNumber
                        )
                        (variableSubstitutionsFromVariableToType context.declarationTypes
                            { useRange = fullRange, name = "number" }
                            negatedInferred.type_
                        )
                )
                (negated |> expressionTypeInfer context)

        Elm.Syntax.Expression.RecordAccess recordNode fieldNameNode ->
            Result.andThen
                (\accessedRecordInferred ->
                    let
                        (Elm.Syntax.Node.Node fieldRange fieldName) =
                            fieldNameNode

                        introducedFieldValueTypeVariable : Type
                        introducedFieldValueTypeVariable =
                            TypeVariable
                                { useRange = fieldRange
                                , name = fieldName
                                }
                    in
                    Result.andThen
                        (\recordWithAccessedFieldUnified ->
                            { range = fullRange
                            , value =
                                ExpressionRecordAccess
                                    { record = accessedRecordInferred
                                    , fieldName = fieldName
                                    , fieldNameRange =
                                        fieldNameNode |> Elm.Syntax.Node.range
                                    }
                            , type_ = introducedFieldValueTypeVariable
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    recordWithAccessedFieldUnified.substitutions
                        )
                        (typeNotVariableUnifyWithType
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                            (TypeRecordExtension
                                { recordVariable =
                                    { useRange = fullRange
                                    , name = "record"
                                    }
                                , fields =
                                    FastDict.singleton fieldName
                                        introducedFieldValueTypeVariable
                                }
                            )
                            accessedRecordInferred.type_
                        )
                )
                (recordNode |> expressionTypeInfer context)

        Elm.Syntax.Expression.OperatorApplication operator _ left right ->
            expressionInfixOperationTypeInfer context
                { fullRange = fullRange
                , operator = operator
                , left = left
                , right = right
                }

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            resultAndThen3
                (\conditionInferred onTrueInferred onFalseInferred ->
                    let
                        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                        typeContext =
                            { declarationTypes = context.declarationTypes
                            , range = fullRange
                            }
                    in
                    resultAndThen2
                        (\conditionTypeInferredUnifiedWithBoolSubstitutions onTrueOnFalseTypesUnified ->
                            Result.andThen
                                (\fullUnificationSubstitutions ->
                                    { range = fullRange
                                    , value =
                                        ExpressionIfThenElse
                                            { condition = conditionInferred
                                            , onTrue = onTrueInferred
                                            , onFalse = onFalseInferred
                                            }
                                    , type_ = onTrueInferred.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            fullUnificationSubstitutions
                                )
                                (variableSubstitutionsMerge typeContext
                                    conditionTypeInferredUnifiedWithBoolSubstitutions
                                    onTrueOnFalseTypesUnified.substitutions
                                )
                        )
                        (typeUnifyWithBasicsBool typeContext
                            conditionInferred.type_
                        )
                        (typeUnify typeContext
                            onTrueInferred.type_
                            onFalseInferred.type_
                        )
                )
                (condition |> expressionTypeInfer context)
                (onTrue |> expressionTypeInfer context)
                (onFalse |> expressionTypeInfer context)

        Elm.Syntax.Expression.TupledExpression tupleParts ->
            case tupleParts of
                [] ->
                    -- should be handled by UnitExpr
                    Ok
                        { range = fullRange
                        , value = ExpressionUnit
                        , type_ = typeUnit
                        }

                [ inParens ] ->
                    -- should be handled by ParenthesizedExpression
                    Result.map
                        (\inParensInferred ->
                            { range = fullRange
                            , value = ExpressionParenthesized inParensInferred
                            , type_ = inParensInferred.type_
                            }
                        )
                        (inParens
                            |> expressionTypeInfer context
                        )

                [ part0, part1 ] ->
                    Result.map2
                        (\part0Inferred part1Inferred ->
                            { range = fullRange
                            , value =
                                ExpressionTuple
                                    { part0 = part0Inferred
                                    , part1 = part1Inferred
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0Inferred.type_
                                        , part1 = part1Inferred.type_
                                        }
                                    )
                            }
                        )
                        (part0 |> expressionTypeInfer context)
                        (part1 |> expressionTypeInfer context)

                [ part0, part1, part2 ] ->
                    Result.map3
                        (\part0Inferred part1Inferred part2Inferred ->
                            { range = fullRange
                            , value =
                                ExpressionTriple
                                    { part0 = part0Inferred
                                    , part1 = part1Inferred
                                    , part2 = part2Inferred
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0Inferred.type_
                                        , part1 = part1Inferred.type_
                                        , part2 = part2Inferred.type_
                                        }
                                    )
                            }
                        )
                        (part0 |> expressionTypeInfer context)
                        (part1 |> expressionTypeInfer context)
                        (part2 |> expressionTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "too many tuple parts"
                        )

        Elm.Syntax.Expression.ListExpr elements ->
            case elements of
                [] ->
                    Ok
                        { range = fullRange
                        , value = expressionListEmpty
                        , type_ =
                            typeListList
                                (TypeVariable
                                    { useRange = fullRange, name = "element" }
                                )
                        }

                head :: tail ->
                    Result.andThen
                        (\headInferred ->
                            let
                                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                                typeContext =
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                            in
                            Result.andThen
                                (\tailElementsInferredAndUnifiedElementType ->
                                    { range = fullRange
                                    , value =
                                        ExpressionList
                                            (headInferred
                                                :: tailElementsInferredAndUnifiedElementType.nodes
                                            )
                                    , type_ = typeListList tailElementsInferredAndUnifiedElementType.unifiedElementType
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            tailElementsInferredAndUnifiedElementType.substitutions
                                )
                                (tail
                                    |> listFoldrWhileOkFrom
                                        { nodes = []
                                        , unifiedElementType = headInferred.type_
                                        , substitutions = variableSubstitutionsNone
                                        }
                                        (\elementNode soFar ->
                                            Result.andThen
                                                (\tailElementInferred ->
                                                    Result.andThen
                                                        (\unifiedSoFarElementTypeWithElement ->
                                                            Result.map
                                                                (\substitutionsSoFarWithElement ->
                                                                    { nodes = tailElementInferred :: soFar.nodes
                                                                    , substitutions = substitutionsSoFarWithElement
                                                                    , unifiedElementType = unifiedSoFarElementTypeWithElement.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge typeContext
                                                                    soFar.substitutions
                                                                    unifiedSoFarElementTypeWithElement.substitutions
                                                                )
                                                        )
                                                        (typeUnify typeContext
                                                            soFar.unifiedElementType
                                                            tailElementInferred.type_
                                                        )
                                                )
                                                (elementNode |> expressionTypeInfer context)
                                        )
                                )
                        )
                        (head |> expressionTypeInfer context)

        Elm.Syntax.Expression.Application application ->
            case application of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "empty application is invalid syntax"
                        )

                [ subExpression ] ->
                    -- never produced by elm-syntax
                    subExpression |> expressionTypeInfer context

                called :: argument0 :: argument1Up ->
                    resultAndThen3
                        (\calledInferred argument0Inferred argument1UpInferred ->
                            let
                                introducedResultTypeVariable : Type
                                introducedResultTypeVariable =
                                    TypeVariable
                                        { useRange = fullRange
                                        , name = "callResult"
                                        }
                            in
                            Result.andThen
                                (\callTypeUnified ->
                                    { range = fullRange
                                    , value =
                                        ExpressionCall
                                            { called = calledInferred
                                            , argument0 = argument0Inferred
                                            , argument1Up = argument1UpInferred
                                            }
                                    , type_ = introducedResultTypeVariable
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            callTypeUnified.substitutions
                                )
                                (typeUnify
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = argument0Inferred.type_
                                            , output =
                                                argument1UpInferred
                                                    |> List.foldr
                                                        (\argumentInferred output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentInferred.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        introducedResultTypeVariable
                                            }
                                        )
                                    )
                                    calledInferred.type_
                                )
                        )
                        (called |> expressionTypeInfer context)
                        (argument0 |> expressionTypeInfer context)
                        (argument1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\argumentNode soFar ->
                                    Result.map
                                        (\argumentInferred ->
                                            argumentInferred :: soFar
                                        )
                                        (argumentNode |> expressionTypeInfer context)
                                )
                        )

        Elm.Syntax.Expression.RecordExpr fields ->
            Result.map
                (\fieldsInferred ->
                    { range = fullRange
                    , value =
                        ExpressionRecord
                            fieldsInferred
                    , type_ =
                        TypeNotVariable
                            (TypeRecord
                                (fieldsInferred
                                    |> List.foldl
                                        (\field soFar ->
                                            soFar
                                                |> FastDict.insert field.name
                                                    field.value.type_
                                        )
                                        FastDict.empty
                                )
                            )
                    }
                )
                (fields
                    |> listFoldrWhileOkFrom
                        []
                        (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node fieldNameRange fieldName, fieldValueNode )) soFar ->
                            Result.map
                                (\fieldValueInferred ->
                                    { range = fieldRange
                                    , name = fieldName
                                    , nameRange = fieldNameRange
                                    , value = fieldValueInferred
                                    }
                                        :: soFar
                                )
                                (fieldValueNode |> expressionTypeInfer context)
                        )
                )

        Elm.Syntax.Expression.RecordUpdateExpression (Elm.Syntax.Node.Node recordVariableRange recordVariable) fields ->
            case fields of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "record update without fields is invalid syntax"
                        )

                (Elm.Syntax.Node.Node field0Range ( Elm.Syntax.Node.Node field0NameRange field0Name, field0ValueNode )) :: field1Up ->
                    resultAndThen3
                        (\recordVariableInferred field0Inferred field1UpInferred ->
                            case recordVariableInferred.value of
                                ExpressionReference recordVariableReference ->
                                    Result.andThen
                                        (\recordVariableUnifiedWithUpdate ->
                                            { range = fullRange
                                            , value =
                                                ExpressionRecordUpdate
                                                    { recordVariable =
                                                        { range = recordVariableInferred.range
                                                        , value =
                                                            { moduleOrigin = recordVariableReference.moduleOrigin
                                                            , name = recordVariableReference.name
                                                            }
                                                        , type_ = recordVariableInferred.type_
                                                        }
                                                    , field0 = field0Inferred
                                                    , field1Up = field1UpInferred
                                                    }
                                            , type_ = recordVariableInferred.type_
                                            }
                                                |> expressionTypedNodeApplyVariableSubstitutions
                                                    context.declarationTypes
                                                    recordVariableUnifiedWithUpdate.substitutions
                                        )
                                        (typeUnify
                                            { declarationTypes = context.declarationTypes
                                            , range = fullRange
                                            }
                                            recordVariableInferred.type_
                                            (TypeNotVariable
                                                (TypeRecordExtension
                                                    { recordVariable =
                                                        { useRange = fullRange
                                                        , name = recordVariableReference.name
                                                        }
                                                    , fields =
                                                        field1UpInferred
                                                            |> List.foldl
                                                                (\fieldInferred soFar ->
                                                                    soFar
                                                                        |> FastDict.insert fieldInferred.name
                                                                            fieldInferred.value.type_
                                                                )
                                                                (FastDict.singleton
                                                                    field0Inferred.name
                                                                    field0Inferred.value.type_
                                                                )
                                                    }
                                                )
                                            )
                                        )

                                _ ->
                                    Err "record update variable needs to be a reference to a lowercase value or function"
                        )
                        ({ fullRange = recordVariableRange
                         , qualification = ""
                         , name = recordVariable
                         }
                            |> expressionReferenceTypeInfer context
                        )
                        (Result.map
                            (\valueInferred ->
                                { range = field0Range
                                , name = field0Name
                                , nameRange = field0NameRange
                                , value = valueInferred
                                }
                            )
                            (field0ValueNode |> expressionTypeInfer context)
                        )
                        (field1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node nameRange name, valueNode )) soFar ->
                                    Result.map
                                        (\fieldValueInferred ->
                                            { range = fieldRange
                                            , name = name
                                            , nameRange = nameRange
                                            , value = fieldValueInferred
                                            }
                                                :: soFar
                                        )
                                        (valueNode |> expressionTypeInfer context)
                                )
                        )

        Elm.Syntax.Expression.LambdaExpression lambda ->
            case lambda.args of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "lambda without parameter patterns is invalid syntax"
                        )

                parameter0 :: parameter1Up ->
                    resultAndThen2
                        (\parameter0Inferred parameter1UpInferred ->
                            Result.andThen
                                (\resultInferred ->
                                    Result.andThen
                                        (\parameterPatternVariablesAndUsesUnificationSubstitutions ->
                                            { range = fullRange
                                            , value =
                                                ExpressionLambda
                                                    { parameter0 = parameter0Inferred
                                                    , parameter1Up = parameter1UpInferred
                                                    , result = resultInferred
                                                    }
                                            , type_ =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = parameter0Inferred.type_
                                                        , output =
                                                            parameter1UpInferred
                                                                |> List.foldr
                                                                    (\argumentTypedNode output ->
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input = argumentTypedNode.type_
                                                                                , output = output
                                                                                }
                                                                            )
                                                                    )
                                                                    resultInferred.type_
                                                        }
                                                    )
                                            }
                                                |> expressionTypedNodeApplyVariableSubstitutions
                                                    context.declarationTypes
                                                    parameterPatternVariablesAndUsesUnificationSubstitutions
                                        )
                                        (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                            { declarationTypes = context.declarationTypes
                                            , range = fullRange
                                            }
                                            ((parameter0Inferred :: parameter1UpInferred)
                                                |> listMapToFastDictsAndUnify
                                                    patternTypedNodeIntroducedVariables
                                            )
                                            resultInferred
                                        )
                                )
                                (lambda.expression
                                    |> expressionTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                (List.foldl
                                                    (\parameter soFar ->
                                                        FastDict.union soFar
                                                            (parameter |> patternTypedNodeIntroducedVariables)
                                                    )
                                                    (parameter0Inferred |> patternTypedNodeIntroducedVariables)
                                                    parameter1UpInferred
                                                )
                                        }
                                )
                        )
                        (parameter0
                            |> patternTypeInfer
                                { moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (parameter1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\pattern soFar ->
                                    Result.map
                                        (\patternInferred ->
                                            patternInferred :: soFar
                                        )
                                        (pattern
                                            |> patternTypeInfer
                                                { declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            case caseOf.cases of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "case-of without case branches is invalid syntax"
                        )

                case0 :: case1Up ->
                    resultAndThen3
                        (\matchedInferred case0Inferred case1UpInferred ->
                            let
                                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                                typeContext =
                                    { declarationTypes = context.declarationTypes
                                    , range = fullRange
                                    }
                            in
                            Result.andThen
                                (\unifiedTypes ->
                                    { range = fullRange
                                    , value =
                                        ExpressionCaseOf
                                            { matched = matchedInferred
                                            , case0 = case0Inferred
                                            , case1Up = case1UpInferred
                                            }
                                    , type_ = case0Inferred.result.type_
                                    }
                                        |> expressionTypedNodeApplyVariableSubstitutions
                                            context.declarationTypes
                                            unifiedTypes.substitutions
                                )
                                (case1UpInferred
                                    |> listFoldlWhileOkFromResult
                                        (Result.map
                                            (\matchedExpressionCase0PatternUnifiedType ->
                                                { resultType = case0Inferred.result.type_
                                                , matchedType = matchedExpressionCase0PatternUnifiedType.type_
                                                , substitutions = matchedExpressionCase0PatternUnifiedType.substitutions
                                                }
                                            )
                                            (typeUnify typeContext
                                                matchedInferred.type_
                                                case0Inferred.pattern.type_
                                            )
                                        )
                                        (\caseInferred soFar ->
                                            resultAndThen2
                                                (\matchedTypeUnifiedWithCasePattern resultTypeUnifiedWithCaseResult ->
                                                    Result.map
                                                        (\substitutionsWithCase ->
                                                            { substitutions = substitutionsWithCase
                                                            , matchedType = matchedTypeUnifiedWithCasePattern.type_
                                                            , resultType = resultTypeUnifiedWithCaseResult.type_
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge3
                                                            typeContext
                                                            soFar.substitutions
                                                            matchedTypeUnifiedWithCasePattern.substitutions
                                                            resultTypeUnifiedWithCaseResult.substitutions
                                                        )
                                                )
                                                (typeUnify typeContext
                                                    soFar.matchedType
                                                    caseInferred.pattern.type_
                                                )
                                                (typeUnify typeContext
                                                    soFar.resultType
                                                    caseInferred.result.type_
                                                )
                                        )
                                )
                        )
                        (caseOf.expression |> expressionTypeInfer context)
                        (case0
                            |> expressionCaseTypeInfer context
                        )
                        (case1Up
                            |> listFoldrWhileOkFrom
                                []
                                (\case_ soFar ->
                                    Result.map
                                        (\caseInferred ->
                                            caseInferred :: soFar
                                        )
                                        (case_
                                            |> expressionCaseTypeInfer context
                                        )
                                )
                        )

        Elm.Syntax.Expression.LetExpression letIn ->
            case letIn.declarations of
                [] ->
                    Err
                        ("("
                            ++ (fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ "let-in without declarations is invalid syntax"
                        )

                letDeclaration0Node :: letDeclaration1Up ->
                    expressionLetInTypeInfer context
                        { declaration0 = letDeclaration0Node
                        , declaration1Up = letDeclaration1Up
                        , expression = letIn.expression
                        , fullRange = fullRange
                        }

        Elm.Syntax.Expression.Operator _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "Elm.Syntax.Expression.Operator is not valid syntax"
                )

        Elm.Syntax.Expression.GLSLExpression _ ->
            Err
                ("("
                    ++ (fullRange |> rangeToInfoString)
                    ++ ") "
                    ++ "glsl shader expressions not supported"
                )


expressionLetInTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    }
    ->
        { declaration0 : Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
        , declaration1Up : List (Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration)
        , fullRange : Elm.Syntax.Range.Range
        , expression : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    -> Result String (TypedNode Expression)
expressionLetInTypeInfer context syntaxExpressionLetIn =
    Result.andThen
        (\acrossLetInIncludingContextSoFar ->
            let
                inferContextAcrossLetIn :
                    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
                    , locallyIntroducedExpressionVariables : FastDict.Dict String Type
                    , locallyIntroducedDeclarationTypes :
                        FastDict.Dict
                            String
                            { type_ : Type
                            , range : Elm.Syntax.Range.Range
                            , moduleLevel : String
                            }
                    , moduleOriginLookup : ModuleOriginLookup
                    }
                inferContextAcrossLetIn =
                    { locallyIntroducedExpressionVariables =
                        acrossLetInIncludingContextSoFar.introducedExpressionVariables
                    , moduleOriginLookup = context.moduleOriginLookup
                    , declarationTypes = context.declarationTypes
                    , locallyIntroducedDeclarationTypes =
                        acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                    }
            in
            resultAndThen3
                (\declaration0Inferred declaration1UpInferred resultInferred ->
                    let
                        letInTypedNodeInferred : TypedNode Expression
                        letInTypedNodeInferred =
                            { range = syntaxExpressionLetIn.fullRange
                            , type_ = resultInferred.type_
                            , value =
                                ExpressionLetIn
                                    { declaration0 = declaration0Inferred
                                    , declaration1Up =
                                        declaration1UpInferred
                                    , result = resultInferred
                                    }
                            }

                        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                        typeContext =
                            { declarationTypes = context.declarationTypes
                            , range = syntaxExpressionLetIn.fullRange
                            }

                        inferredUnannotatedDeclarationTypes : FastDict.Dict String { range : Elm.Syntax.Range.Range, type_ : Type }
                        inferredUnannotatedDeclarationTypes =
                            if acrossLetInIncludingContextSoFar.unannotatedDeclarationsExist then
                                (declaration0Inferred :: declaration1UpInferred)
                                    |> listMapToFastDictsAndUnify
                                        (\declarationInferred ->
                                            case declarationInferred.declaration of
                                                LetDestructuring _ ->
                                                    FastDict.empty

                                                LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
                                                    case letValueOrFunctionDeclaration.signature of
                                                        Just _ ->
                                                            FastDict.empty

                                                        Nothing ->
                                                            FastDict.singleton
                                                                letValueOrFunctionDeclaration.name
                                                                { range = declarationInferred.range
                                                                , type_ = letValueOrFunctionDeclaration.type_
                                                                }
                                        )

                            else
                                FastDict.empty
                    in
                    Result.andThen
                        (\fullSubstitutions ->
                            letInTypedNodeInferred
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    fullSubstitutions
                        )
                        (resultAndThen2
                            (\destructuringUseUnificationSubstitutions declarationUseUnificationSubstitutions ->
                                variableSubstitutionsMerge
                                    typeContext
                                    destructuringUseUnificationSubstitutions
                                    declarationUseUnificationSubstitutions
                            )
                            (if acrossLetInIncludingContextSoFar.destructuringExists then
                                substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                    typeContext
                                    ((declaration0Inferred :: declaration1UpInferred)
                                        |> listMapToFastDictsAndUnify
                                            (\declarationInferred ->
                                                case declarationInferred.declaration of
                                                    LetDestructuring letDestructuring ->
                                                        letDestructuring.pattern
                                                            |> patternTypedNodeIntroducedVariables

                                                    LetValueOrFunctionDeclaration _ ->
                                                        FastDict.empty
                                            )
                                    )
                                    letInTypedNodeInferred

                             else
                                okVariableSubstitutionsNone
                            )
                            (substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression
                                typeContext
                                inferredUnannotatedDeclarationTypes
                                letInTypedNodeInferred
                            )
                        )
                )
                (syntaxExpressionLetIn.declaration0
                    |> letDeclarationTypeInfer
                        inferContextAcrossLetIn
                )
                (syntaxExpressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        []
                        (\letDeclarationNode soFar ->
                            Result.map
                                (\letDeclarationInferred ->
                                    letDeclarationInferred :: soFar
                                )
                                (letDeclarationNode
                                    |> letDeclarationTypeInfer
                                        inferContextAcrossLetIn
                                )
                        )
                )
                (syntaxExpressionLetIn.expression
                    |> expressionTypeInfer
                        inferContextAcrossLetIn
                )
        )
        ((syntaxExpressionLetIn.declaration0 :: syntaxExpressionLetIn.declaration1Up)
            |> listFoldlWhileOkFrom
                { unannotatedDeclarationsExist = False
                , destructuringExists = False
                , introducedExpressionVariables =
                    context.locallyIntroducedExpressionVariables
                , introducedDeclarationTypes =
                    context.locallyIntroducedDeclarationTypes
                }
                (\(Elm.Syntax.Node.Node letDeclarationRange letDeclaration) soFar ->
                    case letDeclaration of
                        Elm.Syntax.Expression.LetDestructuring patternNode _ ->
                            Result.map
                                (\patternInferred ->
                                    { unannotatedDeclarationsExist =
                                        soFar.unannotatedDeclarationsExist
                                    , introducedDeclarationTypes =
                                        soFar.introducedDeclarationTypes
                                    , destructuringExists = True
                                    , introducedExpressionVariables =
                                        FastDict.union soFar.introducedExpressionVariables
                                            (patternInferred |> patternTypedNodeIntroducedVariables)
                                    }
                                )
                                (patternNode
                                    |> patternTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        }
                                )

                        Elm.Syntax.Expression.LetFunction letValueOrFunctionDeclaration ->
                            let
                                (Elm.Syntax.Node.Node _ name) =
                                    (letValueOrFunctionDeclaration.declaration
                                        |> Elm.Syntax.Node.value
                                    ).name
                            in
                            case letValueOrFunctionDeclaration.signature of
                                Nothing ->
                                    Ok
                                        { unannotatedDeclarationsExist = True
                                        , destructuringExists = soFar.destructuringExists
                                        , introducedExpressionVariables =
                                            soFar.introducedExpressionVariables
                                        , introducedDeclarationTypes =
                                            soFar.introducedDeclarationTypes
                                                |> FastDict.insert name
                                                    { range = letDeclarationRange
                                                    , type_ =
                                                        TypeVariable
                                                            { useRange = letDeclarationRange
                                                            , name = name
                                                            }
                                                    , moduleLevel = ""
                                                    }
                                        }

                                Just (Elm.Syntax.Node.Node _ signature) ->
                                    Result.map
                                        (\type_ ->
                                            { destructuringExists = soFar.destructuringExists
                                            , unannotatedDeclarationsExist =
                                                soFar.unannotatedDeclarationsExist
                                            , introducedExpressionVariables =
                                                soFar.introducedExpressionVariables
                                            , introducedDeclarationTypes =
                                                soFar.introducedDeclarationTypes
                                                    |> FastDict.insert name
                                                        { range = letDeclarationRange
                                                        , type_ = type_
                                                        , moduleLevel = ""
                                                        }
                                            }
                                        )
                                        (signature.typeAnnotation
                                            |> syntaxToType context.moduleOriginLookup.typeConstructs
                                        )
                )
        )


substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> FastDict.Dict String Type
    -> TypedNode Expression
    -> Result String VariableSubstitutions
substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression context introducedVariables expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedVariables
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\variableName usesInLambdaResult soFar ->
                case introducedVariables |> FastDict.get variableName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just variableParameterType ->
                        usesInLambdaResult
                            |> ropeFoldlWhileOkFrom
                                { substitutions = soFar
                                , type_ = variableParameterType
                                }
                                (\_ useInLambdaResultType unifiedAcrossUsesSoFar ->
                                    Result.andThen
                                        (\unifiedSoFarWithUse ->
                                            Result.map
                                                (\unificationWithSoFarSubstitutions ->
                                                    { type_ = unifiedSoFarWithUse.type_
                                                    , substitutions = unificationWithSoFarSubstitutions
                                                    }
                                                )
                                                (variableSubstitutionsMerge context
                                                    unifiedAcrossUsesSoFar.substitutions
                                                    unifiedSoFarWithUse.substitutions
                                                )
                                        )
                                        (typeUnify context
                                            useInLambdaResultType
                                            unifiedAcrossUsesSoFar.type_
                                        )
                                )
                            |> Result.map .substitutions
            )


substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type
            }
    -> TypedNode Expression
    -> Result String VariableSubstitutions
substitutionsForInstanceUnifyingIntroducedLetDeclaredTypesWithUsesInExpression context introducedDeclarations expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedDeclarations
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\declarationName usesInLambdaResult soFar ->
                case introducedDeclarations |> FastDict.get declarationName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just inferredDeclarationType ->
                        usesInLambdaResult
                            |> ropeFoldlWhileOkFrom
                                soFar
                                (\useRange useType soFarWithUses ->
                                    let
                                        newDeclarationTypeInstanceForUse : Type
                                        newDeclarationTypeInstanceForUse =
                                            inferredDeclarationType.type_
                                                |> typeMapVariables
                                                    (\inferredDeclarationTypeVariable ->
                                                        if
                                                            inferredDeclarationType.range
                                                                |> rangeIncludesRange
                                                                    inferredDeclarationTypeVariable.useRange
                                                        then
                                                            { useRange = useRange
                                                            , name = inferredDeclarationTypeVariable.name
                                                            }

                                                        else
                                                            inferredDeclarationTypeVariable
                                                    )
                                    in
                                    Result.andThen
                                        (\useUnifiedWithNewLetTypeInstance ->
                                            -- we need to check if the partialTpeNewInstance
                                            -- is actually more strict then the already existing use type.
                                            -- If we don't, this would run indefinitely: E.g.
                                            -- a : number
                                            -- b = round a
                                            -- where a is already known as Float
                                            -- when it is unified with the let `number`
                                            if
                                                typesAreEquallyStrict
                                                    (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                    (useType |> typeContainedVariables)
                                            then
                                                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                                    soFarWithUses.variableToType
                                                    soFarWithUses.equivalentVariables
                                                    useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables

                                            else
                                                variableSubstitutionsMerge context
                                                    soFarWithUses
                                                    useUnifiedWithNewLetTypeInstance.substitutions
                                        )
                                        (typeUnify context
                                            useType
                                            newDeclarationTypeInstanceForUse
                                        )
                                )
            )


substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type
            }
    -> TypedNode Expression
    -> Result String VariableSubstitutions
substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression context introducedDeclarations expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeUsesOfLocalReferences
            introducedDeclarations
        |> fastDictFoldlWhileOkFrom variableSubstitutionsNone
            (\declarationName usesInLambdaResult soFar ->
                case introducedDeclarations |> FastDict.get declarationName of
                    Nothing ->
                        Err
                            ("("
                                ++ (context.range |> rangeToInfoString)
                                ++ ") "
                                ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                            )

                    Just inferredDeclarationType ->
                        usesInLambdaResult
                            |> ropeFoldlWhileOkFrom
                                soFar
                                (\useRange useType soFarWithUses ->
                                    let
                                        newDeclarationTypeInstanceForUse : Type
                                        newDeclarationTypeInstanceForUse =
                                            inferredDeclarationType.type_
                                                |> typeMapVariables
                                                    (\inferredDeclarationTypeVariable ->
                                                        { useRange = useRange
                                                        , name = inferredDeclarationTypeVariable.name
                                                        }
                                                    )
                                    in
                                    Result.andThen
                                        (\useUnifiedWithNewLetTypeInstance ->
                                            -- we need to check if the partialTpeNewInstance
                                            -- is actually more strict then the already existing use type.
                                            -- If we don't, this would run indefinitely: E.g.
                                            -- a : number
                                            -- b = round a
                                            -- where a is already known as Float
                                            -- when it is unified with the let `number`
                                            if
                                                typesAreEquallyStrict
                                                    (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                    (useType |> typeContainedVariables)
                                            then
                                                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                                    soFarWithUses.variableToType
                                                    soFarWithUses.equivalentVariables
                                                    useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables

                                            else
                                                variableSubstitutionsMerge context
                                                    soFarWithUses
                                                    useUnifiedWithNewLetTypeInstance.substitutions
                                        )
                                        (typeUnify context
                                            useType
                                            newDeclarationTypeInstanceForUse
                                        )
                                )
            )


typeUnit : Type
typeUnit =
    TypeNotVariable TypeUnit


expressionListEmpty : Expression
expressionListEmpty =
    ExpressionList []


expressionCaseTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        ( Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
        , Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        )
    ->
        Result
            String
            { pattern : TypedNode Pattern
            , result : TypedNode Expression
            }
expressionCaseTypeInfer context ( syntaxCasePattern, syntaxCaseResult ) =
    Result.andThen
        (\patternInferred ->
            Result.andThen
                (\resultInferred ->
                    let
                        patternIntroducedVariables : FastDict.Dict String Type
                        patternIntroducedVariables =
                            patternInferred |> patternTypedNodeIntroducedVariables
                    in
                    if patternIntroducedVariables |> FastDict.isEmpty then
                        Ok
                            { pattern = patternInferred
                            , result = resultInferred
                            }

                    else
                        Result.andThen
                            (\substitutionsFromUnifyingPatternVariablesWithUses ->
                                Result.map2
                                    (\patternInferredSubstituted resultInferredSubstituted ->
                                        { pattern = patternInferredSubstituted
                                        , result = resultInferredSubstituted
                                        }
                                    )
                                    (patternInferred
                                        |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                            substitutionsFromUnifyingPatternVariablesWithUses
                                    )
                                    (resultInferred
                                        |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                            substitutionsFromUnifyingPatternVariablesWithUses
                                    )
                            )
                            (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                { declarationTypes = context.declarationTypes
                                , range =
                                    { start = (syntaxCasePattern |> Elm.Syntax.Node.range).start
                                    , end = (syntaxCaseResult |> Elm.Syntax.Node.range).end
                                    }
                                }
                                patternIntroducedVariables
                                resultInferred
                            )
                )
                (syntaxCaseResult
                    |> expressionTypeInfer
                        { declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , locallyIntroducedDeclarationTypes =
                            context.locallyIntroducedDeclarationTypes
                        , locallyIntroducedExpressionVariables =
                            FastDict.union context.locallyIntroducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                )
        )
        (syntaxCasePattern
            |> patternTypeInfer
                { declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


expressionReferenceTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , qualification : String
        , name : String
        }
    -> Result String (TypedNode Expression)
expressionReferenceTypeInfer context expressionReference =
    let
        useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration : Maybe (TypedNode Expression)
        useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration =
            case expressionReference.qualification of
                "" ->
                    case
                        context.locallyIntroducedExpressionVariables
                            |> FastDict.get expressionReference.name
                    of
                        Just locallyIntroducedExpressionVariableType ->
                            Just
                                { range = expressionReference.fullRange
                                , value =
                                    ExpressionReference
                                        { qualification = ""
                                        , moduleOrigin = ""
                                        , name = expressionReference.name
                                        }
                                , type_ = locallyIntroducedExpressionVariableType
                                }

                        Nothing ->
                            case
                                context.locallyIntroducedDeclarationTypes
                                    |> FastDict.get expressionReference.name
                            of
                                Nothing ->
                                    Nothing

                                Just locallyIntroducedDeclarationType ->
                                    Just
                                        { range = expressionReference.fullRange
                                        , value =
                                            ExpressionReference
                                                { qualification = ""
                                                , moduleOrigin = locallyIntroducedDeclarationType.moduleLevel
                                                , name = expressionReference.name
                                                }
                                        , type_ =
                                            locallyIntroducedDeclarationType.type_
                                                |> typeMapVariables
                                                    (\partiallyInferredTypeVariable ->
                                                        if
                                                            locallyIntroducedDeclarationType.range
                                                                |> rangeIncludesRange
                                                                    partiallyInferredTypeVariable.useRange
                                                        then
                                                            { useRange = expressionReference.fullRange
                                                            , name = partiallyInferredTypeVariable.name
                                                            }

                                                        else
                                                            partiallyInferredTypeVariable
                                                    )
                                        }

                -- expressionReference.qualification /= ""
                _ ->
                    Nothing
    in
    case useOfLocallyIntroducedExpressionVariablesOrLocallyIntroducedDeclaration of
        Just inferred ->
            Ok inferred

        Nothing ->
            case
                context.moduleOriginLookup.references
                    |> FastDict.get expressionReference.qualification
                    |> Maybe.andThen
                        (\inModuleLookup ->
                            inModuleLookup |> FastDict.get expressionReference.name
                        )
            of
                Nothing ->
                    Err
                        ("("
                            ++ (expressionReference.fullRange |> rangeToInfoString)
                            ++ ") "
                            ++ " could not determine the module where the reference "
                            ++ qualifiedToString
                                { qualification = expressionReference.qualification
                                , name = expressionReference.name
                                }
                            ++ " was originally declared in. I'm likely missing import information or don't know of some locally declared things."
                        )

                Just moduleOrigin ->
                    case context.declarationTypes |> FastDict.get moduleOrigin of
                        Nothing ->
                            Err
                                ("("
                                    ++ (expressionReference.fullRange |> rangeToInfoString)
                                    ++ ") "
                                    ++ "no declaration types found for the reference "
                                    ++ qualifiedToString
                                        { qualification = expressionReference.qualification
                                        , name = expressionReference.name
                                        }
                                    ++ ". I looked for some in the module "
                                    ++ moduleOrigin
                                )

                        Just originModuleDeclarationTypes ->
                            case
                                originModuleDeclarationTypes.signatures
                                    |> FastDict.get expressionReference.name
                            of
                                Just signatureType ->
                                    Ok
                                        { range = expressionReference.fullRange
                                        , value =
                                            ExpressionReference
                                                { qualification = expressionReference.qualification
                                                , moduleOrigin = moduleOrigin
                                                , name = expressionReference.name
                                                }
                                        , type_ =
                                            signatureType
                                                |> typeMapVariables
                                                    (\variable ->
                                                        { useRange = expressionReference.fullRange
                                                        , name = variable.name
                                                        }
                                                    )
                                        }

                                Nothing ->
                                    case
                                        originModuleDeclarationTypes.choiceTypes
                                            |> fastDictMapAndSmallestJust
                                                (\choiceTypeName choiceTypeInfo ->
                                                    choiceTypeInfo.variants
                                                        |> FastDict.get expressionReference.name
                                                        |> Maybe.map
                                                            (\variantValues ->
                                                                { variantValues = variantValues
                                                                , choiceTypeName = choiceTypeName
                                                                , choiceTypeParameters = choiceTypeInfo.parameters
                                                                }
                                                            )
                                                )
                                    of
                                        Just variant ->
                                            Ok
                                                { range = expressionReference.fullRange
                                                , value =
                                                    ExpressionReferenceVariant
                                                        { moduleOrigin = moduleOrigin
                                                        , choiceTypeName = variant.choiceTypeName
                                                        , qualification = expressionReference.qualification
                                                        , name = expressionReference.name
                                                        }
                                                , type_ =
                                                    variant.variantValues
                                                        |> List.foldr
                                                            (\argument output ->
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            argument
                                                                                |> typeMapVariables
                                                                                    (\variable ->
                                                                                        { useRange = expressionReference.fullRange
                                                                                        , name = variable.name
                                                                                        }
                                                                                    )
                                                                        , output = output
                                                                        }
                                                                    )
                                                            )
                                                            (TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin = moduleOrigin
                                                                    , name = variant.choiceTypeName
                                                                    , arguments =
                                                                        variant.choiceTypeParameters
                                                                            |> List.map
                                                                                (\parameter ->
                                                                                    TypeVariable
                                                                                        { useRange = expressionReference.fullRange
                                                                                        , name = parameter
                                                                                        }
                                                                                )
                                                                    }
                                                                )
                                                            )
                                                }

                                        Nothing ->
                                            case originModuleDeclarationTypes.typeAliases |> FastDict.get expressionReference.name of
                                                Nothing ->
                                                    Err
                                                        ("("
                                                            ++ (expressionReference.fullRange |> rangeToInfoString)
                                                            ++ ") "
                                                            ++ "no value/function/port/variant/record type alias constructor found in the origin module of the reference "
                                                            ++ qualifiedToString
                                                                { qualification = moduleOrigin, name = expressionReference.name }
                                                        )

                                                Just originTypeAliasDeclaration ->
                                                    case ( originTypeAliasDeclaration.recordFieldOrder, originTypeAliasDeclaration.type_ ) of
                                                        ( Just fieldOrder, TypeNotVariable (TypeRecord fields) ) ->
                                                            Ok
                                                                { range = expressionReference.fullRange
                                                                , value =
                                                                    ExpressionReferenceRecordTypeAliasConstructorFunction
                                                                        { qualification = expressionReference.qualification
                                                                        , moduleOrigin = moduleOrigin
                                                                        , name = expressionReference.name
                                                                        }
                                                                , type_ =
                                                                    fieldOrder
                                                                        |> List.foldr
                                                                            (\fieldName outputTypeSoFar ->
                                                                                case fields |> FastDict.get fieldName of
                                                                                    Nothing ->
                                                                                        outputTypeSoFar

                                                                                    Just fieldValueType ->
                                                                                        TypeNotVariable
                                                                                            (TypeFunction
                                                                                                { input =
                                                                                                    fieldValueType
                                                                                                        |> typeMapVariables
                                                                                                            (\variable ->
                                                                                                                { useRange = expressionReference.fullRange
                                                                                                                , name = variable.name
                                                                                                                }
                                                                                                            )
                                                                                                , output = outputTypeSoFar
                                                                                                }
                                                                                            )
                                                                            )
                                                                            (TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin = moduleOrigin
                                                                                    , name = expressionReference.name
                                                                                    , arguments =
                                                                                        originTypeAliasDeclaration.parameters
                                                                                            |> List.map
                                                                                                (\parameterName ->
                                                                                                    TypeVariable
                                                                                                        { useRange = expressionReference.fullRange
                                                                                                        , name = parameterName
                                                                                                        }
                                                                                                )
                                                                                    }
                                                                                )
                                                                            )
                                                                }

                                                        _ ->
                                                            Err
                                                                ("("
                                                                    ++ (expressionReference.fullRange |> rangeToInfoString)
                                                                    ++ ") "
                                                                    ++ "I found a type alias with the same name as the reference "
                                                                    ++ qualifiedToString
                                                                        { qualification = moduleOrigin
                                                                        , name = expressionReference.name
                                                                        }
                                                                    ++ ", so I thought you are constructing a record. However, I was unable to determine which arguments correspond to which fields"
                                                                )


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


rangeOverarching : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range
rangeOverarching a b =
    { start = locationMin a.start b.start
    , end = locationMax a.end b.end
    }


locationMin : Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location
locationMin aLocation bLocation =
    if aLocation.row - bLocation.row < 0 then
        aLocation

    else if bLocation.row - aLocation.row < 0 then
        bLocation

    else
    -- bLocation.row == aLocation.row
    if
        aLocation.column - bLocation.column < 0
    then
        aLocation

    else
        bLocation


locationMax : Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location -> Elm.Syntax.Range.Location
locationMax aLocation bLocation =
    if aLocation.row - bLocation.row > 0 then
        aLocation

    else if bLocation.row - aLocation.row > 0 then
        bLocation

    else
    -- bLocation.row == aLocation.row
    if
        aLocation.column - bLocation.column > 0
    then
        aLocation

    else
        bLocation


letDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
    ->
        Result
            String
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration
            }
letDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letDeclaration) =
    case letDeclaration of
        Elm.Syntax.Expression.LetDestructuring letDestructuringPattern letDestructuringExpression ->
            resultAndThen2
                (\patternInferred expressionInferred ->
                    Result.andThen
                        (\patternExpressionUnified ->
                            Result.map2
                                (\patternWithUnificationSubstitutionsApplied expressionWithUnificationSubstitutionsApplied ->
                                    { range = letDeclarationRange
                                    , declaration =
                                        LetDestructuring
                                            { pattern = patternWithUnificationSubstitutionsApplied
                                            , expression = expressionWithUnificationSubstitutionsApplied
                                            }
                                    }
                                )
                                (patternInferred
                                    |> patternTypedNodeApplyVariableSubstitutions
                                        context.declarationTypes
                                        patternExpressionUnified.substitutions
                                )
                                (expressionInferred
                                    |> expressionTypedNodeApplyVariableSubstitutions
                                        context.declarationTypes
                                        patternExpressionUnified.substitutions
                                )
                        )
                        (typeUnify
                            { declarationTypes = context.declarationTypes
                            , range = letDeclarationRange
                            }
                            patternInferred.type_
                            expressionInferred.type_
                        )
                )
                (letDestructuringPattern
                    |> patternTypeInfer
                        { declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        }
                )
                (letDestructuringExpression
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.LetFunction letValueOrFunction ->
            letFunctionOrValueDeclarationTypeInfer context
                (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction)


letFunctionOrValueDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Function
    ->
        Result
            String
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration
            }
letFunctionOrValueDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction) =
    let
        implementation : Elm.Syntax.Expression.FunctionImplementation
        implementation =
            letValueOrFunction.declaration |> Elm.Syntax.Node.value
    in
    Result.andThen
        (\parametersInferred ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = context.declarationTypes
                    , range = letDeclarationRange
                    }

                name : String
                name =
                    implementation.name |> Elm.Syntax.Node.value
            in
            case letValueOrFunction.signature of
                Nothing ->
                    Result.andThen
                        (\resultInferred ->
                            case implementation.arguments of
                                [] ->
                                    Ok
                                        { range = letDeclarationRange
                                        , declaration =
                                            LetValueOrFunctionDeclaration
                                                { signature = Nothing
                                                , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                , name = name
                                                , parameters = []
                                                , result = resultInferred
                                                , type_ = resultInferred.type_
                                                }
                                        }

                                _ :: _ ->
                                    Result.andThen
                                        (\substitutionsFromUnifyingParameterVariablesWithUses ->
                                            Result.map2
                                                (\parametersSubstituted resultSubstituted ->
                                                    { range = letDeclarationRange
                                                    , declaration =
                                                        LetValueOrFunctionDeclaration
                                                            { signature = Nothing
                                                            , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                            , name = name
                                                            , parameters = parametersSubstituted
                                                            , result = resultSubstituted
                                                            , type_ =
                                                                parametersSubstituted
                                                                    |> List.foldr
                                                                        (\parameter outputTypeSoFar ->
                                                                            TypeNotVariable
                                                                                (TypeFunction
                                                                                    { input = parameter.type_
                                                                                    , output = outputTypeSoFar
                                                                                    }
                                                                                )
                                                                        )
                                                                        resultSubstituted.type_
                                                            }
                                                    }
                                                )
                                                (parametersInferred.nodes
                                                    |> listFoldrWhileOkFrom []
                                                        (\parameterInferred soFar ->
                                                            Result.map
                                                                (\parameterSubstituted ->
                                                                    parameterSubstituted :: soFar
                                                                )
                                                                (parameterInferred
                                                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                        substitutionsFromUnifyingParameterVariablesWithUses
                                                                )
                                                        )
                                                )
                                                (resultInferred
                                                    |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                        substitutionsFromUnifyingParameterVariablesWithUses
                                                )
                                        )
                                        (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                            typeContext
                                            parametersInferred.introducedExpressionVariables
                                            resultInferred
                                        )
                        )
                        (implementation.expression
                            |> expressionTypeInfer
                                { declarationTypes = context.declarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , locallyIntroducedDeclarationTypes =
                                    context.locallyIntroducedDeclarationTypes
                                        |> -- elm declarations do not allow "polymorphic recursion"
                                           -- https://github.com/elm/compiler/issues/2275
                                           -- so instead of putting it in partiallyInferredDeclarationTypes
                                           -- we treat it as an introduced variable (sharing the same type variables)
                                           FastDict.remove name
                                , locallyIntroducedExpressionVariables =
                                    FastDict.union
                                        parametersInferred.introducedExpressionVariables
                                        context.locallyIntroducedExpressionVariables
                                        |> FastDict.insert name
                                            (TypeVariable
                                                { useRange =
                                                    letValueOrFunction
                                                        |> syntaxValueOrFunctionDeclarationRange
                                                , name = name
                                                }
                                            )
                                }
                        )

                Just (Elm.Syntax.Node.Node signatureRange letValueOrFunctionSignature) ->
                    Result.andThen
                        (\annotationAsType ->
                            Result.andThen
                                (\resultInferred ->
                                    Result.andThen
                                        (\typeUnifiedWithAnnotation ->
                                            -- TODO when the substituted type is more strict
                                            -- throw an error: annotation too loose
                                            Result.andThen
                                                (\fullSubstitutions ->
                                                    Result.map3
                                                        (\parametersSubstituted resultSubstituted typeSubstituted ->
                                                            { range = letDeclarationRange
                                                            , declaration =
                                                                LetValueOrFunctionDeclaration
                                                                    { signature =
                                                                        Just
                                                                            { range = signatureRange
                                                                            , nameRange =
                                                                                letValueOrFunctionSignature.name |> Elm.Syntax.Node.range
                                                                            , annotationType =
                                                                                letValueOrFunctionSignature.typeAnnotation
                                                                                    |> Elm.Syntax.Node.value
                                                                            , annotationTypeRange =
                                                                                letValueOrFunctionSignature.typeAnnotation
                                                                                    |> Elm.Syntax.Node.range
                                                                            }
                                                                    , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                    , name = name
                                                                    , parameters = parametersSubstituted
                                                                    , result = resultSubstituted
                                                                    , type_ = typeSubstituted
                                                                    }
                                                            }
                                                        )
                                                        (parametersInferred.nodes
                                                            |> listFoldrWhileOkFrom []
                                                                (\parameter soFar ->
                                                                    Result.map
                                                                        (\parameterInferredSubstituted ->
                                                                            parameterInferredSubstituted :: soFar
                                                                        )
                                                                        (parameter
                                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                                fullSubstitutions
                                                                        )
                                                                )
                                                        )
                                                        (resultInferred
                                                            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                fullSubstitutions
                                                        )
                                                        (typeUnifiedWithAnnotation.type_
                                                            |> typeApplyVariableSubstitutions
                                                                typeContext
                                                                fullSubstitutions
                                                        )
                                                )
                                                (case implementation.arguments of
                                                    [] ->
                                                        Ok typeUnifiedWithAnnotation.substitutions

                                                    _ :: _ ->
                                                        Result.andThen
                                                            (\substitutionsFromUnifyingParameterVariablesWithUses ->
                                                                variableSubstitutionsMerge typeContext
                                                                    substitutionsFromUnifyingParameterVariablesWithUses
                                                                    typeUnifiedWithAnnotation.substitutions
                                                            )
                                                            (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                                typeContext
                                                                parametersInferred.introducedExpressionVariables
                                                                resultInferred
                                                            )
                                                )
                                        )
                                        (typeUnify typeContext
                                            annotationAsType
                                            (parametersInferred.nodes
                                                |> List.foldr
                                                    (\parameterTypedNode outputSoFar ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = parameterTypedNode.type_
                                                                , output = outputSoFar
                                                                }
                                                            )
                                                    )
                                                    resultInferred.type_
                                            )
                                        )
                                )
                                (implementation.expression
                                    |> expressionTypeInfer
                                        { declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                                |> -- elm declarations do not allow "polymorphic recursion"
                                                   -- https://github.com/elm/compiler/issues/2275
                                                   -- so instead of putting it in partiallyInferredDeclarationTypes
                                                   -- we treat it as an introduced variable (sharing the same type variables)
                                                   FastDict.remove name
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                parametersInferred.introducedExpressionVariables
                                                |> FastDict.insert name
                                                    annotationAsType
                                        }
                                )
                        )
                        (letValueOrFunctionSignature.typeAnnotation
                            |> syntaxToType context.moduleOriginLookup.typeConstructs
                        )
        )
        (implementation.arguments
            |> parameterPatternsTypeInfer
                { declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


moduleNameToString : Elm.Syntax.ModuleName.ModuleName -> String
moduleNameToString moduleName =
    moduleName |> String.join "."


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


expressionInfixOperationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String Type
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , operator : String
        , left : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        , right : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    -> Result String (TypedNode Expression)
expressionInfixOperationTypeInfer context infixOperation =
    resultAndThen3
        (\operatorAsFunctionType leftInferred rightInferred ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = context.declarationTypes
                    , range = infixOperation.fullRange
                    }
            in
            resultAndThen2
                (\unifiedLeftType unifiedRightType ->
                    Result.andThen
                        (\leftRightAndUnificationSubstitutions ->
                            { range = infixOperation.fullRange
                            , value =
                                ExpressionInfixOperation
                                    { operator =
                                        { type_ =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = leftInferred.type_
                                                    , output =
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = rightInferred.type_
                                                                , output = operatorAsFunctionType.resultType
                                                                }
                                                            )
                                                    }
                                                )
                                        , moduleOrigin = operatorAsFunctionType.moduleOrigin
                                        , symbol = infixOperation.operator
                                        }
                                    , left = leftInferred
                                    , right = rightInferred
                                    }
                            , type_ = operatorAsFunctionType.resultType
                            }
                                |> expressionTypedNodeApplyVariableSubstitutions
                                    context.declarationTypes
                                    leftRightAndUnificationSubstitutions
                        )
                        (variableSubstitutionsMerge
                            typeContext
                            unifiedLeftType.substitutions
                            unifiedRightType.substitutions
                        )
                )
                (typeUnify typeContext
                    operatorAsFunctionType.leftType
                    leftInferred.type_
                )
                (typeUnify typeContext
                    operatorAsFunctionType.rightType
                    rightInferred.type_
                )
        )
        (operatorFunctionType
            { moduleOriginLookup = context.moduleOriginLookup
            , range =
                infixOperationApproximateOperatorRange
                    { operator = infixOperation.operator
                    , leftEnd = (infixOperation.left |> Elm.Syntax.Node.range).end
                    , rightStart = (infixOperation.right |> Elm.Syntax.Node.range).start
                    }
            }
            infixOperation.operator
        )
        (infixOperation.left |> expressionTypeInfer context)
        (infixOperation.right |> expressionTypeInfer context)


{-| elm-syntax should include this info (and will in v8)
This is just some stupid approximation to give better error messages
-}
infixOperationApproximateOperatorRange :
    { operator : String
    , leftEnd : Elm.Syntax.Range.Location
    , rightStart : Elm.Syntax.Range.Location
    }
    -> Elm.Syntax.Range.Range
infixOperationApproximateOperatorRange infixOperation =
    let
        operatorLength : Int
        operatorLength =
            infixOperation.operator |> String.length
    in
    if infixOperation.leftEnd.row - infixOperation.rightStart.row == 0 then
        if (infixOperation.leftEnd.column + operatorLength) - infixOperation.rightStart.column == 0 then
            -- x+y
            { start =
                { row = infixOperation.rightStart.row
                , column = infixOperation.leftEnd.column
                }
            , end =
                { row = infixOperation.rightStart.row
                , column = infixOperation.rightStart.column
                }
            }

        else
            -- assume
            -- x + y
            { start =
                { row = infixOperation.rightStart.row
                , column =
                    infixOperation.rightStart.column
                        - 1
                        - operatorLength
                }
            , end =
                { row = infixOperation.rightStart.row
                , column =
                    infixOperation.rightStart.column - 1
                }
            }

    else
        -- assume
        -- x
        --     + y
        { start =
            { row = infixOperation.rightStart.row
            , column =
                infixOperation.rightStart.column
                    - 1
                    - operatorLength
            }
        , end =
            { row = infixOperation.rightStart.row
            , column =
                infixOperation.rightStart.column - 1
            }
        }


operatorFunctionType :
    { range : Elm.Syntax.Range.Range
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> String
    ->
        Result
            String
            { moduleOrigin : String
            , leftType : Type
            , rightType : Type
            , resultType : Type
            }
operatorFunctionType context operator =
    case operator of
        "|>" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = a
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , resultType = b
                }

        "<|" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , rightType = a
                , resultType = b
                }

        ">>" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }

                c : Type
                c =
                    TypeVariable { useRange = context.range, name = "c" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = b
                            , output = c
                            }
                        )
                , resultType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = c
                            }
                        )
                }

        "<<" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }

                c : Type
                c =
                    TypeVariable { useRange = context.range, name = "c" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType =
                    TypeNotVariable
                        (TypeFunction
                            { input = b
                            , output = c
                            }
                        )
                , rightType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = b
                            }
                        )
                , resultType =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output = c
                            }
                        )
                }

        "++" ->
            let
                appendable : Type
                appendable =
                    TypeVariable { useRange = context.range, name = "appendable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = appendable
                , rightType = appendable
                , resultType = appendable
                }

        "==" ->
            let
                equatable : Type
                equatable =
                    TypeVariable { useRange = context.range, name = "equatable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = equatable
                , rightType = equatable
                , resultType = typeBasicsBool
                }

        "/=" ->
            let
                equatable : Type
                equatable =
                    TypeVariable { useRange = context.range, name = "equatable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = equatable
                , rightType = equatable
                , resultType = typeBasicsBool
                }

        "::" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "element" }
            in
            Ok
                { moduleOrigin = "List"
                , leftType = a
                , rightType = typeListList a
                , resultType = typeListList a
                }

        "*" ->
            let
                number : Type
                number =
                    TypeVariable { useRange = context.range, name = "number" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "+" ->
            let
                number : Type
                number =
                    TypeVariable { useRange = context.range, name = "number" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "-" ->
            let
                number : Type
                number =
                    TypeVariable { useRange = context.range, name = "number" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "/" ->
            okFdivOperatorInfo

        "^" ->
            let
                number : Type
                number =
                    TypeVariable { useRange = context.range, name = "number" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = number
                , rightType = number
                , resultType = number
                }

        "<=" ->
            let
                comparable : Type
                comparable =
                    TypeVariable { useRange = context.range, name = "comparable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        ">=" ->
            let
                comparable : Type
                comparable =
                    TypeVariable { useRange = context.range, name = "comparable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        ">" ->
            let
                comparable : Type
                comparable =
                    TypeVariable { useRange = context.range, name = "comparable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        "<" ->
            let
                comparable : Type
                comparable =
                    TypeVariable { useRange = context.range, name = "comparable" }
            in
            Ok
                { moduleOrigin = "Basics"
                , leftType = comparable
                , rightType = comparable
                , resultType = typeBasicsBool
                }

        "//" ->
            okIdivOperatorInfo

        "&&" ->
            okAndOperatorInfo

        "||" ->
            okOrOperatorInfo

        "|." ->
            Ok
                (if context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type
                        varContext =
                            TypeVariable { useRange = context.range, name = "context" }

                        problem : Type
                        problem =
                            TypeVariable { useRange = context.range, name = "problem" }

                        keep : Type
                        keep =
                            TypeVariable { useRange = context.range, name = "keep" }

                        ignore : Type
                        ignore =
                            TypeVariable { useRange = context.range, name = "ignore" }
                    in
                    { moduleOrigin = "Parser.Advanced"
                    , leftType = typeParserAdvancedParser varContext problem keep
                    , rightType = typeParserAdvancedParser varContext problem ignore
                    , resultType = typeParserAdvancedParser varContext problem keep
                    }

                 else
                    let
                        keep : Type
                        keep =
                            TypeVariable { useRange = context.range, name = "keep" }

                        ignore : Type
                        ignore =
                            TypeVariable { useRange = context.range, name = "ignore" }
                    in
                    { moduleOrigin = "Parser"
                    , leftType = typeParserParser keep
                    , rightType = typeParserParser ignore
                    , resultType = typeParserParser keep
                    }
                )

        "|=" ->
            Ok
                (if context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type
                        varContext =
                            TypeVariable { useRange = context.range, name = "context" }

                        problem : Type
                        problem =
                            TypeVariable { useRange = context.range, name = "problem" }

                        a : Type
                        a =
                            TypeVariable { useRange = context.range, name = "a" }

                        b : Type
                        b =
                            TypeVariable { useRange = context.range, name = "b" }
                    in
                    { moduleOrigin = "Parser.Advanced"
                    , leftType =
                        typeParserAdvancedParser
                            varContext
                            problem
                            (TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                            )
                    , rightType = typeParserAdvancedParser varContext problem a
                    , resultType = typeParserAdvancedParser varContext problem b
                    }

                 else
                    let
                        a : Type
                        a =
                            TypeVariable { useRange = context.range, name = "a" }

                        b : Type
                        b =
                            TypeVariable { useRange = context.range, name = "b" }
                    in
                    { moduleOrigin = "Parser"
                    , leftType =
                        typeParserParser
                            (TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                            )
                    , rightType = typeParserParser a
                    , resultType = typeParserParser b
                    }
                )

        "</>" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }

                c : Type
                c =
                    TypeVariable { useRange = context.range, name = "c" }
            in
            Ok
                { moduleOrigin = "Url.Parser"
                , leftType = typeUrlParserParser a b
                , rightType = typeUrlParserParser b c
                , resultType = typeUrlParserParser a c
                }

        "<?>" ->
            let
                a : Type
                a =
                    TypeVariable { useRange = context.range, name = "a" }

                b : Type
                b =
                    TypeVariable { useRange = context.range, name = "b" }

                query : Type
                query =
                    TypeVariable { useRange = context.range, name = "query" }
            in
            Ok
                { moduleOrigin = "Url.Parser"
                , leftType =
                    typeUrlParserParser
                        a
                        (TypeNotVariable
                            (TypeFunction
                                { input = query
                                , output = b
                                }
                            )
                        )
                , rightType = typeUrlParserQueryParser query
                , resultType = typeUrlParserParser a b
                }

        unknownOperator ->
            Err
                ("("
                    ++ (context.range |> rangeToInfoString)
                    ++ ") "
                    ++ "unknown operator ("
                    ++ unknownOperator
                    ++ ")"
                )


okIdivOperatorInfo :
    Result
        error_
        { moduleOrigin : String
        , leftType : Type
        , rightType : Type
        , resultType : Type
        }
okIdivOperatorInfo =
    Ok
        { moduleOrigin = "Basics"
        , leftType = typeBasicsInt
        , rightType = typeBasicsInt
        , resultType = typeBasicsInt
        }


okFdivOperatorInfo :
    Result
        error_
        { moduleOrigin : String
        , leftType : Type
        , rightType : Type
        , resultType : Type
        }
okFdivOperatorInfo =
    Ok
        { moduleOrigin = "Basics"
        , leftType = typeBasicsFloat
        , rightType = typeBasicsFloat
        , resultType = typeBasicsFloat
        }


okOrOperatorInfo :
    Result
        error_
        { moduleOrigin : String
        , leftType : Type
        , rightType : Type
        , resultType : Type
        }
okOrOperatorInfo =
    Ok
        { moduleOrigin = "Basics"
        , leftType = typeBasicsBool
        , rightType = typeBasicsBool
        , resultType = typeBasicsBool
        }


okAndOperatorInfo :
    Result
        error_
        { moduleOrigin : String
        , leftType : Type
        , rightType : Type
        , resultType : Type
        }
okAndOperatorInfo =
    Ok
        { moduleOrigin = "Basics"
        , leftType = typeBasicsBool
        , rightType = typeBasicsBool
        , resultType = typeBasicsBool
        }


{-| Infer types of
value/[`Elm.Syntax.Expression.Function`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Function) declarations
in a module.

    import Elm.Syntax.Node
    import Elm.Syntax.Expression
    import ElmSyntaxTypeInfer


    [ { declaration =
            Elm.Syntax.Node.empty
                { name = Elm.Syntax.Node.empty "hello"
                , expression =
                    Elm.Syntax.Node.empty
                        (Elm.Syntax.Expression.Literal "world")
                , arguments = []
                }
      , signature = Nothing
      , documentation = Nothing
      }
    ]
        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
            { importedTypes = ElmSyntaxTypeInfer.elmCoreTypes
            , moduleOriginLookup = exampleModuleOriginLookup
            , otherModuleDeclaredTypes =
                []
                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                        exampleModuleOriginLookup
                    |> .types
            }
    -->
    Ok
        (FastDict.singleton "hello"
            { type_ =
                ElmSyntaxTypeInfer.TypeNotVariable
                    (ElmSyntaxTypeInfer.TypeConstruct
                        { moduleOrigin = [ "String" ], name = "String", arguments = [] }
                    )
            ...
            }
        )


    exampleModuleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
    exampleModuleOriginLookup =
        []
            |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                ElmSyntaxTypeInfer.elmCoreTypes

See [`ModuleTypes`](#ModuleTypes) and [`ModuleOriginLookup`](#ModuleOriginLookup)

Warning! Always first verify that provided type alias declarations aren't (mutually) recursive.
Otherwise this function might never terminate.

-}
valueAndFunctionDeclarations :
    { moduleName : String
    , importedTypes :
        FastDict.Dict String ModuleTypes
    , moduleOriginLookup : ModuleOriginLookup
    , otherModuleDeclaredTypes : ModuleTypes
    }
    -> List Elm.Syntax.Expression.Function
    ->
        Result
            String
            (FastDict.Dict
                String
                { parameters :
                    List (TypedNode Pattern)
                , result : TypedNode Expression
                , type_ : Type
                , nameRange : Elm.Syntax.Range.Range
                , documentation :
                    Maybe
                        { content : String
                        , range : Elm.Syntax.Range.Range
                        }
                , signature :
                    Maybe
                        { range : Elm.Syntax.Range.Range
                        , nameRange : Elm.Syntax.Range.Range
                        , annotationTypeRange : Elm.Syntax.Range.Range
                        , -- variables names in here might not correspond
                          -- with those in .type_
                          annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                        }
                }
            )
valueAndFunctionDeclarations context syntaxValueAndFunctionDeclarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            { keepOperatorIsExposedFromParserAdvanced =
                context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced
            , ignoreOperatorIsExposedFromParserAdvanced =
                context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced
            , typeConstructs =
                context.moduleOriginLookup.typeConstructs
                    |> FastDict.update ""
                        (\existingExposedTypeConstructs ->
                            context.otherModuleDeclaredTypes.choiceTypes
                                |> FastDict.foldl
                                    (\choiceTypeName _ soFar ->
                                        soFar
                                            |> FastDict.insert choiceTypeName
                                                context.moduleName
                                    )
                                    (context.otherModuleDeclaredTypes.typeAliases
                                        |> FastDict.foldl
                                            (\typeAliasName _ soFar ->
                                                soFar
                                                    |> FastDict.insert typeAliasName
                                                        context.moduleName
                                            )
                                            (existingExposedTypeConstructs
                                                |> Maybe.withDefault FastDict.empty
                                            )
                                    )
                                |> Just
                        )
            , references =
                context.moduleOriginLookup.references
                    |> FastDict.update ""
                        (\existingExposedReferences ->
                            context.otherModuleDeclaredTypes.choiceTypes
                                |> FastDict.foldl
                                    (\_ info soFar ->
                                        info.variants
                                            |> FastDict.foldl
                                                (\variantName _ soFarWithVariantNames ->
                                                    soFarWithVariantNames
                                                        |> FastDict.insert variantName
                                                            context.moduleName
                                                )
                                                soFar
                                    )
                                    (context.otherModuleDeclaredTypes.typeAliases
                                        |> FastDict.foldl
                                            (\typeAliasName info soFar ->
                                                case info.recordFieldOrder of
                                                    Nothing ->
                                                        soFar

                                                    Just _ ->
                                                        soFar
                                                            |> FastDict.insert typeAliasName
                                                                context.moduleName
                                            )
                                            (context.otherModuleDeclaredTypes.signatures
                                                |> FastDict.foldl
                                                    (\signatureName _ soFar ->
                                                        soFar
                                                            |> FastDict.insert signatureName
                                                                context.moduleName
                                                    )
                                                    (syntaxValueAndFunctionDeclarations
                                                        |> List.foldl
                                                            (\valueOrFunctionDeclaration soFar ->
                                                                soFar
                                                                    |> FastDict.insert
                                                                        ((valueOrFunctionDeclaration.declaration
                                                                            |> Elm.Syntax.Node.value
                                                                         ).name
                                                                            |> Elm.Syntax.Node.value
                                                                        )
                                                                        context.moduleName
                                                            )
                                                            (existingExposedReferences
                                                                |> Maybe.withDefault FastDict.empty
                                                            )
                                                    )
                                            )
                                    )
                                |> Just
                        )
            }

        acrossValueAndFunctionDeclarationsToInfer :
            { unannotatedInferredDeclarationTypes :
                FastDict.Dict
                    String
                    { type_ : Type
                    , range : Elm.Syntax.Range.Range
                    , moduleLevel : String
                    }
            , annotated : FastDict.Dict String Type
            }
        acrossValueAndFunctionDeclarationsToInfer =
            syntaxValueAndFunctionDeclarations
                |> List.foldl
                    (\syntaxValueOrFunctionDeclaration soFar ->
                        let
                            name : String
                            name =
                                (syntaxValueOrFunctionDeclaration.declaration
                                    |> Elm.Syntax.Node.value
                                ).name
                                    |> Elm.Syntax.Node.value
                        in
                        case syntaxValueOrFunctionDeclaration.signature of
                            Nothing ->
                                let
                                    declarationRange : Elm.Syntax.Range.Range
                                    declarationRange =
                                        syntaxValueOrFunctionDeclaration
                                            |> syntaxValueOrFunctionDeclarationRange
                                in
                                { annotated = soFar.annotated
                                , unannotatedInferredDeclarationTypes =
                                    soFar.unannotatedInferredDeclarationTypes
                                        |> FastDict.insert name
                                            { type_ =
                                                TypeVariable
                                                    { useRange = declarationRange
                                                    , name = name
                                                    }
                                            , range = declarationRange
                                            , moduleLevel = context.moduleName
                                            }
                                }

                            Just (Elm.Syntax.Node.Node _ signature) ->
                                case
                                    signature.typeAnnotation
                                        |> syntaxToType moduleOriginLookup.typeConstructs
                                of
                                    Err _ ->
                                        -- error will be reported later
                                        soFar

                                    Ok type_ ->
                                        { unannotatedInferredDeclarationTypes =
                                            soFar.unannotatedInferredDeclarationTypes
                                        , annotated =
                                            soFar.annotated
                                                |> FastDict.insert name type_
                                        }
                    )
                    unannotatedInferredDeclarationTypesEmptyAndAnnotatedEmpty

        declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        declarationTypes =
            context.importedTypes
                |> FastDict.insert context.moduleName
                    { signatures =
                        FastDict.union
                            context.otherModuleDeclaredTypes.signatures
                            acrossValueAndFunctionDeclarationsToInfer.annotated
                    , typeAliases = context.otherModuleDeclaredTypes.typeAliases
                    , choiceTypes = context.otherModuleDeclaredTypes.choiceTypes
                    }

        parameterPatternsContext :
            { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
            , moduleOriginLookup : ModuleOriginLookup
            }
        parameterPatternsContext =
            { declarationTypes = declarationTypes
            , moduleOriginLookup = moduleOriginLookup
            }
    in
    syntaxValueAndFunctionDeclarations
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\valueOrFunctionDeclarationToInfer soFar ->
                let
                    implementation : Elm.Syntax.Expression.FunctionImplementation
                    implementation =
                        valueOrFunctionDeclarationToInfer.declaration
                            |> Elm.Syntax.Node.value

                    name : String
                    name =
                        implementation.name |> Elm.Syntax.Node.value
                in
                Result.andThen
                    (\parametersInferred ->
                        let
                            valueOrFunctionDeclarationToInferRange : Elm.Syntax.Range.Range
                            valueOrFunctionDeclarationToInferRange =
                                valueOrFunctionDeclarationToInfer
                                    |> syntaxValueOrFunctionDeclarationRange

                            maybeDocumentationAndRange : Maybe { range : Elm.Syntax.Range.Range, content : String }
                            maybeDocumentationAndRange =
                                case valueOrFunctionDeclarationToInfer.documentation of
                                    Nothing ->
                                        Nothing

                                    Just (Elm.Syntax.Node.Node documentationRange documentationContent) ->
                                        Just
                                            { range = documentationRange
                                            , content = documentationContent
                                            }

                            typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                            typeContext =
                                { declarationTypes = declarationTypes
                                , range = valueOrFunctionDeclarationToInferRange
                                }
                        in
                        case valueOrFunctionDeclarationToInfer.signature of
                            Nothing ->
                                Result.andThen
                                    (\resultInferred ->
                                        case parametersInferred.nodes of
                                            [] ->
                                                Ok
                                                    (soFar
                                                        |> FastDict.insert name
                                                            { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                            , documentation = maybeDocumentationAndRange
                                                            , signature = Nothing
                                                            , result = resultInferred
                                                            , type_ =
                                                                parametersInferred.nodes
                                                                    |> List.foldr
                                                                        (\parameterTypedNode typeSoFar ->
                                                                            TypeNotVariable
                                                                                (TypeFunction
                                                                                    { input = parameterTypedNode.type_
                                                                                    , output = typeSoFar
                                                                                    }
                                                                                )
                                                                        )
                                                                        resultInferred.type_
                                                            , parameters = parametersInferred.nodes
                                                            }
                                                    )

                                            _ :: _ ->
                                                Result.andThen
                                                    (\parameterPatternVariablesAndUsesUnificationSubstitutions ->
                                                        Result.map2
                                                            (\resultSubstituted parametersSubstituted ->
                                                                soFar
                                                                    |> FastDict.insert name
                                                                        { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                        , documentation = maybeDocumentationAndRange
                                                                        , signature = Nothing
                                                                        , result = resultSubstituted
                                                                        , type_ =
                                                                            parametersSubstituted
                                                                                |> List.foldr
                                                                                    (\parameterTypedNode typeSoFar ->
                                                                                        TypeNotVariable
                                                                                            (TypeFunction
                                                                                                { input = parameterTypedNode.type_
                                                                                                , output = typeSoFar
                                                                                                }
                                                                                            )
                                                                                    )
                                                                                    resultSubstituted.type_
                                                                        , parameters = parametersSubstituted
                                                                        }
                                                            )
                                                            (resultInferred
                                                                |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                                    parameterPatternVariablesAndUsesUnificationSubstitutions
                                                            )
                                                            (parametersInferred.nodes
                                                                |> listFoldrWhileOkFrom []
                                                                    (\parameterInferred parametersSubstitutedSoFar ->
                                                                        Result.map
                                                                            (\parameterSubstituted ->
                                                                                parameterSubstituted :: parametersSubstitutedSoFar
                                                                            )
                                                                            (parameterInferred
                                                                                |> patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                                                    parameterPatternVariablesAndUsesUnificationSubstitutions
                                                                            )
                                                                    )
                                                            )
                                                    )
                                                    (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                        typeContext
                                                        (parametersInferred.nodes
                                                            |> listMapToFastDictsAndUnify
                                                                patternTypedNodeIntroducedVariables
                                                        )
                                                        resultInferred
                                                    )
                                    )
                                    (implementation.expression
                                        |> expressionTypeInfer
                                            { declarationTypes = declarationTypes
                                            , locallyIntroducedExpressionVariables =
                                                -- elm declarations do not allow "polymorphic recursion"
                                                -- https://github.com/elm/compiler/issues/2275
                                                -- so instead of putting it in partiallyInferredDeclarationTypes
                                                -- we treat it as an introduced variable (sharing the same type variables)
                                                parametersInferred.introducedExpressionVariables
                                                    |> FastDict.insert name
                                                        (TypeVariable
                                                            { useRange = valueOrFunctionDeclarationToInferRange
                                                            , name = name
                                                            }
                                                        )
                                            , locallyIntroducedDeclarationTypes =
                                                acrossValueAndFunctionDeclarationsToInfer.unannotatedInferredDeclarationTypes
                                                    |> FastDict.remove name
                                            , moduleOriginLookup = moduleOriginLookup
                                            }
                                    )

                            Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                case
                                    acrossValueAndFunctionDeclarationsToInfer.annotated
                                        |> FastDict.get name
                                of
                                    Nothing ->
                                        Err
                                            ("bug in elm-syntax-type-infer: failed to retrieve annotation type for "
                                                ++ name
                                            )

                                    Just annotationType ->
                                        Result.andThen
                                            (\resultInferred ->
                                                let
                                                    inferredFullType : Type
                                                    inferredFullType =
                                                        parametersInferred.nodes
                                                            |> List.foldr
                                                                (\parameterTypedNode typeSoFar ->
                                                                    TypeNotVariable
                                                                        (TypeFunction
                                                                            { input = parameterTypedNode.type_
                                                                            , output = typeSoFar
                                                                            }
                                                                        )
                                                                )
                                                                resultInferred.type_
                                                in
                                                resultAndThen2
                                                    (\inferredDeclarationTypeUnifiedWithAnnotation substitutionsFromUnifyingParameterVariablesWithUses ->
                                                        -- TODO when the substituted type is more strict
                                                        -- throw an error: annotation too loose
                                                        Result.andThen
                                                            (\fullSubstitutions ->
                                                                Result.map3
                                                                    (\typeSubstituted resultSubstituted parametersSubstituted ->
                                                                        soFar
                                                                            |> FastDict.insert name
                                                                                { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                                , documentation = maybeDocumentationAndRange
                                                                                , signature =
                                                                                    Just
                                                                                        { range = signatureRange
                                                                                        , nameRange = signature.name |> Elm.Syntax.Node.range
                                                                                        , annotationType = signature.typeAnnotation |> Elm.Syntax.Node.value
                                                                                        , annotationTypeRange = signature.typeAnnotation |> Elm.Syntax.Node.range
                                                                                        }
                                                                                , result = resultSubstituted
                                                                                , type_ = typeSubstituted
                                                                                , parameters = parametersSubstituted
                                                                                }
                                                                    )
                                                                    (annotationType
                                                                        |> typeApplyVariableSubstitutions
                                                                            typeContext
                                                                            fullSubstitutions
                                                                    )
                                                                    (resultInferred
                                                                        |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                                            fullSubstitutions
                                                                    )
                                                                    (parametersInferred.nodes
                                                                        |> listFoldrWhileOkFrom []
                                                                            (\parameterInferred parametersSubstitutedSoFar ->
                                                                                Result.map
                                                                                    (\parameterSubstituted ->
                                                                                        parameterSubstituted :: parametersSubstitutedSoFar
                                                                                    )
                                                                                    (parameterInferred
                                                                                        |> patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                                                            fullSubstitutions
                                                                                    )
                                                                            )
                                                                    )
                                                            )
                                                            (variableSubstitutionsMerge
                                                                typeContext
                                                                substitutionsFromUnifyingParameterVariablesWithUses
                                                                inferredDeclarationTypeUnifiedWithAnnotation.substitutions
                                                            )
                                                    )
                                                    (typeUnify typeContext
                                                        annotationType
                                                        inferredFullType
                                                    )
                                                    (substitutionsForUnifyingIntroducedVariableTypesWithUsesInExpression
                                                        typeContext
                                                        parametersInferred.introducedExpressionVariables
                                                        resultInferred
                                                    )
                                            )
                                            (implementation.expression
                                                |> expressionTypeInfer
                                                    { declarationTypes = declarationTypes
                                                    , locallyIntroducedExpressionVariables =
                                                        parametersInferred.nodes
                                                            |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                                    , locallyIntroducedDeclarationTypes =
                                                        acrossValueAndFunctionDeclarationsToInfer.unannotatedInferredDeclarationTypes
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    }
                                            )
                    )
                    (implementation.arguments
                        |> parameterPatternsTypeInfer
                            parameterPatternsContext
                    )
                    |> Result.mapError
                        (\inferError ->
                            "inferring the value/function declaration "
                                ++ name
                                ++ ": "
                                ++ inferError
                        )
            )
        |> Result.andThen
            (\declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations ->
                if
                    acrossValueAndFunctionDeclarationsToInfer.unannotatedInferredDeclarationTypes
                        |> FastDict.isEmpty
                then
                    Ok declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations

                else
                    let
                        unannotatedDeclarationTypes :
                            FastDict.Dict
                                String
                                { range : Elm.Syntax.Range.Range
                                , type_ : Type
                                }
                        unannotatedDeclarationTypes =
                            declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                                |> FastDict.foldl
                                    (\declarationName declaration soFar ->
                                        case declaration.signature of
                                            Just _ ->
                                                soFar

                                            Nothing ->
                                                soFar
                                                    |> FastDict.insert declarationName
                                                        { type_ = declaration.type_
                                                        , range =
                                                            declaration
                                                                |> valueOrFunctionDeclarationInfoRange
                                                        }
                                    )
                                    FastDict.empty
                    in
                    -- TODO optimization: if declaration is annotated, apply subs directly
                    Result.andThen
                        (\substitutionsForInstanceUnifyingUnannotatedDeclarationTypesWithUses ->
                            declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                                |> valueAndFunctionDeclarationsApplyVariableSubstitutions
                                    declarationTypes
                                    substitutionsForInstanceUnifyingUnannotatedDeclarationTypesWithUses
                        )
                        (declarationsInferredIndependentOfOtherLocalUnannotatedDeclarations
                            |> fastDictFoldlWhileOkFrom
                                variableSubstitutionsNone
                                (\_ declarationInfo soFar ->
                                    Result.andThen
                                        (\resultSubstitutions ->
                                            variableSubstitutionsMerge
                                                { declarationTypes = declarationTypes
                                                , range = everywhereRange
                                                }
                                                soFar
                                                resultSubstitutions
                                        )
                                        (declarationInfo.result
                                            |> substitutionsForInstanceUnifyingModuleDeclaredTypesWithUsesInExpression
                                                { declarationTypes = declarationTypes
                                                , range = declarationInfo |> valueOrFunctionDeclarationInfoRange
                                                }
                                                unannotatedDeclarationTypes
                                        )
                                )
                        )
            )
        |> Result.map
            (\fullySubstitutedDeclarationsTypedWithContext ->
                fullySubstitutedDeclarationsTypedWithContext
                    |> FastDict.map
                        (\_ declaration ->
                            declaration |> declarationValueOrFunctionInfoDisambiguateTypeVariables
                        )
            )


syntaxValueOrFunctionDeclarationRange : Elm.Syntax.Expression.Function -> Elm.Syntax.Range.Range
syntaxValueOrFunctionDeclarationRange syntaxValueOrFunctionDeclaration =
    { start =
        case syntaxValueOrFunctionDeclaration.documentation of
            Just (Elm.Syntax.Node.Node documentationRange _) ->
                documentationRange.start

            Nothing ->
                case syntaxValueOrFunctionDeclaration.signature of
                    Just (Elm.Syntax.Node.Node signatureRange _) ->
                        signatureRange.start

                    Nothing ->
                        (syntaxValueOrFunctionDeclaration.declaration
                            |> Elm.Syntax.Node.range
                        ).start
    , end =
        (syntaxValueOrFunctionDeclaration.declaration
            |> Elm.Syntax.Node.range
        ).end
    }


valueAndFunctionDeclarationsApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo Type)
    ->
        Result
            String
            (FastDict.Dict
                String
                (ValueOrFunctionDeclarationInfo Type)
            )
valueAndFunctionDeclarationsApplyVariableSubstitutions declarationTypes substitutionsToApply valueAndFunctionDeclarationsSoFar =
    if
        (substitutionsToApply.variableToType |> DictByTypeVariableFromContext.isEmpty)
            && (substitutionsToApply.equivalentVariables |> List.isEmpty)
    then
        Ok valueAndFunctionDeclarationsSoFar

    else
        let
            everywhereTypeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
            everywhereTypeContext =
                { declarationTypes = declarationTypes
                , range = everywhereRange
                }
        in
        case
            createBatchOfSubstitutionsToApply
                everywhereTypeContext
                substitutionsToApply
        of
            Err error ->
                Err error

            Ok batchOfSubstitutionsToApply ->
                case
                    valueAndFunctionDeclarationsSoFar
                        |> valueAndFunctionDeclarationsSubstituteVariableByType
                            declarationTypes
                            batchOfSubstitutionsToApply.substituteVariableByType
                of
                    Err error ->
                        Err error

                    Ok valueAndFunctionDeclarationsSubstituted ->
                        let
                            moduleLevelPartiallyInferredDeclarations :
                                FastDict.Dict
                                    String
                                    { range : Elm.Syntax.Range.Range
                                    , type_ : Type
                                    }
                            moduleLevelPartiallyInferredDeclarations =
                                valueAndFunctionDeclarationsSoFar
                                    |> valueAndFunctionDeclarationsGetPartiallyInferred

                            allPartiallyInferredDeclarationsAndUsesAfterSubstitution :
                                FastDict.Dict
                                    String
                                    (Rope
                                        Elm.Syntax.Range.Range
                                        Type
                                    )
                            allPartiallyInferredDeclarationsAndUsesAfterSubstitution =
                                valueAndFunctionDeclarationsSubstituted.declarations
                                    |> valueAndFunctionDeclarationsUsesOfLocalReferences
                                        moduleLevelPartiallyInferredDeclarations

                            substitutionsOfPartiallyInferredDeclarationUses :
                                List
                                    { uses :
                                        Rope
                                            Elm.Syntax.Range.Range
                                            Type
                                    , partiallyInferredDeclarationType : Type
                                    }
                            substitutionsOfPartiallyInferredDeclarationUses =
                                allPartiallyInferredDeclarationsAndUsesAfterSubstitution
                                    |> FastDict.foldl
                                        (\unannotatedInferredDeclarationName uses soFar ->
                                            case valueAndFunctionDeclarationsSubstituted.declarations |> FastDict.get unannotatedInferredDeclarationName of
                                                Nothing ->
                                                    soFar

                                                Just inferredDeclarationAfterSubstituting ->
                                                    if
                                                        valueAndFunctionDeclarationsSubstituted.unchangedDeclarations
                                                            |> Set.member unannotatedInferredDeclarationName
                                                    then
                                                        { uses = uses
                                                        , partiallyInferredDeclarationType =
                                                            inferredDeclarationAfterSubstituting.type_
                                                        }
                                                            :: soFar

                                                    else
                                                        soFar
                                        )
                                        []

                            updatePartiallyInferredSubstitutionsOrError : Result String VariableSubstitutions
                            updatePartiallyInferredSubstitutionsOrError =
                                substitutionsOfPartiallyInferredDeclarationUses
                                    |> listFoldlWhileOkFrom
                                        variableSubstitutionsNone
                                        (\substitutionOfPartiallyInferredDeclaration substitutionsSoFar ->
                                            substitutionOfPartiallyInferredDeclaration.uses
                                                |> ropeFoldlWhileOkFrom
                                                    substitutionsSoFar
                                                    (\useRange useType unificationSubstitutionsWithUsesSoFar ->
                                                        let
                                                            partialTypeNewInstance : Type
                                                            partialTypeNewInstance =
                                                                substitutionOfPartiallyInferredDeclaration.partiallyInferredDeclarationType
                                                                    |> typeMapVariables
                                                                        (\declarationTypeVariable ->
                                                                            { useRange = useRange
                                                                            , name = declarationTypeVariable.name
                                                                            }
                                                                        )
                                                        in
                                                        Result.andThen
                                                            (\unified ->
                                                                variableSubstitutionsMerge
                                                                    everywhereTypeContext
                                                                    unificationSubstitutionsWithUsesSoFar
                                                                    unified.substitutions
                                                            )
                                                            (typeUnify everywhereTypeContext
                                                                partialTypeNewInstance
                                                                useType
                                                            )
                                                    )
                                        )
                        in
                        case updatePartiallyInferredSubstitutionsOrError of
                            Err error ->
                                Err error

                            Ok updatePartiallyInferredSubstitutions ->
                                case
                                    variableSubstitutionsMerge3
                                        everywhereTypeContext
                                        valueAndFunctionDeclarationsSubstituted.substitutions
                                        updatePartiallyInferredSubstitutions
                                        { variableToType = DictByTypeVariableFromContext.empty
                                        , equivalentVariables = batchOfSubstitutionsToApply.newEquivalentVariables
                                        }
                                of
                                    Err error ->
                                        Err error

                                    Ok substitutionsAfterSubstitution ->
                                        valueAndFunctionDeclarationsApplyVariableSubstitutions
                                            declarationTypes
                                            substitutionsAfterSubstitution
                                            valueAndFunctionDeclarationsSubstituted.declarations


unannotatedInferredDeclarationTypesEmptyAndAnnotatedEmpty :
    { unannotatedInferredDeclarationTypes :
        FastDict.Dict
            String
            { type_ : Type
            , range : Elm.Syntax.Range.Range
            , moduleLevel : String
            }
    , annotated : FastDict.Dict String Type
    }
unannotatedInferredDeclarationTypesEmptyAndAnnotatedEmpty =
    { unannotatedInferredDeclarationTypes = FastDict.empty
    , annotated = FastDict.empty
    }


variableSubstitutionsFromVariableToType :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeVariableFromContext
    -> Type
    -> Result String VariableSubstitutions
variableSubstitutionsFromVariableToType declarationsTypes variableToReplace replacementType =
    case replacementType of
        TypeNotVariable replacementTypeNotVariable ->
            variableSubstitutionsFromVariableToTypeNotVariableOrError declarationsTypes
                variableToReplace
                replacementTypeNotVariable

        TypeVariable replacementVariable ->
            variableSubstitutionsFrom2EquivalentVariables
                variableToReplace
                replacementVariable


variableSubstitutionsFrom2EquivalentVariables :
    TypeVariableFromContext
    -> TypeVariableFromContext
    -> Result String VariableSubstitutions
variableSubstitutionsFrom2EquivalentVariables aVariable bVariable =
    if TypeVariableFromContext.equals aVariable bVariable then
        okVariableSubstitutionsNone

    else
        Result.map
            (\abConstraint ->
                { variableToType = DictByTypeVariableFromContext.empty
                , equivalentVariables =
                    [ { variables =
                            DictByTypeVariableFromContext.twoDistinct aVariable () bVariable ()
                      , constraint = abConstraint
                      , overarchingUseRange =
                            rangeOverarching
                                aVariable.useRange
                                bVariable.useRange
                      }
                    ]
                }
            )
            (maybeTypeVariableConstraintMerge
                (aVariable.name |> typeVariableConstraint)
                (bVariable.name |> typeVariableConstraint)
            )


type alias ValueOrFunctionDeclarationInfo type_ =
    { nameRange : Elm.Syntax.Range.Range
    , documentation :
        Maybe
            { content : String
            , range : Elm.Syntax.Range.Range
            }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , -- variables names in here might not correspond
              -- with those in .type_
              annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters :
        List (TypedNode Pattern)
    , result : TypedNode Expression
    , type_ : type_
    }


type alias ModuleLevelDeclarationTypesAvailableInModule =
    FastDict.Dict String ModuleTypes


declarationValueOrFunctionInfoDisambiguateTypeVariables :
    ValueOrFunctionDeclarationInfo Type
    -> ValueOrFunctionDeclarationInfo Type
declarationValueOrFunctionInfoDisambiguateTypeVariables declarationValueOrFunctionInfo =
    let
        globalTypeVariableDisambiguationLookup : DictByTypeVariableFromContext String
        globalTypeVariableDisambiguationLookup =
            typeVariablesFromContextToDisambiguationLookup
                (declarationValueOrFunctionInfo
                    |> valueOrFunctionDeclarationInfoContainedTypeVariables
                )
    in
    declarationValueOrFunctionInfo
        |> declarationValueOrFunctionInfoMapTypeVariables
            (\variable ->
                { useRange = variable.useRange
                , name =
                    globalTypeVariableDisambiguationLookup
                        |> DictByTypeVariableFromContext.get variable
                        |> Maybe.withDefault
                            "thisIsABugInDisambiguationPleaseReportToElmSyntaxTypeInfer"
                }
            )


valueOrFunctionDeclarationInfoContainedTypeVariables :
    ValueOrFunctionDeclarationInfo Type
    -> TypeVariableFromContextSet
valueOrFunctionDeclarationInfoContainedTypeVariables declarationValueOrFunction =
    declarationValueOrFunction.parameters
        |> listMapToTypeVariableFromContextSetsAndUnify
            patternTypedNodeContainedTypeVariables
        |> DictByTypeVariableFromContext.setUnion
            (declarationValueOrFunction.type_
                |> typeContainedVariables
            )
        |> DictByTypeVariableFromContext.setUnion
            (declarationValueOrFunction.result
                |> expressionTypedNodeContainedTypeVariables
            )


patternTypedNodeContainedTypeVariables :
    TypedNode Pattern
    -> TypeVariableFromContextSet
patternTypedNodeContainedTypeVariables patternTypedNode =
    DictByTypeVariableFromContext.setUnion
        (patternTypedNode.type_
            |> typeContainedVariables
        )
        (patternTypedNode.value
            |> patternContainedTypeVariables
        )


patternContainedTypeVariables :
    Pattern
    -> TypeVariableFromContextSet
patternContainedTypeVariables pattern =
    case pattern of
        PatternIgnored ->
            DictByTypeVariableFromContext.empty

        PatternUnit ->
            DictByTypeVariableFromContext.empty

        PatternChar _ ->
            DictByTypeVariableFromContext.empty

        PatternString _ ->
            DictByTypeVariableFromContext.empty

        PatternInt _ ->
            DictByTypeVariableFromContext.empty

        PatternVariable _ ->
            DictByTypeVariableFromContext.empty

        PatternParenthesized inParens ->
            patternTypedNodeContainedTypeVariables
                inParens

        PatternAs patternAs ->
            DictByTypeVariableFromContext.setUnion
                (patternAs.variable.type_
                    |> typeContainedVariables
                )
                (patternAs.pattern
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTuple parts ->
            DictByTypeVariableFromContext.setUnion
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTriple parts ->
            parts.part0
                |> patternTypedNodeContainedTypeVariables
                |> DictByTypeVariableFromContext.setUnion
                    (parts.part1
                        |> patternTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (parts.part2
                        |> patternTypedNodeContainedTypeVariables
                    )

        PatternListCons patternListCons ->
            DictByTypeVariableFromContext.setUnion
                (patternListCons.head
                    |> patternTypedNodeContainedTypeVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternListExact elements ->
            elements
                |> listMapToTypeVariableFromContextSetsAndUnify
                    patternTypedNodeContainedTypeVariables

        PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToTypeVariableFromContextSetsAndUnify
                    patternTypedNodeContainedTypeVariables

        PatternRecord fields ->
            fields
                |> listMapToTypeVariableFromContextSetsAndUnify
                    (\fieldTypedNode ->
                        fieldTypedNode.type_
                            |> typeContainedVariables
                    )


listMapToTypeVariableFromContextSetsAndUnify :
    (a -> TypeVariableFromContextSet)
    -> List a
    -> TypeVariableFromContextSet
listMapToTypeVariableFromContextSetsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                DictByTypeVariableFromContext.setUnion soFar
                    (element |> elementToSet)
            )
            DictByTypeVariableFromContext.empty


listMapToFastDictsAndUnify :
    (a -> FastDict.Dict comparable value)
    -> List a
    -> FastDict.Dict comparable value
listMapToFastDictsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar
                    (element |> elementToSet)
            )
            FastDict.empty


type Rope key value
    = RopeLeaf key value
    | RopeBranch (Rope key value) (Rope key value)


ropeFoldlWhileOkFrom :
    state
    -> (key -> value -> state -> Result error state)
    -> Rope key value
    -> Result error state
ropeFoldlWhileOkFrom initialState reduceToResult rope =
    -- IGNORE TCO
    case rope of
        RopeLeaf key value ->
            reduceToResult key value initialState

        RopeBranch left right ->
            case ropeFoldlWhileOkFrom initialState reduceToResult left of
                Err error ->
                    Err error

                Ok leftState ->
                    ropeFoldlWhileOkFrom
                        leftState
                        reduceToResult
                        right


valueAndFunctionDeclarationsUsesOfLocalReferences :
    FastDict.Dict String whatever_
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo Type)
    ->
        FastDict.Dict
            String
            (Rope
                Elm.Syntax.Range.Range
                Type
            )
valueAndFunctionDeclarationsUsesOfLocalReferences localReferencesToCollect inferredValueAndFunctionDeclarations =
    inferredValueAndFunctionDeclarations
        |> FastDict.foldl
            (\_ declarationValueOrFunction usesSoFar ->
                collectedLocalReferenceUsesMerge
                    usesSoFar
                    (declarationValueOrFunction.result
                        |> expressionTypedNodeUsesOfLocalReferences
                            localReferencesToCollect
                    )
            )
            FastDict.empty


{-| Figure out why changing the order can lead to type check failures (self-referential type variable substitution: r -> { r | field })
-}
expressionTypedNodeUsesOfLocalReferences :
    FastDict.Dict String whatever_
    -> TypedNode Expression
    ->
        FastDict.Dict
            String
            (Rope Elm.Syntax.Range.Range Type)
expressionTypedNodeUsesOfLocalReferences localReferencesToCollect expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            FastDict.empty

        ExpressionInteger _ ->
            FastDict.empty

        ExpressionFloat _ ->
            FastDict.empty

        ExpressionString _ ->
            FastDict.empty

        ExpressionChar _ ->
            FastDict.empty

        ExpressionReferenceVariant _ ->
            FastDict.empty

        ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastDict.empty

        ExpressionReference reference ->
            -- we're checking against qualification, not moduleOrigin
            -- because referencing other module-level declared things
            -- should be covered by expressionTypedNodeUsesOfLocalReferences as well
            -- and those have the current module name set as the origin
            case reference.qualification of
                "" ->
                    if localReferencesToCollect |> FastDict.member reference.name then
                        FastDict.singleton reference.name
                            (RopeLeaf
                                expressionTypedNode.range
                                expressionTypedNode.type_
                            )

                    else
                        FastDict.empty

                _ ->
                    FastDict.empty

        ExpressionOperatorFunction _ ->
            FastDict.empty

        ExpressionRecordAccessFunction _ ->
            FastDict.empty

        ExpressionNegation negated ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            collectedLocalReferenceUsesMerge
                (expressionInfixOperation.left
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )

        ExpressionTuple parts ->
            collectedLocalReferenceUsesMerge
                (parts.part0
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (parts.part1
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )

        ExpressionTriple parts ->
            collectedLocalReferenceUsesMerge
                (parts.part0
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (collectedLocalReferenceUsesMerge
                    (parts.part1
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                    (parts.part2
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                )

        ExpressionIfThenElse expressionIfThenElse ->
            collectedLocalReferenceUsesMerge
                (expressionIfThenElse.condition
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (collectedLocalReferenceUsesMerge
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                    )
                )

        ExpressionList elements ->
            elements
                |> List.foldl
                    (\element soFar ->
                        collectedLocalReferenceUsesMerge
                            soFar
                            (element |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect)
                    )
                    FastDict.empty

        ExpressionRecord fields ->
            fields
                |> List.foldl
                    (\field soFar ->
                        collectedLocalReferenceUsesMerge
                            soFar
                            (field.value
                                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                            )
                    )
                    FastDict.empty

        ExpressionCall expressionCall ->
            collectedLocalReferenceUsesMerge
                (expressionCall.called
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (expressionCall.argument1Up
                    |> List.foldl
                        (\argument soFar ->
                            collectedLocalReferenceUsesMerge
                                soFar
                                (argument
                                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                )
                        )
                        (expressionCall.argument0
                            |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                        )
                )

        ExpressionLambda expressionLambda ->
            expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                expressionLambda.result

        ExpressionRecordUpdate expressionRecordUpdate ->
            collectedLocalReferenceUsesMerge
                (if
                    localReferencesToCollect
                        |> FastDict.member expressionRecordUpdate.recordVariable.value.name
                 then
                    FastDict.singleton expressionRecordUpdate.recordVariable.value.name
                        (RopeLeaf
                            expressionRecordUpdate.recordVariable.range
                            expressionRecordUpdate.recordVariable.type_
                        )

                 else
                    FastDict.empty
                )
                (expressionRecordUpdate.field1Up
                    |> List.foldl
                        (\field soFar ->
                            collectedLocalReferenceUsesMerge
                                soFar
                                (field.value
                                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                )
                        )
                        (expressionRecordUpdate.field0.value
                            |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                        )
                )

        ExpressionCaseOf expressionCaseOf ->
            collectedLocalReferenceUsesMerge
                (expressionCaseOf.matched
                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                )
                (expressionCaseOf.case1Up
                    |> List.foldl
                        (\case_ soFar ->
                            collectedLocalReferenceUsesMerge
                                soFar
                                (case_.result
                                    |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                                )
                        )
                        (expressionCaseOf.case0.result
                            |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
                        )
                )

        ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences localReferencesToCollect expressionLetIn


expressionLetInUsesOfLocalReferences :
    FastDict.Dict String whatever_
    ->
        { declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration
                }
        , declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration
            }
        , result : TypedNode Expression
        }
    ->
        FastDict.Dict
            String
            (Rope
                Elm.Syntax.Range.Range
                Type
            )
expressionLetInUsesOfLocalReferences localReferencesToCollect expressionLetIn =
    collectedLocalReferenceUsesMerge
        (expressionLetIn.declaration1Up
            |> List.foldl
                (\letDeclaration soFar ->
                    collectedLocalReferenceUsesMerge
                        soFar
                        (letDeclaration.declaration
                            |> letDeclarationUsesOfLocalReferences localReferencesToCollect
                        )
                )
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationUsesOfLocalReferences localReferencesToCollect
                )
        )
        (expressionLetIn.result
            |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect
        )


letDeclarationUsesOfLocalReferences :
    FastDict.Dict String whatever_
    -> LetDeclaration
    ->
        FastDict.Dict
            String
            (Rope
                Elm.Syntax.Range.Range
                Type
            )
letDeclarationUsesOfLocalReferences localReferencesToCollect letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            letValueOrFunctionDeclaration.result
                |> expressionTypedNodeUsesOfLocalReferences localReferencesToCollect


collectedLocalReferenceUsesMerge :
    FastDict.Dict
        String
        (Rope
            Elm.Syntax.Range.Range
            Type
        )
    ->
        FastDict.Dict
            String
            (Rope
                Elm.Syntax.Range.Range
                Type
            )
    ->
        FastDict.Dict
            String
            (Rope
                Elm.Syntax.Range.Range
                Type
            )
collectedLocalReferenceUsesMerge a b =
    fastDictUnionWith
        (\_ aUses bUses -> RopeBranch aUses bUses)
        a
        b


{-| Unify two dictionaries by combining values at the same key with a given function.

    fastDictUnionWith (\_ usesInA usesInB -> usesInA + usesInB)
        (FastDict.fromList
            [ ( "setFromListMap", 3 )
            , ( "setUnifyList", 1 )
            ]
        )
        (FastDict.fromList
            [ ( "listLast", 1 )
            , ( "setFromListMap", 1 )
            ]
        )
    --> FastDict.fromList
    -->     [ ( "listLast", 1 )
    -->     , ( "setFromListMap", 4 )
    -->     , ( "setUnifyList", 1 )
    -->     ]

-}
fastDictUnionWith :
    (comparable -> a -> a -> a)
    -> FastDict.Dict comparable a
    -> FastDict.Dict comparable a
    -> FastDict.Dict comparable a
fastDictUnionWith combineValuesFromBothAndKey aDict bDict =
    if (aDict |> FastDict.size) > (bDict |> FastDict.size) then
        FastDict.foldl
            (\key b soFar ->
                case FastDict.get key soFar of
                    Nothing ->
                        FastDict.insert key b soFar

                    Just a ->
                        FastDict.insert key (combineValuesFromBothAndKey key a b) soFar
            )
            aDict
            bDict

    else
        FastDict.foldl
            (\key a soFar ->
                case FastDict.get key soFar of
                    Nothing ->
                        FastDict.insert key a soFar

                    Just b ->
                        FastDict.insert key (combineValuesFromBothAndKey key a b) soFar
            )
            bDict
            aDict


expressionTypedNodeContainedTypeVariables :
    TypedNode Expression
    -> TypeVariableFromContextSet
expressionTypedNodeContainedTypeVariables expressionTypedNode =
    DictByTypeVariableFromContext.setUnion
        (expressionTypedNode.type_
            |> typeContainedVariables
        )
        (expressionTypedNode.value
            |> expressionContainedTypeVariables
        )


expressionContainedTypeVariables :
    Expression
    -> TypeVariableFromContextSet
expressionContainedTypeVariables expression =
    case expression of
        ExpressionUnit ->
            DictByTypeVariableFromContext.empty

        ExpressionInteger _ ->
            DictByTypeVariableFromContext.empty

        ExpressionFloat _ ->
            DictByTypeVariableFromContext.empty

        ExpressionString _ ->
            DictByTypeVariableFromContext.empty

        ExpressionChar _ ->
            DictByTypeVariableFromContext.empty

        ExpressionReferenceVariant _ ->
            DictByTypeVariableFromContext.empty

        ExpressionReference _ ->
            DictByTypeVariableFromContext.empty

        ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            DictByTypeVariableFromContext.empty

        ExpressionOperatorFunction _ ->
            DictByTypeVariableFromContext.empty

        ExpressionRecordAccessFunction _ ->
            DictByTypeVariableFromContext.empty

        ExpressionNegation negated ->
            expressionTypedNodeContainedTypeVariables
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeContainedTypeVariables
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeContainedTypeVariables
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            DictByTypeVariableFromContext.setUnion
                (expressionInfixOperation.left
                    |> expressionTypedNodeContainedTypeVariables
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTuple parts ->
            DictByTypeVariableFromContext.setUnion
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTriple parts ->
            parts.part0
                |> expressionTypedNodeContainedTypeVariables
                |> DictByTypeVariableFromContext.setUnion
                    (parts.part1
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (parts.part2
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> expressionTypedNodeContainedTypeVariables
                |> DictByTypeVariableFromContext.setUnion
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionList elements ->
            elements
                |> listMapToTypeVariableFromContextSetsAndUnify
                    expressionTypedNodeContainedTypeVariables

        ExpressionRecord fields ->
            fields
                |> listMapToTypeVariableFromContextSetsAndUnify
                    (\field ->
                        field.value
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionCall expressionCall ->
            expressionCall.called
                |> expressionTypedNodeContainedTypeVariables
                |> DictByTypeVariableFromContext.setUnion
                    (expressionCall.argument0
                        |> expressionTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (expressionCall.argument1Up
                        |> listMapToTypeVariableFromContextSetsAndUnify
                            expressionTypedNodeContainedTypeVariables
                    )

        ExpressionLambda expressionLambda ->
            expressionLambda.parameter1Up
                |> List.foldl
                    (\parameter soFar ->
                        DictByTypeVariableFromContext.setUnion
                            soFar
                            (parameter
                                |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (expressionLambda.parameter0
                        |> patternTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (expressionLambda.result
                        |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionRecordUpdate expressionRecordUpdate ->
            expressionRecordUpdate.recordVariable.type_
                |> typeContainedVariables
                |> DictByTypeVariableFromContext.setUnion
                    (expressionRecordUpdate.field1Up
                        |> List.foldl
                            (\field soFar ->
                                DictByTypeVariableFromContext.setUnion
                                    soFar
                                    (field.value
                                        |> expressionTypedNodeContainedTypeVariables
                                    )
                            )
                            (expressionRecordUpdate.field0.value
                                |> expressionTypedNodeContainedTypeVariables
                            )
                    )

        ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matched
                |> expressionTypedNodeContainedTypeVariables
                |> DictByTypeVariableFromContext.setUnion
                    (expressionCaseOf.case1Up
                        |> List.foldl
                            (\case_ soFar ->
                                DictByTypeVariableFromContext.setUnion
                                    soFar
                                    (case_ |> expressionCaseOfCaseContainedTypeVariables)
                            )
                            (expressionCaseOf.case0
                                |> expressionCaseOfCaseContainedTypeVariables
                            )
                    )

        ExpressionLetIn expressionLetIn ->
            expressionLetIn.declaration1Up
                |> List.foldl
                    (\letDeclaration soFar ->
                        DictByTypeVariableFromContext.setUnion
                            soFar
                            (letDeclaration.declaration
                                |> letDeclarationContainedTypeVariables
                            )
                    )
                    (expressionLetIn.declaration0.declaration
                        |> letDeclarationContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (expressionLetIn.result
                        |> expressionTypedNodeContainedTypeVariables
                    )


letDeclarationContainedTypeVariables :
    LetDeclaration
    -> TypeVariableFromContextSet
letDeclarationContainedTypeVariables letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            DictByTypeVariableFromContext.setUnion
                (letDestructuring.pattern
                    |> patternTypedNodeContainedTypeVariables
                )
                (letDestructuring.expression
                    |> expressionTypedNodeContainedTypeVariables
                )

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            letValueOrFunctionDeclaration.type_
                |> typeContainedVariables
                |> DictByTypeVariableFromContext.setUnion
                    (letValueOrFunctionDeclaration.parameters
                        |> listMapToTypeVariableFromContextSetsAndUnify
                            patternTypedNodeContainedTypeVariables
                    )
                |> DictByTypeVariableFromContext.setUnion
                    (letValueOrFunctionDeclaration.result
                        |> expressionTypedNodeContainedTypeVariables
                    )


expressionCaseOfCaseContainedTypeVariables :
    { pattern : TypedNode Pattern
    , result : TypedNode Expression
    }
    -> TypeVariableFromContextSet
expressionCaseOfCaseContainedTypeVariables syntaxCase =
    DictByTypeVariableFromContext.setUnion
        (syntaxCase.pattern
            |> patternTypedNodeContainedTypeVariables
        )
        (syntaxCase.result
            |> expressionTypedNodeContainedTypeVariables
        )


createEquivalentVariablesToCondensedVariableLookup :
    List EquivalentTypeVariableSet
    -> Result String (DictByTypeVariableFromContext TypeVariableFromContext)
createEquivalentVariablesToCondensedVariableLookup equivalentVariables =
    equivalentVariables
        |> listFoldlWhileOkFrom
            DictByTypeVariableFromContext.empty
            (\equivalentVariableSet soFar ->
                Result.map
                    (\unifiedVariable ->
                        equivalentVariableSet.variables
                            |> DictByTypeVariableFromContext.foldl
                                (\variable () soFarInSet ->
                                    soFarInSet
                                        |> DictByTypeVariableFromContext.insertNoReplace
                                            variable
                                            unifiedVariable
                                )
                                soFar
                    )
                    (equivalentVariablesCreateCondensedVariable equivalentVariableSet)
            )


valueAndFunctionDeclarationsGetPartiallyInferred :
    FastDict.Dict
        String
        (ValueOrFunctionDeclarationInfo Type)
    ->
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type
            }
valueAndFunctionDeclarationsGetPartiallyInferred valueAndFunctionDeclarationsSoFar =
    valueAndFunctionDeclarationsSoFar
        |> FastDict.foldl
            (\name declarationValueOrFunction moduleLevelPartiallyInferredDeclarationsSoFar ->
                case declarationValueOrFunction.signature of
                    Just _ ->
                        moduleLevelPartiallyInferredDeclarationsSoFar

                    Nothing ->
                        moduleLevelPartiallyInferredDeclarationsSoFar
                            |> FastDict.insert name
                                { range =
                                    declarationValueOrFunction |> valueOrFunctionDeclarationInfoRange
                                , type_ = declarationValueOrFunction.type_
                                }
            )
            FastDict.empty


valueOrFunctionDeclarationInfoRange :
    ValueOrFunctionDeclarationInfo typeVariable_
    -> Elm.Syntax.Range.Range
valueOrFunctionDeclarationInfoRange valueOrFunctionDeclarationInfo =
    { start =
        case valueOrFunctionDeclarationInfo.documentation of
            Just documentation ->
                documentation.range.start

            Nothing ->
                case valueOrFunctionDeclarationInfo.signature of
                    Just signature ->
                        signature.range.start

                    Nothing ->
                        valueOrFunctionDeclarationInfo.nameRange.start
    , end = valueOrFunctionDeclarationInfo.result.range.end
    }


typeVariableFromContextSetToListHighestToLowestAndMap :
    (TypeVariableFromContext -> listElement)
    -> TypeVariableFromContextSet
    -> List listElement
typeVariableFromContextSetToListHighestToLowestAndMap setElementToListElement typeVariableFromContextSet =
    typeVariableFromContextSet
        |> DictByTypeVariableFromContext.foldl
            (\setElement () soFar ->
                (setElement |> setElementToListElement) :: soFar
            )
            []


valueAndFunctionDeclarationsSubstituteVariableByType :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo Type)
    ->
        Result
            String
            { declarations :
                FastDict.Dict
                    String
                    (ValueOrFunctionDeclarationInfo Type)
            , unchangedDeclarations : Set.Set String
            , substitutions : VariableSubstitutions
            }
valueAndFunctionDeclarationsSubstituteVariableByType declarationTypes substitutionToApply valueAndFunctionDeclarationsToApplySubstitutionTo =
    valueAndFunctionDeclarationsToApplySubstitutionTo
        |> fastDictFoldlWhileOkFrom
            substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty
            (\declarationName declarationToSubstituteIn soFar ->
                Result.andThen
                    (\declarationSubstituted ->
                        if declarationSubstituted.unchanged then
                            Ok
                                { substitutions = soFar.substitutions
                                , unchangedDeclarations =
                                    soFar.unchangedDeclarations
                                        |> Set.insert declarationName
                                , declarations =
                                    FastDict.insert declarationName
                                        declarationToSubstituteIn
                                        soFar.declarations
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , unchangedDeclarations =
                                        soFar.unchangedDeclarations
                                    , declarations =
                                        FastDict.insert declarationName
                                            declarationSubstituted.declaration
                                            soFar.declarations
                                    }
                                )
                                (variableSubstitutionsMerge
                                    { declarationTypes = declarationTypes
                                    , range = everywhereRange
                                    }
                                    soFar.substitutions
                                    declarationSubstituted.substitutions
                                )
                    )
                    (declarationToSubstituteIn
                        |> valueOrFunctionDeclarationInfoSubstituteVariableByType
                            declarationTypes
                            substitutionToApply
                    )
                    |> Result.mapError
                        (\substitutionError ->
                            "I inferred various parts of the value/function declaration "
                                ++ declarationName
                                ++ " but there was a problem after substituting pieces of knowledge: "
                                ++ substitutionError
                        )
            )


{-| Hacky way to get a range that includes any other possible range.
Avoid if possible
-}
everywhereRange : Elm.Syntax.Range.Range
everywhereRange =
    { start = { row = 1, column = 1 }
    , end = { row = 10000000, column = 10000000 }
    }


substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty :
    { substitutions : VariableSubstitutions
    , declarations : FastDict.Dict String declarationInfo_
    , unchangedDeclarations : Set String
    }
substitutionsNoneDeclarationsDictEmptyUnchangedDeclarationsSetEmpty =
    { substitutions = variableSubstitutionsNone
    , declarations = FastDict.empty
    , unchangedDeclarations = Set.empty
    }


variableToTypeSubstitutionsCondenseVariables :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> DictByTypeVariableFromContext TypeVariableFromContext
    -> DictByTypeVariableFromContext TypeNotVariable
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsCondenseVariables context variableToCondensedLookup variableToType =
    variableToType
        |> DictByTypeVariableFromContext.foldlWhileOkFrom
            variableSubstitutionsNone
            (\uncondensedVariable replacementType soFar ->
                let
                    replacementTypeUsingCondensedVariables : TypeNotVariable
                    replacementTypeUsingCondensedVariables =
                        replacementType
                            |> typeNotVariableMapVariables
                                (\variable ->
                                    variableToCondensedLookup
                                        |> DictByTypeVariableFromContext.get variable
                                        |> Maybe.withDefault variable
                                )
                in
                case variableToCondensedLookup |> DictByTypeVariableFromContext.get uncondensedVariable of
                    Nothing ->
                        Ok
                            { equivalentVariables = soFar.equivalentVariables
                            , variableToType =
                                soFar.variableToType
                                    |> DictByTypeVariableFromContext.insertNoReplace uncondensedVariable
                                        replacementTypeUsingCondensedVariables
                            }

                    Just condensedVariable ->
                        case soFar.variableToType |> DictByTypeVariableFromContext.get condensedVariable of
                            Nothing ->
                                Ok
                                    { equivalentVariables = soFar.equivalentVariables
                                    , variableToType =
                                        soFar.variableToType
                                            |> DictByTypeVariableFromContext.insertNoReplace condensedVariable
                                                replacementTypeUsingCondensedVariables
                                    }

                            Just existingReplacementTypeForCondensedVariable ->
                                Result.andThen
                                    (\replacementTypeForCondensedVariable ->
                                        case replacementTypeForCondensedVariable.type_ of
                                            TypeVariable replacementTypeVariableForCondensedVariable ->
                                                Result.map
                                                    (\equivalentVariablesWithCondensed ->
                                                        { equivalentVariables =
                                                            equivalentVariablesWithCondensed
                                                        , variableToType = soFar.variableToType
                                                        }
                                                    )
                                                    (soFar.equivalentVariables
                                                        |> equivalentVariablesMergeWithSetOf2
                                                            condensedVariable
                                                            replacementTypeVariableForCondensedVariable
                                                    )

                                            TypeNotVariable replacementTypeNotVariableForCondensedVariable ->
                                                Result.map
                                                    (\substitutionsSoFarAndFromUnifying ->
                                                        { variableToType =
                                                            substitutionsSoFarAndFromUnifying.variableToType
                                                                |> DictByTypeVariableFromContext.insertNoReplace condensedVariable
                                                                    replacementTypeNotVariableForCondensedVariable
                                                        , equivalentVariables =
                                                            substitutionsSoFarAndFromUnifying.equivalentVariables
                                                        }
                                                    )
                                                    (variableSubstitutionsMerge context
                                                        soFar
                                                        replacementTypeForCondensedVariable.substitutions
                                                    )
                                    )
                                    (typeNotVariableUnify context
                                        existingReplacementTypeForCondensedVariable
                                        replacementTypeUsingCondensedVariables
                                    )
            )


valueOrFunctionDeclarationInfoSubstituteVariableByType :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> ValueOrFunctionDeclarationInfo Type
    ->
        Result
            String
            { unchanged : Bool
            , declaration : ValueOrFunctionDeclarationInfo Type
            , substitutions : VariableSubstitutions
            }
valueOrFunctionDeclarationInfoSubstituteVariableByType declarationTypes replacement declarationValueOrFunctionSoFar =
    let
        typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
        typeContext =
            { declarationTypes = declarationTypes
            , range = declarationValueOrFunctionSoFar |> valueOrFunctionDeclarationInfoRange
            }
    in
    resultAndThen3
        (\typeSubstituted parametersSubstituted resultSubstituted ->
            if typeSubstituted.unchanged && parametersSubstituted.allUnchanged && resultSubstituted.unchanged then
                Ok
                    { unchanged = True
                    , declaration = declarationValueOrFunctionSoFar
                    , substitutions = parametersSubstituted.substitutions
                    }

            else
                Result.map
                    (\fullSubstitutions ->
                        { unchanged = False
                        , declaration =
                            { nameRange = declarationValueOrFunctionSoFar.nameRange
                            , documentation = declarationValueOrFunctionSoFar.documentation
                            , signature = declarationValueOrFunctionSoFar.signature
                            , parameters = parametersSubstituted.nodes
                            , result = resultSubstituted.node
                            , type_ = typeSubstituted.type_
                            }
                        , substitutions = fullSubstitutions
                        }
                    )
                    (variableSubstitutionsMerge3 typeContext
                        parametersSubstituted.substitutions
                        resultSubstituted.substitutions
                        typeSubstituted.substitutions
                    )
        )
        (declarationValueOrFunctionSoFar.type_
            |> typeSubstituteVariableByType typeContext
                replacement
        )
        (declarationValueOrFunctionSoFar.parameters
            |> listFoldrWhileOkFrom
                substitutionsNoneNodesEmptyAllUnchangedTrue
                (\patternTypedNode soFar ->
                    Result.andThen
                        (\patternSubstituted ->
                            if patternSubstituted.unchanged then
                                Ok
                                    { allUnchanged = soFar.allUnchanged
                                    , substitutions = soFar.substitutions
                                    , nodes =
                                        patternTypedNode :: soFar.nodes
                                    }

                            else
                                Result.map
                                    (\fullSubstitutions ->
                                        { allUnchanged = False
                                        , substitutions = fullSubstitutions
                                        , nodes =
                                            patternSubstituted.node
                                                :: soFar.nodes
                                        }
                                    )
                                    (variableSubstitutionsMerge typeContext
                                        patternSubstituted.substitutions
                                        soFar.substitutions
                                    )
                        )
                        (patternTypedNode
                            |> patternTypedNodeSubstituteVariableByType declarationTypes
                                replacement
                        )
                )
        )
        (declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeSubstituteVariableByType declarationTypes
                replacement
        )


typeNotVariableIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable
    -> Bool
typeNotVariableIsEquivalentToTypeVariable declarationTypes typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            case declarationTypes |> FastDict.get typeConstruct.moduleOrigin of
                Nothing ->
                    False

                Just originModule ->
                    case originModule.typeAliases |> FastDict.get typeConstruct.name of
                        Nothing ->
                            False

                        Just typeAlias ->
                            typeAlias.type_ |> typeIsEquivalentToTypeVariable declarationTypes

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type
    -> Bool
typeIsEquivalentToTypeVariable declarationTypes type_ =
    case type_ of
        TypeVariable _ ->
            True

        TypeNotVariable typeNotVariable ->
            typeNotVariable
                |> typeNotVariableIsEquivalentToTypeVariable declarationTypes


declarationValueOrFunctionInfoMapTypeVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> ValueOrFunctionDeclarationInfo Type
    -> ValueOrFunctionDeclarationInfo Type
declarationValueOrFunctionInfoMapTypeVariables variableChange declarationValueOrFunctionSoFar =
    { nameRange = declarationValueOrFunctionSoFar.nameRange
    , documentation = declarationValueOrFunctionSoFar.documentation
    , signature = declarationValueOrFunctionSoFar.signature
    , parameters =
        declarationValueOrFunctionSoFar.parameters
            |> List.map
                (\argument ->
                    argument |> patternTypedNodeMapTypeVariables variableChange
                )
    , result =
        declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeMapTypeVariables variableChange
    , type_ =
        declarationValueOrFunctionSoFar.type_
            |> typeMapVariables variableChange
    }


expressionTypedNodeSubstituteVariableByType :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> TypedNode Expression
    ->
        Result
            String
            { unchanged : Bool
            , substitutions : VariableSubstitutions
            , node : TypedNode Expression
            }
expressionTypedNodeSubstituteVariableByType declarationTypes replacement expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionFloat _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionChar _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionString _ ->
            Ok
                { unchanged = True
                , node = expressionTypedNode
                , substitutions = variableSubstitutionsNone
                }

        ExpressionInteger integer ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionInteger integer
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionReferenceRecordTypeAliasConstructorFunction reference
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionReferenceVariant reference ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionReferenceVariant reference
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionReference reference ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionReference reference
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionOperatorFunction symbol ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionOperatorFunction symbol
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionRecordAccessFunction field ->
            Result.map
                (\typeSubstituted ->
                    if typeSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = typeSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionRecordAccessFunction field
                            , type_ = typeSubstituted.type_
                            }
                        }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = expressionTypedNode.range
                        }
                        replacement
                )

        ExpressionNegation negated ->
            Result.map
                (\negatedSubstituted ->
                    if negatedSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = negatedSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionNegation negatedSubstituted.node
                            , type_ = negatedSubstituted.node.type_
                            }
                        }
                )
                (negated
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value = ExpressionParenthesized inParensSubstituted.node
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (inParens
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionRecordAccess recordAccess ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted recordSubstituted ->
                    if typeSubstituted.unchanged && recordSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionRecordAccess
                                            { fieldName = recordAccess.fieldName
                                            , fieldNameRange = recordAccess.fieldNameRange
                                            , record = recordSubstituted.node
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                typeSubstituted.substitutions
                                recordSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (recordAccess.record
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionInfixOperation expressionInfixOperation ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\typeSubstituted leftSubstituted rightSubstituted ->
                    if typeSubstituted.unchanged && leftSubstituted.unchanged && rightSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionInfixOperation
                                            { operator =
                                                { symbol = expressionInfixOperation.operator.symbol
                                                , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                                                , type_ =
                                                    TypeNotVariable
                                                        (TypeFunction
                                                            { input = leftSubstituted.node.type_
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input = rightSubstituted.node.type_
                                                                        , output = typeSubstituted.type_
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                }
                                            , left = leftSubstituted.node
                                            , right = rightSubstituted.node
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                leftSubstituted.substitutions
                                rightSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType typeContext
                        replacement
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionTuple expressionTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionTuple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (expressionTuple.part0
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionTuple.part1
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionTriple expressionTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionTriple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            , part2 = part2Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                , part2 = part2Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (expressionTriple.part0
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionTriple.part1
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionTriple.part2
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen3
                (\conditionSubstituted onTrueSubstituted onFalseSubstituted ->
                    if conditionSubstituted.unchanged && onTrueSubstituted.unchanged && onFalseSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionIfThenElse
                                            { condition = conditionSubstituted.node
                                            , onTrue = onTrueSubstituted.node
                                            , onFalse = onFalseSubstituted.node
                                            }
                                    , type_ = onTrueSubstituted.node.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = expressionTypedNode.range
                                }
                                conditionSubstituted.substitutions
                                onTrueSubstituted.substitutions
                                onFalseSubstituted.substitutions
                            )
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionList expressionListElements ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    if typeSubstituted.unchanged && elementsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionList
                                            elementsSubstituted.nodes
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge typeContext
                                elementsSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (expressionListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\elementNode soFar ->
                            Result.andThen
                                (\elementSubstituted ->
                                    if elementSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = elementNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsSoFarWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsSoFarWithElement
                                                , nodes =
                                                    elementSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                elementSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (elementNode
                                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionCall expressionCall ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen4
                (\typeSubstituted calledSubstituted argument0Substituted argument1UpSubstituted ->
                    if typeSubstituted.unchanged && calledSubstituted.unchanged && argument0Substituted.unchanged && argument1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionCall
                                            { called = calledSubstituted.node
                                            , argument0 = argument0Substituted.node
                                            , argument1Up = argument1UpSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge4
                                typeContext
                                calledSubstituted.substitutions
                                argument0Substituted.substitutions
                                argument1UpSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (expressionCall.called
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionCall.argument0
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionCall.argument1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    if argumentSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                argumentNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    argumentSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                argumentSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (argumentNode
                                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecord expressionRecordFields ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            Result.map
                (\fieldsSubstituted ->
                    if fieldsSubstituted.allUnchanged then
                        { unchanged = True
                        , node = expressionTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = fieldsSubstituted.substitutions
                        , node =
                            { range = expressionTypedNode.range
                            , value =
                                ExpressionRecord fieldsSubstituted.nodes
                            , type_ =
                                TypeNotVariable
                                    (TypeRecord
                                        (fieldsSubstituted.nodes
                                            |> List.foldl
                                                (\fieldSubstituted soFar ->
                                                    soFar
                                                        |> FastDict.insert fieldSubstituted.name
                                                            fieldSubstituted.value.type_
                                                )
                                                FastDict.empty
                                        )
                                    )
                            }
                        }
                )
                (expressionRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    if fieldValueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { range = fieldNode.range
                                                    , name = fieldNode.name
                                                    , nameRange = fieldNode.nameRange
                                                    , value = fieldValueSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldValueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\typeSubstituted field0Substituted field1UpSubstituted ->
                    if typeSubstituted.unchanged && field0Substituted.unchanged && field1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionRecordUpdate
                                            { recordVariable =
                                                { value = expressionRecordUpdate.recordVariable.value
                                                , range = expressionRecordUpdate.recordVariable.range
                                                , type_ = typeSubstituted.type_
                                                }
                                            , field0 = field0Substituted.node
                                            , field1Up = field1UpSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                field0Substituted.substitutions
                                field1UpSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (Result.map
                    (\fieldValueSubstituted ->
                        if fieldValueSubstituted.unchanged then
                            { unchanged = True
                            , node = expressionRecordUpdate.field0
                            , substitutions = variableSubstitutionsNone
                            }

                        else
                            { unchanged = False
                            , substitutions = fieldValueSubstituted.substitutions
                            , node =
                                { range = expressionRecordUpdate.field0.range
                                , name = expressionRecordUpdate.field0.name
                                , nameRange = expressionRecordUpdate.field0.nameRange
                                , value = fieldValueSubstituted.node
                                }
                            }
                    )
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeSubstituteVariableByType declarationTypes
                            replacement
                    )
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    if fieldValueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { range = fieldNode.range
                                                    , name = fieldNode.name
                                                    , nameRange = fieldNode.nameRange
                                                    , value = fieldValueSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldValueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLambda expressionLambda ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\parameter0Substituted parameter1UpSubstituted resultSubstituted ->
                    if parameter0Substituted.unchanged && parameter1UpSubstituted.allUnchanged && resultSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionLambda
                                            { parameter0 = parameter0Substituted.node
                                            , parameter1Up = parameter1UpSubstituted.nodes
                                            , result = resultSubstituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = parameter0Substituted.node.type_
                                                , output =
                                                    parameter1UpSubstituted.nodes
                                                        |> List.foldr
                                                            (\argumentTypedNode output ->
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input = argumentTypedNode.type_
                                                                        , output = output
                                                                        }
                                                                    )
                                                            )
                                                            resultSubstituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                typeContext
                                parameter0Substituted.substitutions
                                parameter1UpSubstituted.substitutions
                                resultSubstituted.substitutions
                            )
                )
                (expressionLambda.parameter0
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionLambda.parameter1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\parameterNode soFar ->
                            Result.andThen
                                (\parameterSubstituted ->
                                    if parameterSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                parameterNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsSoFarWithParameter ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsSoFarWithParameter
                                                , nodes =
                                                    parameterSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge typeContext
                                                parameterSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLambda.result
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        ExpressionCaseOf expressionCaseOf ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\matchedSubstituted case0Substituted case1UpSubstituted ->
                    if matchedSubstituted.unchanged && case0Substituted.unchanged && case1UpSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = expressionTypedNode.range
                                    , value =
                                        ExpressionCaseOf
                                            { case0 = case0Substituted.node
                                            , case1Up = case1UpSubstituted.nodes
                                            , matched = matchedSubstituted.node
                                            }
                                    , type_ = case0Substituted.node.result.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                matchedSubstituted.substitutions
                                case0Substituted.substitutions
                                case1UpSubstituted.substitutions
                            )
                )
                (expressionCaseOf.matched
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (resultAndThen2
                    (\patternSubstituted resultSubstituted ->
                        if patternSubstituted.unchanged && resultSubstituted.unchanged then
                            Ok
                                { unchanged = True
                                , node = expressionCaseOf.case0
                                , substitutions = variableSubstitutionsNone
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { unchanged = False
                                    , substitutions = fullSubstitutions
                                    , node =
                                        { pattern = patternSubstituted.node
                                        , result = resultSubstituted.node
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge
                                    { declarationTypes = declarationTypes
                                    , range =
                                        { start = expressionCaseOf.case0.pattern.range.start
                                        , end = expressionCaseOf.case0.result.range.end
                                        }
                                    }
                                    patternSubstituted.substitutions
                                    resultSubstituted.substitutions
                                )
                    )
                    (expressionCaseOf.case0.pattern
                        |> patternTypedNodeSubstituteVariableByType declarationTypes
                            replacement
                    )
                    (expressionCaseOf.case0.result
                        |> expressionTypedNodeSubstituteVariableByType declarationTypes
                            replacement
                    )
                )
                (expressionCaseOf.case1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\case_ soFar ->
                            resultAndThen2
                                (\patternSubstituted resultSubstituted ->
                                    if resultSubstituted.unchanged && patternSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = case_ :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    { pattern = patternSubstituted.node
                                                    , result = resultSubstituted.node
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge3 typeContext
                                                patternSubstituted.substitutions
                                                resultSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (case_.pattern
                                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                                (case_.result
                                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLetIn expressionLetIn ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = expressionTypedNode.range
                    }
            in
            resultAndThen3
                (\declaration0Substituted declaration1UpSubstituted resultSubstituted ->
                    if declaration0Substituted.unchanged && declaration1UpSubstituted.allUnchanged && resultSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = expressionTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        let
                            resultLetInNode : TypedNode Expression
                            resultLetInNode =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLetIn
                                        { declaration0 =
                                            declaration0Substituted.node
                                        , declaration1Up = declaration1UpSubstituted.nodes
                                        , result = resultSubstituted.node
                                        }
                                , type_ = resultSubstituted.node.type_
                                }

                            updatedValueOrFunctionTypes :
                                FastDict.Dict
                                    String
                                    { range : Elm.Syntax.Range.Range
                                    , type_ : Type
                                    }
                            updatedValueOrFunctionTypes =
                                case declaration0Substituted.updatedValueOrFunctionType of
                                    Nothing ->
                                        declaration1UpSubstituted.updatedValueOrFunctionTypes

                                    Just declaration0UpdatedValueOrFunctionType ->
                                        FastDict.insert declaration0UpdatedValueOrFunctionType.name
                                            { range = declaration0UpdatedValueOrFunctionType.range
                                            , type_ = declaration0UpdatedValueOrFunctionType.type_
                                            }
                                            declaration1UpSubstituted.updatedValueOrFunctionTypes

                            variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError : Result String VariableSubstitutions
                            variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError =
                                expressionTypedNodeUsesOfLocalReferences
                                    updatedValueOrFunctionTypes
                                    resultLetInNode
                                    |> fastDictFoldlWhileOkFrom
                                        variableSubstitutionsNone
                                        (\inferredLetDeclarationName uses soFar ->
                                            case updatedValueOrFunctionTypes |> FastDict.get inferredLetDeclarationName of
                                                Nothing ->
                                                    Err
                                                        ("("
                                                            ++ (expressionTypedNode.range |> rangeToInfoString)
                                                            ++ ") "
                                                            ++ "bug in elm-syntax-type-infer: collected uses of variable that wasn't asked for"
                                                        )

                                                Just inferredDeclarationType ->
                                                    uses
                                                        |> ropeFoldlWhileOkFrom
                                                            soFar
                                                            (\useRange useType soFarWithUses ->
                                                                let
                                                                    letDeclarationTypeNewInstanceForUse : Type
                                                                    letDeclarationTypeNewInstanceForUse =
                                                                        inferredDeclarationType.type_
                                                                            |> typeMapVariables
                                                                                (\inferredDeclarationTypeVariable ->
                                                                                    if
                                                                                        inferredDeclarationType.range
                                                                                            |> rangeIncludesRange
                                                                                                useRange
                                                                                    then
                                                                                        { useRange = useRange
                                                                                        , name = inferredDeclarationTypeVariable.name
                                                                                        }

                                                                                    else
                                                                                        inferredDeclarationTypeVariable
                                                                                )
                                                                in
                                                                Result.andThen
                                                                    (\useUnifiedWithNewLetTypeInstance ->
                                                                        -- we need to check if the partialTpeNewInstance
                                                                        -- is actually more strict then the already existing use type.
                                                                        -- If we don't, this would run indefinitely: E.g.
                                                                        -- a : number
                                                                        -- b = round a
                                                                        -- where a is already known as Float
                                                                        -- when it is unified with the let `number`
                                                                        if
                                                                            typesAreEquallyStrict
                                                                                (useUnifiedWithNewLetTypeInstance.type_ |> typeContainedVariables)
                                                                                (useType |> typeContainedVariables)
                                                                        then
                                                                            equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                                                                soFarWithUses.variableToType
                                                                                soFarWithUses.equivalentVariables
                                                                                useUnifiedWithNewLetTypeInstance.substitutions.equivalentVariables

                                                                        else
                                                                            variableSubstitutionsMerge
                                                                                typeContext
                                                                                soFarWithUses
                                                                                useUnifiedWithNewLetTypeInstance.substitutions
                                                                    )
                                                                    (typeUnify typeContext
                                                                        useType
                                                                        letDeclarationTypeNewInstanceForUse
                                                                    )
                                                            )
                                        )
                        in
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node = resultLetInNode
                                }
                            )
                            (Result.andThen
                                (\variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes ->
                                    variableSubstitutionsMerge4
                                        typeContext
                                        declaration0Substituted.substitutions
                                        declaration1UpSubstituted.substitutions
                                        resultSubstituted.substitutions
                                        variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypes
                                )
                                variableSubstitutionsForUnifyingWithUpdatedValueOrFunctionTypesOrError
                            )
                )
                (expressionLetIn.declaration0
                    |> letDeclarationSubstituteVariableByType declarationTypes
                        replacement
                )
                (expressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue
                        (\letDeclarationNode soFar ->
                            Result.andThen
                                (\declarationSubstituted ->
                                    if declarationSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , updatedValueOrFunctionTypes =
                                                soFar.updatedValueOrFunctionTypes
                                            , nodes =
                                                letDeclarationNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , updatedValueOrFunctionTypes =
                                                    case declarationSubstituted.updatedValueOrFunctionType of
                                                        Nothing ->
                                                            soFar.updatedValueOrFunctionTypes

                                                        Just updatedValueOrFunctionType ->
                                                            FastDict.insert updatedValueOrFunctionType.name
                                                                { range = updatedValueOrFunctionType.range
                                                                , type_ = updatedValueOrFunctionType.type_
                                                                }
                                                                soFar.updatedValueOrFunctionTypes
                                                , nodes =
                                                    declarationSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                soFar.substitutions
                                                declarationSubstituted.substitutions
                                            )
                                )
                                (letDeclarationNode
                                    |> letDeclarationSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )


letDeclarationSubstituteVariableByType :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : LetDeclaration
        }
    ->
        Result
            String
            { unchanged : Bool
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration
                }
            , updatedValueOrFunctionType :
                Maybe
                    { name : String
                    , range : Elm.Syntax.Range.Range
                    , type_ : Type
                    }
            , substitutions : VariableSubstitutions
            }
letDeclarationSubstituteVariableByType declarationTypes replacement letDeclarationAndRange =
    case letDeclarationAndRange.declaration of
        LetDestructuring letDestructuring ->
            resultAndThen2
                (\patternSubstituted expressionSubstituted ->
                    if patternSubstituted.unchanged && expressionSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = letDeclarationAndRange
                            , substitutions = variableSubstitutionsNone
                            , updatedValueOrFunctionType = Nothing
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , updatedValueOrFunctionType = Nothing
                                , node =
                                    { range = letDeclarationAndRange.range
                                    , declaration =
                                        LetDestructuring
                                            { pattern = patternSubstituted.node
                                            , expression = expressionSubstituted.node
                                            }
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = letDeclarationAndRange.range
                                }
                                patternSubstituted.substitutions
                                expressionSubstituted.substitutions
                            )
                )
                (letDestructuring.pattern
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (letDestructuring.expression
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = letDeclarationAndRange.range
                    }
            in
            resultAndThen3
                (\parametersSubstituted resultSubstituted typeSubstituted ->
                    if typeSubstituted.unchanged then
                        if resultSubstituted.unchanged && parametersSubstituted.allUnchanged then
                            Ok
                                { unchanged = True
                                , substitutions = variableSubstitutionsNone
                                , updatedValueOrFunctionType = Nothing
                                , node = letDeclarationAndRange
                                }

                        else
                            Result.map
                                (\fullSubstitutions ->
                                    { unchanged = False
                                    , substitutions = fullSubstitutions
                                    , updatedValueOrFunctionType = Nothing
                                    , node =
                                        { range = letDeclarationAndRange.range
                                        , declaration =
                                            LetValueOrFunctionDeclaration
                                                { parameters = parametersSubstituted.nodes
                                                , result = resultSubstituted.node
                                                , type_ = letValueOrFunction.type_
                                                , signature = letValueOrFunction.signature
                                                , nameRange = letValueOrFunction.nameRange
                                                , name = letValueOrFunction.name
                                                }
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge typeContext
                                    parametersSubstituted.substitutions
                                    resultSubstituted.substitutions
                                )

                    else
                        -- TODO when the substituted type is more strict
                        -- throw an error: annotation too loose
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , updatedValueOrFunctionType =
                                    Just
                                        { name = letValueOrFunction.name
                                        , range = letDeclarationAndRange.range
                                        , type_ = typeSubstituted.type_
                                        }
                                , node =
                                    { range = letDeclarationAndRange.range
                                    , declaration =
                                        LetValueOrFunctionDeclaration
                                            { parameters = parametersSubstituted.nodes
                                            , result = resultSubstituted.node
                                            , type_ = typeSubstituted.type_
                                            , signature = letValueOrFunction.signature
                                            , nameRange = letValueOrFunction.nameRange
                                            , name = letValueOrFunction.name
                                            }
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3 typeContext
                                parametersSubstituted.substitutions
                                resultSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (letValueOrFunction.parameters
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\parameterNode soFar ->
                            Result.andThen
                                (\parameterSubstituted ->
                                    if parameterSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                parameterNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\fullSubstitutions ->
                                                { allUnchanged = False
                                                , substitutions = fullSubstitutions
                                                , nodes =
                                                    parameterSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                soFar.substitutions
                                                parameterSubstituted.substitutions
                                            )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (letValueOrFunction.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )


{-| How do we check a type has gotten more strict?

 - each variable has at most one corresponding condensed variable
   so if we have less condensed variables, the type is more limited
 - also, if any condensed variable has more constraints,
   the type is also more limited

-}
typesAreEquallyStrict :
    TypeVariableFromContextSet
    -> TypeVariableFromContextSet
    -> Bool
typesAreEquallyStrict aType bType =
    ((aType |> DictByTypeVariableFromContext.size) - (bType |> DictByTypeVariableFromContext.size) == 0)
        && ((aType
                |> typeVariableFromContextSetToListHighestToLowestAndMap
                    (\aVariable ->
                        aVariable.name
                            |> typeVariableConstraint
                            |> maybeTypeVariableConstraintToString
                    )
                |> List.sort
            )
                == (bType
                        |> typeVariableFromContextSetToListHighestToLowestAndMap
                            (\bVariable ->
                                bVariable.name
                                    |> typeVariableConstraint
                                    |> maybeTypeVariableConstraintToString
                            )
                        |> List.sort
                   )
           )


{-| Use for renaming but not for possibly adding constraints
-}
expressionTypedNodeMapTypeVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> TypedNode Expression
    -> TypedNode Expression
expressionTypedNodeMapTypeVariables typeVariableChange expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


expressionTypedNodeMapTypes :
    (Type -> Type)
    -> TypedNode Expression
    -> TypedNode Expression
expressionTypedNodeMapTypes typeChange expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            expressionTypedNode

        ExpressionFloat _ ->
            expressionTypedNode

        ExpressionChar _ ->
            expressionTypedNode

        ExpressionString _ ->
            expressionTypedNode

        ExpressionInteger _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionReferenceVariant _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionReference _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionOperatorFunction _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionRecordAccessFunction _ ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value = expressionTypedNode.value
            }

        ExpressionNegation inNegation ->
            let
                inNegationMapped : TypedNode Expression
                inNegationMapped =
                    inNegation
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = inNegationMapped.type_
            , value =
                ExpressionNegation
                    inNegationMapped
            }

        ExpressionParenthesized inParens ->
            let
                inParensMapped : TypedNode Expression
                inParensMapped =
                    inParens
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = inParensMapped.type_
            , value =
                ExpressionParenthesized
                    inParensMapped
            }

        ExpressionRecordAccess expressionRecordAccess ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value =
                ExpressionRecordAccess
                    { record =
                        expressionRecordAccess.record
                            |> expressionTypedNodeMapTypes typeChange
                    , fieldName = expressionRecordAccess.fieldName
                    , fieldNameRange = expressionRecordAccess.fieldNameRange
                    }
            }

        ExpressionInfixOperation expressionInfixOperation ->
            let
                fullTypeMapped : Type
                fullTypeMapped =
                    expressionTypedNode.type_ |> typeChange

                leftMapped : TypedNode Expression
                leftMapped =
                    expressionInfixOperation.left
                        |> expressionTypedNodeMapTypes typeChange

                rightMapped : TypedNode Expression
                rightMapped =
                    expressionInfixOperation.right
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = fullTypeMapped
            , value =
                ExpressionInfixOperation
                    { operator =
                        { symbol = expressionInfixOperation.operator.symbol
                        , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                        , type_ =
                            TypeNotVariable
                                (TypeFunction
                                    { input = leftMapped.type_
                                    , output =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = rightMapped.type_
                                                , output = fullTypeMapped
                                                }
                                            )
                                    }
                                )
                        }
                    , left = leftMapped
                    , right = rightMapped
                    }
            }

        ExpressionTuple expressionTuple ->
            let
                part0Mapped : TypedNode Expression
                part0Mapped =
                    expressionTuple.part0
                        |> expressionTypedNodeMapTypes typeChange

                part1Mapped : TypedNode Expression
                part1Mapped =
                    expressionTuple.part1
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ =
                TypeNotVariable
                    (TypeTuple
                        { part0 = part0Mapped.type_
                        , part1 = part1Mapped.type_
                        }
                    )
            , value =
                ExpressionTuple
                    { part0 = part0Mapped
                    , part1 = part1Mapped
                    }
            }

        ExpressionTriple expressionTriple ->
            let
                part0Mapped : TypedNode Expression
                part0Mapped =
                    expressionTriple.part0
                        |> expressionTypedNodeMapTypes typeChange

                part1Mapped : TypedNode Expression
                part1Mapped =
                    expressionTriple.part1
                        |> expressionTypedNodeMapTypes typeChange

                part2Mapped : TypedNode Expression
                part2Mapped =
                    expressionTriple.part2
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ =
                TypeNotVariable
                    (TypeTriple
                        { part0 = part0Mapped.type_
                        , part1 = part1Mapped.type_
                        , part2 = part2Mapped.type_
                        }
                    )
            , value =
                ExpressionTriple
                    { part0 = part0Mapped
                    , part1 = part1Mapped
                    , part2 = part2Mapped
                    }
            }

        ExpressionIfThenElse expressionIfThenElse ->
            let
                onTrueMapped : TypedNode Expression
                onTrueMapped =
                    expressionIfThenElse.onTrue
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = onTrueMapped.type_
            , value =
                ExpressionIfThenElse
                    { condition =
                        expressionIfThenElse.condition
                            |> expressionTypedNodeMapTypes typeChange
                    , onTrue = onTrueMapped
                    , onFalse =
                        expressionIfThenElse.onFalse
                            |> expressionTypedNodeMapTypes typeChange
                    }
            }

        ExpressionList expressionListElements ->
            case expressionListElements of
                [] ->
                    { range = expressionTypedNode.range
                    , type_ = expressionTypedNode.type_ |> typeChange
                    , value = expressionListEmpty
                    }

                head :: tail ->
                    let
                        headMapped : TypedNode Expression
                        headMapped =
                            head
                                |> expressionTypedNodeMapTypes
                                    typeChange
                    in
                    { range = expressionTypedNode.range
                    , type_ = typeListList headMapped.type_
                    , value =
                        ExpressionList
                            (headMapped
                                :: (tail
                                        |> List.map
                                            (\element ->
                                                element
                                                    |> expressionTypedNodeMapTypes
                                                        typeChange
                                            )
                                   )
                            )
                    }

        ExpressionCall expressionCall ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value =
                ExpressionCall
                    { called =
                        expressionCall.called
                            |> expressionTypedNodeMapTypes typeChange
                    , argument0 =
                        expressionCall.argument0
                            |> expressionTypedNodeMapTypes typeChange
                    , argument1Up =
                        expressionCall.argument1Up
                            |> List.map
                                (\argument ->
                                    argument
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                )
                    }
            }

        ExpressionRecord expressionRecordFields ->
            { range = expressionTypedNode.range
            , type_ = expressionTypedNode.type_ |> typeChange
            , value =
                ExpressionRecord
                    (expressionRecordFields
                        |> List.map
                            (\field ->
                                { range = field.range
                                , name = field.name
                                , nameRange = field.nameRange
                                , value =
                                    field.value
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                }
                            )
                    )
            }

        ExpressionRecordUpdate expressionRecordUpdate ->
            let
                recordVariableTypeMapped : Type
                recordVariableTypeMapped =
                    expressionRecordUpdate.recordVariable.type_
                        |> typeChange
            in
            { range = expressionTypedNode.range
            , type_ = recordVariableTypeMapped
            , value =
                ExpressionRecordUpdate
                    { recordVariable =
                        { range = expressionRecordUpdate.recordVariable.range
                        , value = expressionRecordUpdate.recordVariable.value
                        , type_ = recordVariableTypeMapped
                        }
                    , field0 =
                        { range = expressionRecordUpdate.field0.range
                        , name = expressionRecordUpdate.field0.name
                        , nameRange = expressionRecordUpdate.field0.nameRange
                        , value =
                            expressionRecordUpdate.field0.value
                                |> expressionTypedNodeMapTypes
                                    typeChange
                        }
                    , field1Up =
                        expressionRecordUpdate.field1Up
                            |> List.map
                                (\field ->
                                    { range = field.range
                                    , name = field.name
                                    , nameRange = field.nameRange
                                    , value =
                                        field.value
                                            |> expressionTypedNodeMapTypes
                                                typeChange
                                    }
                                )
                    }
            }

        ExpressionLambda expressionLambda ->
            let
                parameter0Mapped : TypedNode Pattern
                parameter0Mapped =
                    expressionLambda.parameter0
                        |> patternTypedNodeMapTypes typeChange

                resultMapped : TypedNode Expression
                resultMapped =
                    expressionLambda.result
                        |> expressionTypedNodeMapTypes typeChange

                withParameter1UpMapped :
                    { parameters1UpMapped : List (TypedNode Pattern)
                    , fullTypeAfterParameter0 : Type
                    }
                withParameter1UpMapped =
                    expressionLambda.parameter1Up
                        |> List.foldr
                            (\argument soFar ->
                                let
                                    parameterMapped : TypedNode Pattern
                                    parameterMapped =
                                        argument |> patternTypedNodeMapTypes typeChange
                                in
                                { parameters1UpMapped =
                                    parameterMapped
                                        :: soFar.parameters1UpMapped
                                , fullTypeAfterParameter0 =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = parameterMapped.type_
                                            , output = soFar.fullTypeAfterParameter0
                                            }
                                        )
                                }
                            )
                            { parameters1UpMapped = []
                            , fullTypeAfterParameter0 =
                                resultMapped.type_
                            }
            in
            { range = expressionTypedNode.range
            , type_ =
                TypeNotVariable
                    (TypeFunction
                        { input = parameter0Mapped.type_
                        , output =
                            withParameter1UpMapped.fullTypeAfterParameter0
                        }
                    )
            , value =
                ExpressionLambda
                    { parameter0 = parameter0Mapped
                    , parameter1Up = withParameter1UpMapped.parameters1UpMapped
                    , result = resultMapped
                    }
            }

        ExpressionCaseOf expressionCaseOf ->
            let
                case0ResultMapped : TypedNode Expression
                case0ResultMapped =
                    expressionCaseOf.case0.result
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = case0ResultMapped.type_
            , value =
                ExpressionCaseOf
                    { matched =
                        expressionCaseOf.matched
                            |> expressionTypedNodeMapTypes typeChange
                    , case0 =
                        { pattern =
                            expressionCaseOf.case0.pattern
                                |> patternTypedNodeMapTypes typeChange
                        , result = case0ResultMapped
                        }
                    , case1Up =
                        expressionCaseOf.case1Up
                            |> List.map
                                (\case_ ->
                                    { pattern =
                                        case_.pattern
                                            |> patternTypedNodeMapTypes typeChange
                                    , result =
                                        case_.result
                                            |> expressionTypedNodeMapTypes typeChange
                                    }
                                )
                    }
            }

        ExpressionLetIn expressionLetIn ->
            let
                resultMapped : TypedNode Expression
                resultMapped =
                    expressionLetIn.result
                        |> expressionTypedNodeMapTypes typeChange
            in
            { range = expressionTypedNode.range
            , type_ = resultMapped.type_
            , value =
                ExpressionLetIn
                    { declaration0 =
                        { range = expressionLetIn.declaration0.range
                        , declaration =
                            expressionLetIn.declaration0.declaration
                                |> letDeclarationMapTypes typeChange
                        }
                    , declaration1Up =
                        expressionLetIn.declaration1Up
                            |> List.map
                                (\letDeclarationAndRange ->
                                    { range = letDeclarationAndRange.range
                                    , declaration =
                                        letDeclarationAndRange.declaration
                                            |> letDeclarationMapTypes typeChange
                                    }
                                )
                    , result = resultMapped
                    }
            }


letDeclarationMapTypes :
    (Type -> Type)
    -> LetDeclaration
    -> LetDeclaration
letDeclarationMapTypes typeChange expressionLetDeclaration =
    case expressionLetDeclaration of
        LetDestructuring letDestructuring ->
            LetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> patternTypedNodeMapTypes typeChange
                , expression =
                    letDestructuring.expression
                        |> expressionTypedNodeMapTypes typeChange
                }

        LetValueOrFunctionDeclaration letValueOrFunction ->
            LetValueOrFunctionDeclaration
                { signature = letValueOrFunction.signature
                , nameRange = letValueOrFunction.nameRange
                , name = letValueOrFunction.name
                , parameters =
                    letValueOrFunction.parameters
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    letValueOrFunction.result
                        |> expressionTypedNodeMapTypes typeChange
                , type_ =
                    letValueOrFunction.type_
                        |> typeChange
                }


expressionTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> TypedNode Expression
    -> Result String (TypedNode Expression)
expressionTypedNodeApplyVariableSubstitutions declarationTypes substitutions expressionTypedNode =
    if
        (substitutions.variableToType |> DictByTypeVariableFromContext.isEmpty)
            && (substitutions.equivalentVariables |> List.isEmpty)
    then
        Ok expressionTypedNode

    else
        case
            createBatchOfSubstitutionsToApply
                { declarationTypes = declarationTypes
                , range = expressionTypedNode.range
                }
                substitutions
        of
            Err error ->
                Err error

            Ok batchOfSubstitutionsToApply ->
                case
                    expressionTypedNode
                        |> expressionTypedNodeSubstituteVariableByType
                            declarationTypes
                            batchOfSubstitutionsToApply.substituteVariableByType
                of
                    Err error ->
                        Err error

                    Ok substitutedExpressionTypedNode ->
                        if substitutedExpressionTypedNode.unchanged then
                            Ok expressionTypedNode

                        else
                            case
                                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                    substitutedExpressionTypedNode.substitutions.variableToType
                                    substitutedExpressionTypedNode.substitutions.equivalentVariables
                                    batchOfSubstitutionsToApply.newEquivalentVariables
                            of
                                Err error ->
                                    Err error

                                Ok withNewEquivalentVariables ->
                                    expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                        withNewEquivalentVariables
                                        substitutedExpressionTypedNode.node


{-| Always remember to use the resulting `newEquivalentVariables`!
-}
createBatchOfSubstitutionsToApply :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , range : Elm.Syntax.Range.Range
    }
    -> VariableSubstitutions
    ->
        Result
            String
            { newEquivalentVariables : List EquivalentTypeVariableSet
            , substituteVariableByType :
                TypeVariableFromContext
                -> Maybe Type
            }
createBatchOfSubstitutionsToApply context substitutions =
    case
        substitutions.equivalentVariables
            |> createEquivalentVariablesToCondensedVariableLookup
    of
        Err error ->
            Err
                ("("
                    ++ (context.range |> rangeToInfoString)
                    ++ ") "
                    ++ error
                )

        Ok variableToCondensedLookup ->
            case
                substitutions.variableToType
                    |> variableToTypeSubstitutionsCondenseVariables
                        context
                        variableToCondensedLookup
            of
                Err error ->
                    Err error

                Ok variableToTypeWithCondensedVariables ->
                    case
                        variableToTypeWithCondensedVariables.variableToType
                            |> substitutionsVariableToTypeApplyOverItself context
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeSubstitutedOverItself ->
                            Ok
                                { newEquivalentVariables = variableToTypeWithCondensedVariables.equivalentVariables
                                , substituteVariableByType =
                                    \originalTypeVariable ->
                                        case
                                            variableToCondensedLookup
                                                |> DictByTypeVariableFromContext.get originalTypeVariable
                                        of
                                            Just condensedVariable ->
                                                Just
                                                    (case
                                                        variableToTypeSubstitutedOverItself
                                                            |> DictByTypeVariableFromContext.get condensedVariable
                                                     of
                                                        Nothing ->
                                                            TypeVariable condensedVariable

                                                        Just replacementTypeNotVariable ->
                                                            TypeNotVariable replacementTypeNotVariable
                                                    )

                                            Nothing ->
                                                variableToTypeSubstitutedOverItself
                                                    |> DictByTypeVariableFromContext.get originalTypeVariable
                                                    |> Maybe.map TypeNotVariable
                                }


patternTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> TypedNode Pattern
    -> Result String (TypedNode Pattern)
patternTypedNodeApplyVariableSubstitutions declarationTypes substitutions patternTypedNode =
    if
        (substitutions.variableToType |> DictByTypeVariableFromContext.isEmpty)
            && (substitutions.equivalentVariables |> List.isEmpty)
    then
        Ok patternTypedNode

    else
        case
            createBatchOfSubstitutionsToApply
                { declarationTypes = declarationTypes
                , range = patternTypedNode.range
                }
                substitutions
        of
            Err error ->
                Err error

            Ok batchOfSubstitutionsToApply ->
                case
                    patternTypedNode
                        |> patternTypedNodeSubstituteVariableByType
                            declarationTypes
                            batchOfSubstitutionsToApply.substituteVariableByType
                of
                    Err error ->
                        Err error

                    Ok substitutedPatternTypedNode ->
                        if substitutedPatternTypedNode.unchanged then
                            Ok patternTypedNode

                        else
                            case
                                equivalentVariableSetMergeIntoVariableSubstitutionsWithVariableToType
                                    substitutedPatternTypedNode.substitutions.variableToType
                                    substitutedPatternTypedNode.substitutions.equivalentVariables
                                    batchOfSubstitutionsToApply.newEquivalentVariables
                            of
                                Err error ->
                                    Err error

                                Ok withNewEquivalentVariables ->
                                    patternTypedNodeApplyVariableSubstitutions declarationTypes
                                        withNewEquivalentVariables
                                        substitutedPatternTypedNode.node


substitutionsVariableToTypeApplyOverItself :
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        DictByTypeVariableFromContext
            TypeNotVariable
    ->
        Result
            String
            (DictByTypeVariableFromContext
                TypeNotVariable
            )
substitutionsVariableToTypeApplyOverItself context variableToTypeInitial =
    if (variableToTypeInitial |> DictByTypeVariableFromContext.size) <= 1 then
        Ok variableToTypeInitial

    else
        -- TODO optimize by instead updating existing variableToTypeInitial
        -- and skipping when replacement type does not contain
        variableToTypeInitial
            |> DictByTypeVariableFromContext.foldlWhileOkFrom
                DictByTypeVariableFromContext.empty
                (\variable replacementTypeNotVariable soFar ->
                    Result.map
                        (\replacementTypeSubstituted ->
                            soFar
                                |> DictByTypeVariableFromContext.insertNoReplace variable
                                    replacementTypeSubstituted
                        )
                        (replacementTypeNotVariable
                            |> typeNotVariableFullyApplyVariableToTypeSubstitutions
                                context
                                (\replacementTypeVariable ->
                                    variableToTypeInitial
                                        |> DictByTypeVariableFromContext.get
                                            replacementTypeVariable
                                        |> Maybe.map TypeNotVariable
                                )
                        )
                )


typeNotVariableFullyApplyVariableToTypeSubstitutions :
    -- TODO do new substitutions need be tracked?
    { range : Elm.Syntax.Range.Range
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> TypeNotVariable
    -> Result String TypeNotVariable
typeNotVariableFullyApplyVariableToTypeSubstitutions context substitutionsToApply typeNotVariable =
    case
        -- TODO optimize by not tracking new substitutions
        typeNotVariable
            |> typeNotVariableSubstituteVariableByType context
                substitutionsToApply
    of
        Err error ->
            Err error

        Ok typeNotVariableSubstituted ->
            if typeNotVariableSubstituted.unchanged then
                Ok typeNotVariable

            else
                typeNotVariableFullyApplyVariableToTypeSubstitutions context
                    substitutionsToApply
                    typeNotVariableSubstituted.type_


patternTypedNodeSubstituteVariableByType :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        (TypeVariableFromContext
         -> Maybe Type
        )
    -> TypedNode Pattern
    ->
        Result
            String
            { unchanged : Bool
            , substitutions : VariableSubstitutions
            , node : TypedNode Pattern
            }
patternTypedNodeSubstituteVariableByType declarationTypes replacement patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternChar _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternString _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternInt _ ->
            Ok
                { unchanged = True
                , node = patternTypedNode
                , substitutions = variableSubstitutionsNone
                }

        PatternIgnored ->
            Result.map
                (\substituted ->
                    { unchanged = substituted.unchanged
                    , substitutions = substituted.substitutions
                    , node =
                        if substituted.unchanged then
                            patternTypedNode

                        else
                            { range = patternTypedNode.range
                            , value = PatternIgnored
                            , type_ = substituted.type_
                            }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = patternTypedNode.range
                        }
                        replacement
                )

        PatternVariable name ->
            Result.map
                (\substituted ->
                    if substituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = substituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value = PatternVariable name
                            , type_ = substituted.type_
                            }
                        }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByType
                        { declarationTypes = declarationTypes
                        , range = patternTypedNode.range
                        }
                        replacement
                )

        PatternParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value = PatternParenthesized inParensSubstituted.node
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (inParens
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        PatternAs patternAs ->
            Result.map
                (\inParensSubstituted ->
                    if inParensSubstituted.unchanged then
                        { unchanged = True
                        , node = patternTypedNode
                        , substitutions = variableSubstitutionsNone
                        }

                    else
                        { unchanged = False
                        , substitutions = inParensSubstituted.substitutions
                        , node =
                            { range = patternTypedNode.range
                            , value =
                                PatternAs
                                    { pattern = inParensSubstituted.node
                                    , variable =
                                        { range = patternAs.variable.range
                                        , value = patternAs.variable.value
                                        , type_ = inParensSubstituted.node.type_
                                        }
                                    }
                            , type_ = inParensSubstituted.node.type_
                            }
                        }
                )
                (patternAs.pattern
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        PatternListCons patternListCons ->
            resultAndThen2
                (\headSubstituted tailSubstituted ->
                    if headSubstituted.unchanged && tailSubstituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternListCons
                                            { head = headSubstituted.node
                                            , tail = tailSubstituted.node
                                            }
                                    , type_ = typeListList headSubstituted.node.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                headSubstituted.substitutions
                                tailSubstituted.substitutions
                            )
                )
                (patternListCons.head
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (patternListCons.tail
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        PatternTuple patternTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternTuple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTuple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                            )
                )
                (patternTuple.part0
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (patternTuple.part1
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        PatternTriple patternTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    if part0Substituted.unchanged && part1Substituted.unchanged && part2Substituted.unchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternTriple
                                            { part0 = part0Substituted.node
                                            , part1 = part1Substituted.node
                                            , part2 = part2Substituted.node
                                            }
                                    , type_ =
                                        TypeNotVariable
                                            (TypeTriple
                                                { part0 = part0Substituted.node.type_
                                                , part1 = part1Substituted.node.type_
                                                , part2 = part2Substituted.node.type_
                                                }
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge3
                                { declarationTypes = declarationTypes
                                , range = patternTypedNode.range
                                }
                                part0Substituted.substitutions
                                part1Substituted.substitutions
                                part2Substituted.substitutions
                            )
                )
                (patternTriple.part0
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (patternTriple.part1
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )
                (patternTriple.part2
                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                        replacement
                )

        PatternRecord patternRecordFields ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted fieldsSubstituted ->
                    if typeSubstituted.unchanged && fieldsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternRecord
                                            fieldsSubstituted.nodes
                                    , type_ =
                                        TypeNotVariable
                                            (TypeRecord
                                                (fieldsSubstituted.nodes
                                                    |> List.foldl
                                                        (\fieldSubstituted soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldSubstituted.value
                                                                    fieldSubstituted.type_
                                                        )
                                                        FastDict.empty
                                                )
                                            )
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                typeSubstituted.substitutions
                                fieldsSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (patternRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldTypeSubstituted ->
                                    if fieldTypeSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = fieldNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithField ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithField
                                                , nodes =
                                                    { value = fieldNode.value
                                                    , range = fieldNode.range
                                                    , type_ = fieldTypeSubstituted.type_
                                                    }
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldTypeSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (fieldNode.type_
                                    |> typeSubstituteVariableByType
                                        typeContext
                                        replacement
                                )
                        )
                )

        PatternListExact patternListElements ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    if typeSubstituted.unchanged && elementsSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternListExact
                                            elementsSubstituted.nodes
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge
                                typeContext
                                elementsSubstituted.substitutions
                                typeSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (patternListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\elementNode soFar ->
                            Result.andThen
                                (\fieldSubstituted ->
                                    if fieldSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes = elementNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithElement
                                                , nodes =
                                                    fieldSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                fieldSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (elementNode
                                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )

        PatternVariant patternVariant ->
            let
                typeContext : { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule, range : Elm.Syntax.Range.Range }
                typeContext =
                    { declarationTypes = declarationTypes
                    , range = patternTypedNode.range
                    }
            in
            resultAndThen2
                (\typeSubstituted valuesSubstituted ->
                    if typeSubstituted.unchanged && valuesSubstituted.allUnchanged then
                        Ok
                            { unchanged = True
                            , node = patternTypedNode
                            , substitutions = variableSubstitutionsNone
                            }

                    else
                        Result.map
                            (\fullSubstitutions ->
                                { unchanged = False
                                , substitutions = fullSubstitutions
                                , node =
                                    { range = patternTypedNode.range
                                    , value =
                                        PatternVariant
                                            { moduleOrigin = patternVariant.moduleOrigin
                                            , choiceTypeName = patternVariant.choiceTypeName
                                            , qualification = patternVariant.qualification
                                            , name = patternVariant.name
                                            , values = valuesSubstituted.nodes
                                            }
                                    , type_ = typeSubstituted.type_
                                    }
                                }
                            )
                            (variableSubstitutionsMerge typeContext
                                typeSubstituted.substitutions
                                valuesSubstituted.substitutions
                            )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByType
                        typeContext
                        replacement
                )
                (patternVariant.values
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmptyAllUnchangedTrue
                        (\argumentNode soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    if valueSubstituted.unchanged then
                                        Ok
                                            { allUnchanged = soFar.allUnchanged
                                            , substitutions = soFar.substitutions
                                            , nodes =
                                                argumentNode :: soFar.nodes
                                            }

                                    else
                                        Result.map
                                            (\substitutionsWithElement ->
                                                { allUnchanged = False
                                                , substitutions = substitutionsWithElement
                                                , nodes =
                                                    valueSubstituted.node
                                                        :: soFar.nodes
                                                }
                                            )
                                            (variableSubstitutionsMerge
                                                typeContext
                                                valueSubstituted.substitutions
                                                soFar.substitutions
                                            )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByType declarationTypes
                                        replacement
                                )
                        )
                )


substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , updatedValueOrFunctionTypes :
        FastDict.Dict
            String
            { range : Elm.Syntax.Range.Range
            , type_ : Type
            }
    , nodes : List node_
    }
substitutionsNoneNodesEmptyUpdatedValueOrFunctionTypesDictEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , updatedValueOrFunctionTypes = FastDict.empty
    , nodes = []
    }


substitutionsNoneNodesEmptyAllUnchangedTrue :
    { allUnchanged : Bool
    , substitutions : VariableSubstitutions
    , nodes : List node_
    }
substitutionsNoneNodesEmptyAllUnchangedTrue =
    { allUnchanged = True
    , substitutions = variableSubstitutionsNone
    , nodes = []
    }


patternTypedNodeMapTypeVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> TypedNode Pattern
    -> TypedNode Pattern
patternTypedNodeMapTypeVariables typeVariableChange patternTypedNode =
    patternTypedNode
        |> patternTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


patternTypedNodeMapTypes :
    (Type -> Type)
    -> TypedNode Pattern
    -> TypedNode Pattern
patternTypedNodeMapTypes typeChange patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            patternTypedNode

        PatternChar _ ->
            patternTypedNode

        PatternString _ ->
            patternTypedNode

        PatternInt _ ->
            patternTypedNode

        PatternIgnored ->
            { range = patternTypedNode.range
            , type_ = patternTypedNode.type_ |> typeChange
            , value = PatternIgnored
            }

        PatternVariable _ ->
            { range = patternTypedNode.range
            , type_ = patternTypedNode.type_ |> typeChange
            , value = patternTypedNode.value
            }

        PatternParenthesized inParens ->
            let
                inParensMapped : TypedNode Pattern
                inParensMapped =
                    inParens
                        |> patternTypedNodeMapTypes typeChange
            in
            { range = patternTypedNode.range
            , type_ = inParensMapped.type_
            , value = PatternParenthesized inParensMapped
            }

        PatternAs patternAs ->
            let
                aliasedPatternMapped : TypedNode Pattern
                aliasedPatternMapped =
                    patternAs.pattern
                        |> patternTypedNodeMapTypes typeChange
            in
            { range = patternTypedNode.range
            , type_ = aliasedPatternMapped.type_
            , value =
                PatternAs
                    { pattern = aliasedPatternMapped
                    , variable =
                        { range = patternAs.variable.range
                        , value = patternAs.variable.value
                        , type_ = aliasedPatternMapped.type_
                        }
                    }
            }

        PatternListCons patternListCons ->
            let
                headMapped : TypedNode Pattern
                headMapped =
                    patternListCons.head
                        |> patternTypedNodeMapTypes typeChange
            in
            { range = patternTypedNode.range
            , type_ = typeListList headMapped.type_
            , value =
                PatternListCons
                    { head = headMapped
                    , tail =
                        patternListCons.tail
                            |> patternTypedNodeMapTypes typeChange
                    }
            }

        PatternTuple patternTuple ->
            let
                part0Mapped : TypedNode Pattern
                part0Mapped =
                    patternTuple.part0
                        |> patternTypedNodeMapTypes typeChange

                part1Mapped : TypedNode Pattern
                part1Mapped =
                    patternTuple.part1
                        |> patternTypedNodeMapTypes typeChange
            in
            { range = patternTypedNode.range
            , type_ =
                TypeNotVariable
                    (TypeTuple
                        { part0 = part0Mapped.type_
                        , part1 = part1Mapped.type_
                        }
                    )
            , value =
                PatternTuple
                    { part0 = part0Mapped
                    , part1 = part1Mapped
                    }
            }

        PatternTriple patternTriple ->
            let
                part0Mapped : TypedNode Pattern
                part0Mapped =
                    patternTriple.part0
                        |> patternTypedNodeMapTypes typeChange

                part1Mapped : TypedNode Pattern
                part1Mapped =
                    patternTriple.part1
                        |> patternTypedNodeMapTypes typeChange

                part2Mapped : TypedNode Pattern
                part2Mapped =
                    patternTriple.part2
                        |> patternTypedNodeMapTypes typeChange
            in
            { range = patternTypedNode.range
            , type_ =
                TypeNotVariable
                    (TypeTriple
                        { part0 = part0Mapped.type_
                        , part1 = part1Mapped.type_
                        , part2 = part2Mapped.type_
                        }
                    )
            , value =
                PatternTriple
                    { part0 = part0Mapped
                    , part1 = part1Mapped
                    , part2 = part2Mapped
                    }
            }

        PatternRecord patternRecordFields ->
            { range = patternTypedNode.range
            , type_ = patternTypedNode.type_ |> typeChange
            , value =
                PatternRecord
                    (patternRecordFields
                        |> List.map
                            (\field ->
                                { value = field.value
                                , range = field.range
                                , type_ = field.type_ |> typeChange
                                }
                            )
                    )
            }

        PatternListExact patternListElements ->
            case patternListElements of
                [] ->
                    { range = patternTypedNode.range
                    , type_ = patternTypedNode.type_ |> typeChange
                    , value = patternListExactEmpty
                    }

                head :: tail ->
                    let
                        headMapped : TypedNode Pattern
                        headMapped =
                            head
                                |> patternTypedNodeMapTypes
                                    typeChange
                    in
                    { range = patternTypedNode.range
                    , type_ = typeListList headMapped.type_
                    , value =
                        PatternListExact
                            (headMapped
                                :: (tail
                                        |> List.map
                                            (\element ->
                                                element
                                                    |> patternTypedNodeMapTypes
                                                        typeChange
                                            )
                                   )
                            )
                    }

        PatternVariant patternVariant ->
            { range = patternTypedNode.range
            , type_ = patternTypedNode.type_ |> typeChange
            , value =
                PatternVariant
                    { moduleOrigin = patternVariant.moduleOrigin
                    , choiceTypeName = patternVariant.choiceTypeName
                    , qualification = patternVariant.qualification
                    , name = patternVariant.name
                    , values =
                        patternVariant.values
                            |> List.map
                                (\argument ->
                                    argument
                                        |> patternTypedNodeMapTypes
                                            typeChange
                                )
                    }
            }


equivalentVariablesCreateCondensedVariable : EquivalentTypeVariableSet -> Result String TypeVariableFromContext
equivalentVariablesCreateCondensedVariable set =
    -- TODO figure out why getMaxKey for example doesn't work. Makes no sense to me
    case set.variables |> DictByTypeVariableFromContext.getMinKey of
        Nothing ->
            Err "implementation bug: equivalent variable set is empty"

        Just variable0 ->
            Ok
                { useRange = set.overarchingUseRange
                , name =
                    case set.constraint of
                        Nothing ->
                            variable0.name

                        Just unifiedConstraint ->
                            unifiedConstraint |> typeVariableConstraintToString
                }


maybeTypeVariableConstraintToString : Maybe TypeVariableConstraint -> String
maybeTypeVariableConstraintToString maybeConstraint =
    case maybeConstraint of
        Nothing ->
            ""

        Just constraint ->
            constraint |> typeVariableConstraintToString


typeVariableConstraintToString : TypeVariableConstraint -> String
typeVariableConstraintToString constraint =
    case constraint of
        TypeVariableConstraintNumber ->
            "number"

        TypeVariableConstraintAppendable ->
            "appendable"

        TypeVariableConstraintComparable ->
            "comparable"

        TypeVariableConstraintCompappend ->
            "compappend"


fastDictFoldlWhileOkFrom : ok -> (key -> value -> ok -> Result err ok) -> FastDict.Dict key value -> Result err ok
fastDictFoldlWhileOkFrom initialFolded reduceToResult fastDict =
    fastDict
        |> -- we could use stoppableFoldl with some overhead for the case that all are ok
           -- but elm-syntax-type-infer optimizes for the more common case
           FastDict.foldl
            (\key value soFarOrError ->
                case soFarOrError of
                    Err error ->
                        Err error

                    Ok soFar ->
                        reduceToResult key value soFar
            )
            (Ok initialFolded)


fastDictMapAndSmallestJust : (key -> value -> Maybe ok) -> FastDict.Dict key value -> Maybe ok
fastDictMapAndSmallestJust keyValueToMaybe fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value _ ->
                case keyValueToMaybe key value of
                    Just foldedWithEntry ->
                        FastDict.Stop (Just foldedWithEntry)

                    Nothing ->
                        fastDictContinueNothing
            )
            Nothing


fastDictContinueNothing : FastDict.Step (Maybe folded_)
fastDictContinueNothing =
    FastDict.Continue Nothing


parameterPatternsTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
    ->
        Result
            String
            { introducedExpressionVariables :
                FastDict.Dict String Type
            , nodes :
                List (TypedNode Pattern)
            }
parameterPatternsTypeInfer context parameterPatterns =
    parameterPatterns
        |> listFoldrWhileOkFrom
            introducedExpressionVariablesEmptyNodesEmpty
            (\pattern soFar ->
                Result.map
                    (\patternInferred ->
                        { nodes =
                            patternInferred
                                :: soFar.nodes
                        , introducedExpressionVariables =
                            FastDict.union soFar.introducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                    )
                    (pattern |> patternTypeInfer context)
            )
        |> Result.map
            (\folded ->
                { introducedExpressionVariables = folded.introducedExpressionVariables
                , nodes = folded.nodes
                }
            )


introducedExpressionVariablesEmptyNodesEmpty :
    { introducedExpressionVariables : FastDict.Dict String Type
    , nodes : List node_
    }
introducedExpressionVariablesEmptyNodesEmpty =
    { introducedExpressionVariables = FastDict.empty
    , nodes = []
    }


{-| Extract all known types
from module [metadata](https://dark.elm.dmy.fr/packages/elm/project-metadata-utils/latest/),
usually from parsing the `docs.json` of a dependency.

For elm-syntax modules, use [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)

-}
moduleInterfaceToTypes :
    Elm.Docs.Module
    -> { types : ModuleTypes, errors : List String }
moduleInterfaceToTypes moduleInterface =
    let
        typeAliases :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { type_ : Type
                    , parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    }
            }
        typeAliases =
            moduleInterface.aliases
                |> List.foldl
                    (\typeAliasDeclarationInterface soFar ->
                        case
                            typeAliasDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            typeAliasDeclarationInterface.name
                                            { type_ = type_
                                            , parameters = typeAliasDeclarationInterface.args
                                            , recordFieldOrder =
                                                case typeAliasDeclarationInterface.tipe of
                                                    Elm.Type.Record fields Nothing ->
                                                        Just (fields |> List.map (\( name, _ ) -> name))

                                                    Elm.Type.Record _ (Just _) ->
                                                        Nothing

                                                    Elm.Type.Var _ ->
                                                        Nothing

                                                    Elm.Type.Lambda _ _ ->
                                                        Nothing

                                                    Elm.Type.Tuple _ ->
                                                        Nothing

                                                    Elm.Type.Type _ _ ->
                                                        Nothing
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        choiceTypes :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (List Type)
                    }
            }
        choiceTypes =
            moduleInterface.unions
                |> List.foldl
                    (\declarationChoiceType soFar ->
                        case
                            declarationChoiceType.tags
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\( variantName, variantValueInterfaces ) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert variantName
                                                        variantValues
                                            )
                                            (variantValueInterfaces
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue |> interfaceToType
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            declarationChoiceType.name
                                            { parameters =
                                                declarationChoiceType.args
                                            , variants = variants
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        signatures : { errors : List String, types : FastDict.Dict String Type }
        signatures =
            moduleInterface.values
                |> List.foldl
                    (\valueOrFunctionDeclarationInterface soFar ->
                        case
                            valueOrFunctionDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            valueOrFunctionDeclarationInterface.name
                                            type_
                                }
                    )
                    typesDictEmptyErrorsEmpty
    in
    { errors =
        typeAliases.errors
            ++ choiceTypes.errors
            ++ signatures.errors
    , types =
        { typeAliases = typeAliases.types
        , choiceTypes = choiceTypes.types
        , signatures = signatures.types
        }
    }


typesDictEmptyErrorsEmpty : { types : FastDict.Dict String info_, errors : List error_ }
typesDictEmptyErrorsEmpty =
    { types = FastDict.empty
    , errors = []
    }


interfaceToType : Elm.Type.Type -> Result String Type
interfaceToType typeInterface =
    -- IGNORE TCO
    case typeInterface of
        Elm.Type.Var name ->
            Ok
                (TypeVariable
                    { useRange = Elm.Syntax.Range.empty
                    , name = name
                    }
                )

        Elm.Type.Lambda functionInput functionOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (functionInput |> interfaceToType)
                (functionOutput |> interfaceToType)

        Elm.Type.Tuple parts ->
            case parts of
                [] ->
                    okTypeUnit

                [ inParens ] ->
                    inParens |> interfaceToType

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (tuplePart1 |> interfaceToType)
                        (tuplePart0 |> interfaceToType)

                [ triplePart0, triplePart1, triplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (triplePart0 |> interfaceToType)
                        (triplePart1 |> interfaceToType)
                        (triplePart2 |> interfaceToType)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Type.Type reference argumentInterfaces ->
            case reference |> splitIntoBeforeAndAfterLastDot of
                Just beforeAndAfterLastDot ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = beforeAndAfterLastDot.beforeLastDot
                                    , name = beforeAndAfterLastDot.afterLastDot
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentInterfaces |> listMapAndCombineOk interfaceToType)

                Nothing ->
                    Err "invalid reference"

        Elm.Type.Record fieldInterfaces Nothing ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )

        Elm.Type.Record fieldInterfaces (Just extendedRecordVariable) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { fields = fields
                            , recordVariable =
                                { useRange = Elm.Syntax.Range.empty
                                , name = extendedRecordVariable
                                }
                            }
                        )
                )
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )


splitIntoBeforeAndAfterLastDot :
    String
    ->
        Maybe
            { beforeLastDot : String
            , afterLastDot : String
            }
splitIntoBeforeAndAfterLastDot string =
    -- TODO optimize
    case string |> String.split "." |> List.reverse of
        referenceName :: referenceModulePartLast :: referenceModulePartBeforeLastDown ->
            Just
                { beforeLastDot =
                    (referenceModulePartLast :: referenceModulePartBeforeLastDown)
                        |> List.reverse
                        |> String.join "."
                , afterLastDot = referenceName
                }

        [ _ ] ->
            Nothing

        [] ->
            Nothing


okTypeUnit : Result error_ Type
okTypeUnit =
    Ok (TypeNotVariable TypeUnit)


{-| Extract all known types
from declarations within a module.
Un-annotated value/function declarations are ignored.

For dependency modules, use [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

-}
moduleDeclarationsToTypes :
    { moduleOriginLookup : ModuleOriginLookup
    , moduleName : String
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Declaration.Declaration)
    -> { types : ModuleTypes, errors : List String }
moduleDeclarationsToTypes context declarations =
    let
        typeConstructModuleOriginLookup :
            FastDict.Dict
                -- qualification
                String
                (FastDict.Dict
                    -- name
                    String
                    String
                )
        typeConstructModuleOriginLookup =
            context.moduleOriginLookup.typeConstructs
                |> FastDict.update ""
                    (\contextExposedTypeConstructsOrNothing ->
                        declarations
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                    case declaration of
                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            soFar

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            soFar

                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                            soFar

                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                            soFar

                                        Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                                            soFar
                                                |> FastDict.insert
                                                    (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                    context.moduleName

                                        Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                                            soFar
                                                |> FastDict.insert
                                                    (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                    context.moduleName
                                )
                                (contextExposedTypeConstructsOrNothing
                                    |> Maybe.withDefault FastDict.empty
                                )
                            |> Just
                    )
    in
    declarations
        |> List.foldl
            (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                case declaration of
                    Elm.Syntax.Declaration.InfixDeclaration _ ->
                        soFar

                    Elm.Syntax.Declaration.Destructuring _ _ ->
                        { errors =
                            "destructuring at the module level is invalid syntax"
                                :: soFar.errors
                        , types = soFar.types
                        }

                    Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                        case declarationValueOrFunction.signature of
                            Nothing ->
                                soFar

                            Just (Elm.Syntax.Node.Node _ declarationValueOrFunctionSignature) ->
                                case
                                    declarationValueOrFunctionSignature.typeAnnotation
                                        |> syntaxToType typeConstructModuleOriginLookup
                                of
                                    Err error ->
                                        { errors = error :: soFar.errors
                                        , types = soFar.types
                                        }

                                    Ok type_ ->
                                        { errors = soFar.errors
                                        , types =
                                            { signatures =
                                                soFar.types.signatures
                                                    |> FastDict.insert
                                                        (declarationValueOrFunctionSignature.name |> Elm.Syntax.Node.value)
                                                        type_
                                            , typeAliases = soFar.types.typeAliases
                                            , choiceTypes = soFar.types.choiceTypes
                                            }
                                        }

                    Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                        case
                            declarationTypeAlias.typeAnnotation
                                |> syntaxToType typeConstructModuleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases =
                                        soFar.types.typeAliases
                                            |> FastDict.insert
                                                (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationTypeAlias.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , type_ = type_
                                                , recordFieldOrder =
                                                    case declarationTypeAlias.typeAnnotation |> Elm.Syntax.Node.value of
                                                        Elm.Syntax.TypeAnnotation.Record fields ->
                                                            Just
                                                                (fields
                                                                    |> List.map
                                                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                                                            name
                                                                        )
                                                                )

                                                        Elm.Syntax.TypeAnnotation.GenericType _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Unit ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                                                            Nothing
                                                }
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }

                    Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                        case
                            declarationChoiceType.constructors
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\(Elm.Syntax.Node.Node _ variant) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        (variant.name |> Elm.Syntax.Node.value)
                                                        variantValues
                                            )
                                            (variant.arguments
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue
                                                            |> syntaxToType
                                                                typeConstructModuleOriginLookup
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes =
                                        soFar.types.choiceTypes
                                            |> FastDict.insert
                                                (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationChoiceType.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , variants = variants
                                                }
                                    }
                                }

                    Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                        case
                            declarationPortSignature.typeAnnotation
                                |> syntaxToType typeConstructModuleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures =
                                        soFar.types.signatures
                                            |> FastDict.insert
                                                (declarationPortSignature.name |> Elm.Syntax.Node.value)
                                                type_
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }
            )
            typesEmptyAndErrorsEmpty


typesEmptyAndErrorsEmpty : { types : ModuleTypes, errors : List error_ }
typesEmptyAndErrorsEmpty =
    { types = moduleTypesEmpty
    , errors = []
    }


moduleTypesEmpty : ModuleTypes
moduleTypesEmpty =
    { signatures = FastDict.empty
    , typeAliases = FastDict.empty
    , choiceTypes = FastDict.empty
    }


typeVariablesFromContextToDisambiguationLookup :
    TypeVariableFromContextSet
    -> DictByTypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookup variables =
    variables
        |> DictByTypeVariableFromContext.foldl
            (\variable () soFar ->
                let
                    alreadyExists : String -> Bool
                    alreadyExists toDisambiguate =
                        soFar
                            |> DictByTypeVariableFromContext.any
                                (\_ diambiguatedVariableSoFar ->
                                    diambiguatedVariableSoFar == toDisambiguate
                                )

                    variableAsDisambiguatedString : String
                    variableAsDisambiguatedString =
                        variable.name |> nameDisambiguateBy alreadyExists
                in
                soFar
                    |> DictByTypeVariableFromContext.insertNoReplace variable
                        variableAsDisambiguatedString
            )
            DictByTypeVariableFromContext.empty


nameDisambiguateBy : (String -> Bool) -> String -> String
nameDisambiguateBy alreadyExists currentName =
    nameDisambiguateWithIndexBy 0 alreadyExists currentName


nameDisambiguateWithIndexBy : Int -> (String -> Bool) -> String -> String
nameDisambiguateWithIndexBy index alreadyExists currentName =
    let
        indexedCurrentName : String
        indexedCurrentName =
            case index of
                0 ->
                    currentName

                indexAtLeast1 ->
                    currentName ++ (indexAtLeast1 |> String.fromInt) ++ ""
    in
    if alreadyExists indexedCurrentName then
        nameDisambiguateWithIndexBy (index + 1) alreadyExists currentName

    else
        indexedCurrentName


fastDictAny : (value -> Bool) -> FastDict.Dict key_ value -> Bool
fastDictAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.value
                    || state.left ()
                    || state.right ()
            )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


listFoldl2WhileOkFrom :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> Result error state)
    -> Result error state
listFoldl2WhileOkFrom initialState aList bList reduce =
    case aList of
        [] ->
            Ok initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    Ok initialState

                bHead :: bTail ->
                    case reduce aHead bHead initialState of
                        Err error ->
                            Err error

                        Ok stateAfterReducingHeads ->
                            listFoldl2WhileOkFrom
                                stateAfterReducingHeads
                                aTail
                                bTail
                                reduce


listFoldlWhileOkFromResult :
    Result err okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFromResult initialResult reduceOnOk list =
    case initialResult of
        Err error ->
            Err error

        Ok initialOkFolded ->
            listFoldlWhileOkFrom initialOkFolded reduceOnOk list


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


{-| Prefer `listFoldlWhileOkFrom` whenever you don't need to reverse the result
-}
listFoldrWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldrWhileOkFrom initialOkFolded reduceOnOk list =
    list
        |> List.foldr
            (\element soFar ->
                case soFar of
                    Err error ->
                        Err error

                    Ok soFarOk ->
                        soFarOk |> reduceOnOk element
            )
            (Ok initialOkFolded)


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


resultAndThen3 :
    (a -> b -> c -> Result error d)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
resultAndThen3 abToResult aResult bResult cResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            abToResult a b c


resultAndThen4 :
    (a -> b -> c -> d -> Result error e)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
    -> Result error e
resultAndThen4 abToResult aResult bResult cResult dResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            case dResult of
                                Err error ->
                                    Err error

                                Ok d ->
                                    abToResult a b c d


elmCoreTypesGeneratedFromDocsJson :
    FastDict.Dict
        String
        ModuleTypes
elmCoreTypesGeneratedFromDocsJson =
    FastDict.fromList
        [ ( "Array"
          , { signatures =
                FastDict.fromList
                    [ ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Array"
                                , name = "Array"
                                , arguments =
                                    [ TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "initialize"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "push"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Array"
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toIndexedList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Array"
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Array"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "Basics"
          , { signatures =
                FastDict.fromList
                    [ ( "abs"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "acos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "always"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    , ( "asin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "ceiling"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "clamp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "number"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name =
                                                                    "number"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name =
                                                                    "number"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "compare"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Order"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "degrees"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "e"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "floor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "isInfinite"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isNaN"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "logBase"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "max"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    , ( "min"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    , ( "modBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "never"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Never"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "not"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pi"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "radians"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remainderBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "round"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sqrt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "tan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "truncate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "turns"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bool"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "True", [] ), ( "False", [] ) ]
                        }
                      )
                    , ( "Float"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Int"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Never"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Order"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "LT", [] ), ( "EQ", [] ), ( "GT", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bitwise"
          , { signatures =
                FastDict.fromList
                    [ ( "and"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "complement"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "or"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftLeftBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightZfBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( "Char"
          , { signatures =
                FastDict.fromList
                    [ ( "fromCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlpha"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlphaNum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isHexDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isOctDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Char"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Debug"
          , { signatures =
                FastDict.fromList
                    [ ( "log"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toString"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "todo"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( "Dict"
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Dict"
                                , name = "Dict"
                                , arguments =
                                    [ TypeVariable
                                        { name = "k"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , TypeVariable
                                        { name = "v"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keys"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "k"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "k"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "merge"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "b"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "b"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Dict"
                                                                                , name =
                                                                                    "Dict"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "comparable"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Dict"
                                                                                            , name =
                                                                                                "Dict"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "comparable"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "b"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "k"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "update"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "values"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Dict"
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "v"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Dict"
                      , { parameters = [ "k", "v" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "List"
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concatMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "drop"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filterMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "head"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersperse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "List"
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "List"
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "List"
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "List"
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "List"
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maximum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "minimum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "product"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "number"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "range"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sort"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Order"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "number"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "number"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "tail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "take"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unzip"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.singleton
                    "List"
                    { parameters = [ "a" ], variants = FastDict.empty }
            }
          )
        , ( "Maybe"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Maybe"
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Maybe"
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Maybe"
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Maybe"
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Maybe"
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Maybe"
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Maybe"
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Maybe"
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Maybe"
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Maybe"
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Maybe"
                      , { parameters = [ "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Just"
                                  , [ TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Nothing", [] )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Platform"
          , { signatures =
                FastDict.fromList
                    [ ( "sendToApp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Platform"
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sendToSelf"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Platform"
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "worker"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecord
                                            (FastDict.fromList
                                                [ ( "init"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    { name =
                                                                        "flags"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeTuple
                                                                        { part0 =
                                                                            TypeVariable
                                                                                { name =
                                                                                    "model"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                        , part1 =
                                                                            TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Platform.Cmd"
                                                                                    , name =
                                                                                        "Cmd"
                                                                                    , arguments =
                                                                                        [ TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "subscriptions"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    { name =
                                                                        "model"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Platform.Sub"
                                                                        , name =
                                                                            "Sub"
                                                                        , arguments =
                                                                            [ TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "update"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            TypeVariable
                                                                                { name =
                                                                                    "model"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                        , output =
                                                                            TypeNotVariable
                                                                                (TypeTuple
                                                                                    { part0 =
                                                                                        TypeVariable
                                                                                            { name =
                                                                                                "model"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                    , part1 =
                                                                                        TypeNotVariable
                                                                                            (TypeConstruct
                                                                                                { moduleOrigin =
                                                                                                    "Platform.Cmd"
                                                                                                , name =
                                                                                                    "Cmd"
                                                                                                , arguments =
                                                                                                    [ TypeVariable
                                                                                                        { name =
                                                                                                            "msg"
                                                                                                        , useRange =
                                                                                                            Elm.Syntax.Range.empty
                                                                                                        }
                                                                                                    ]
                                                                                                }
                                                                                            )
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Platform"
                                            , name = "Program"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "flags"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "model"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "ProcessId"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Program"
                      , { parameters = [ "flags", "model", "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Router"
                      , { parameters = [ "appMsg", "selfMsg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Task"
                      , { parameters = [ "err", "ok" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "Platform.Cmd"
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Platform.Cmd"
                                            , name = "Cmd"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Platform.Cmd"
                                , name = "Cmd"
                                , arguments =
                                    [ TypeVariable
                                        { name = "msg"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Cmd"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "Platform.Sub"
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Platform.Sub"
                                            , name = "Sub"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Platform.Sub"
                                , name = "Sub"
                                , arguments =
                                    [ TypeVariable
                                        { name = "msg"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Sub"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "Process"
          , { signatures =
                FastDict.fromList
                    [ ( "kill"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Process"
                                            , name = "Id"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sleep"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "spawn"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "y"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Process"
                                                        , name = "Id"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Id"
                      , { parameters = []
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = "Platform"
                                    , name = "ProcessId"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( "Result"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Result"
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Result"
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Result"
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Result"
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Result"
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Result"
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Result"
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Result"
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Result"
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Result"
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Result"
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Result"
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Result"
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "x"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            , TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Result"
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "x"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            , TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "y"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Result"
                                            , name = "Result"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Result"
                      , { parameters = [ "error", "value" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Ok"
                                  , [ TypeVariable
                                        { name = "value"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Err"
                                  , [ TypeVariable
                                        { name = "error"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Set"
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = "Set"
                                , name = "Set"
                                , arguments =
                                    [ TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Set"
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Set"
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "comparable2"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable2"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Set"
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Set"
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "comparable"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "comparable"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Set"
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "comparable"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "comparable"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Set"
                      , { parameters = [ "t" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( "String"
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "contains"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "endsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromChar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Char"
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexes"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indices"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "join"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "left"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lines"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pad"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replace"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "right"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "startsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "Char"
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trim"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uncons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Char"
                                                                    , name =
                                                                        "Char"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "words"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "String"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Task"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attempt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Task"
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Task"
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Task"
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Task"
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Task"
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Task"
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Task"
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Task"
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Task"
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Task"
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Task"
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        { name =
                                                                                            "x"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Task"
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    { name =
                                                                                                        "x"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                , TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Task"
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "x"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            , TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Task"
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                { name =
                                                                                                                    "x"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            , TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "y"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "onError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "perform"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Never"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "Task"
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            , TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = "Task"
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                , TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Task"
                      , { parameters = [ "x", "a" ]
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = "Platform"
                                    , name = "Task"
                                    , arguments =
                                        [ TypeVariable
                                            { name = "x"
                                            , useRange = Elm.Syntax.Range.empty
                                            }
                                        , TypeVariable
                                            { name = "a"
                                            , useRange = Elm.Syntax.Range.empty
                                            }
                                        ]
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( "Tuple"
          , { signatures =
                FastDict.fromList
                    [ ( "first"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , part1 =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    , ( "mapBoth"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            { name =
                                                                                "x"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        TypeVariable
                                                                            { name =
                                                                                "y"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapFirst"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "x"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "x"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapSecond"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeVariable
                                                    { name = "y"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "y"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pair"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "second"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , part1 =
                                                TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    TypeVariable
                                        { name = "b"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        ]
