module ElmSyntaxTypeInfer exposing
    ( valueAndFunctionDeclarations
    , ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
    , ModuleOriginLookup, importsToModuleOriginLookup
    , TypedNode, Expression(..), LetDeclaration(..), Pattern(..), Base10Or16(..)
    , Type(..), TypeNotVariable(..)
    )

{-| Add type information to the nodes
of an [elm-syntax](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/) tree.

@docs valueAndFunctionDeclarations

## context

@docs ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
@docs ModuleOriginLookup, importsToModuleOriginLookup


## syntax

@docs TypedNode, Expression, LetDeclaration, Pattern, Base10Or16
@docs Type, TypeNotVariable

If you are interested in exposing helpers like `expressionMapType`,
[open an issue](https://github.com/lue-bird/elm-syntax-type-infer/issues/new)

-}

import Elm.Docs
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.Import
import Elm.Syntax.ModuleName
import Elm.Syntax.Node
import Elm.Syntax.Pattern
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import Elm.Type
import FastDict
import FastSet


{-| Known types of members in a module.
Create with [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)
-}
type alias ModuleTypes =
    { signatures :
        -- value, function, port
        FastDict.Dict String (Type String)
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : Type String
            , recordFieldOrder : Maybe (List String)
            }
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List (Type String))
            }
    }


{-| [`ModuleTypes`](#ModuleTypes) exposed in `elm/core`.

Please _always_ start with [`elmCoreTypes`](#elmCoreTypes)
and add further module info with [`FastDict.union`]()
using [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

And if for some reason you already know used dependencies at compile time,
you can re-use the [code generator used for these elm/core types](https://github.com/lue-bird/elm-syntax-type-infer/tree/main/codegen)

-}
elmCoreTypes :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypes =
    elmCoreTypesGeneratedFromDocsJson


{-| When syntax _introduces_ type variables from another "context" (another (let) declaration, another branch, another element, ...)
we need to differentiate these from variables in the current "context"

For example,

    ( 0, 1 )
    -- ( number, number )
    ( identity, List.map identity )
    -- ( a -> a, List a -> List a )

would be incorrect inferences because
the `number` in `0` and `1` or `a` in `identity` and `List.map` are not related
and can be different types.
So in practice these are

    ( 0, 1 )
    -- ( ( [ "0" ], "number" ), ( [ "1" ], "number" ) )
    ( identity, List.map identity )
    -- ( ( [ "0" ], "a" ) -> ( [ "0" ], "a" )
    -- , List ( [ "1", "argument0" ], "a" )
    --   -> List ( [ "1", "argument0" ], "a" )
    -- )

`"0"` and `"1"` referring to the tuple part location
and `"argument0"` referring to the applied argument index.

We could work with some kind of name disambiguation system
but preserving names and context is usually nicer
for the final inferred variable names.

Performance note: `TypeVariableFromContext` is a tuple to allow for internal use as a dict key.

-}
type alias TypeVariableFromContext =
    ( -- path inner to outer
      List String
    , String
    )


type TypeVariableConstraint
    = TypeVariableConstraintNumber
    | TypeVariableConstraintAppendable
    | TypeVariableConstraintComparable
    | TypeVariableConstraintCompappend


typeVariableIgnoringContext : TypeVariableFromContext -> String
typeVariableIgnoringContext ( _, name ) =
    name


typeVariableConstraint : String -> Maybe TypeVariableConstraint
typeVariableConstraint variableName =
    if variableName |> String.startsWith "number" then
        justTypeVariableConstraintNumber

    else if variableName |> String.startsWith "appendable" then
        justTypeVariableConstraintAppendable

    else if variableName |> String.startsWith "comparable" then
        justTypeVariableConstraintComparable

    else if variableName |> String.startsWith "compappend" then
        justTypeVariableConstraintCompappend

    else
        Nothing


justTypeVariableConstraintCompappend : Maybe TypeVariableConstraint
justTypeVariableConstraintCompappend =
    Just TypeVariableConstraintCompappend


justTypeVariableConstraintComparable : Maybe TypeVariableConstraint
justTypeVariableConstraintComparable =
    Just TypeVariableConstraintComparable


justTypeVariableConstraintAppendable : Maybe TypeVariableConstraint
justTypeVariableConstraintAppendable =
    Just TypeVariableConstraintAppendable


justTypeVariableConstraintNumber : Maybe TypeVariableConstraint
justTypeVariableConstraintNumber =
    Just TypeVariableConstraintNumber


maybeTypeVariableConstraintMerge : Maybe TypeVariableConstraint -> Maybe TypeVariableConstraint -> Result String (Maybe TypeVariableConstraint)
maybeTypeVariableConstraintMerge a b =
    case a of
        Nothing ->
            Ok b

        Just aConstraint ->
            case b of
                Nothing ->
                    Ok (Just aConstraint)

                Just bConstraint ->
                    Result.map Just
                        (typeVariableConstraintMerge aConstraint bConstraint)


typeVariableConstraintMerge : TypeVariableConstraint -> TypeVariableConstraint -> Result String TypeVariableConstraint
typeVariableConstraintMerge a b =
    case a of
        TypeVariableConstraintNumber ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintCompappend ->
                    Err "number and compappend variables cannot be unified"

        TypeVariableConstraintAppendable ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintAppendable

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintComparable ->
            case b of
                TypeVariableConstraintNumber ->
                    okTypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintComparable

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend

        TypeVariableConstraintCompappend ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and compappend variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    okTypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    okTypeVariableConstraintCompappend


okTypeVariableConstraintCompappend : Result error_ TypeVariableConstraint
okTypeVariableConstraintCompappend =
    Ok TypeVariableConstraintCompappend


okTypeVariableConstraintComparable : Result error_ TypeVariableConstraint
okTypeVariableConstraintComparable =
    Ok TypeVariableConstraintComparable


okTypeVariableConstraintNumber : Result error_ TypeVariableConstraint
okTypeVariableConstraintNumber =
    Ok TypeVariableConstraintNumber


okTypeVariableConstraintAppendable : Result error_ TypeVariableConstraint
okTypeVariableConstraintAppendable =
    Ok TypeVariableConstraintAppendable


{-| Type information attached to expressions and patterns,
see [`TypedNode`](#TypedNode).

This is different from [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)
in that it doesn't contain
information unrelated to type inference like ranges, qualification levels or parens.

-}
type Type variable
    = TypeVariable variable
    | TypeNotVariable (TypeNotVariable variable)


{-| [`Type`](#Type) except the variable case
-}
type TypeNotVariable variable
    = TypeUnit
    | TypeConstruct
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type variable)
        }
    | TypeTuple
        { part0 : Type variable
        , part1 : Type variable
        }
    | TypeTriple
        { part0 : Type variable
        , part1 : Type variable
        , part2 : Type variable
        }
    | TypeRecord (FastDict.Dict String (Type variable))
    | TypeRecordExtension
        { recordVariable : variable
        , fields : FastDict.Dict String (Type variable)
        }
    | TypeFunction
        { input : Type variable
        , output : Type variable
        }


typeMapVariables :
    (variable -> changedVariable)
    -> Type variable
    -> Type changedVariable
typeMapVariables variableMap type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable variable ->
            TypeVariable (variable |> variableMap)

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariable
                    |> typeNotVariableMapVariables variableMap
                )


typeContainedVariables :
    Type comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeContainedVariables type_ =
    case type_ of
        TypeVariable variable ->
            FastSet.singleton variable

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableContainedVariables


typeNotVariableContainedVariables :
    TypeNotVariable comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeNotVariableContainedVariables typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            FastSet.empty

        TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> typeContainedVariables)
                (typeFunction.output |> typeContainedVariables)

        TypeTuple typeTuple ->
            FastSet.union
                (typeTuple.part0 |> typeContainedVariables)
                (typeTuple.part1 |> typeContainedVariables)

        TypeTriple typeTriple ->
            FastSet.union
                (FastSet.union
                    (typeTriple.part0 |> typeContainedVariables)
                    (typeTriple.part1 |> typeContainedVariables)
                )
                (typeTriple.part2 |> typeContainedVariables)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify typeContainedVariables

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union soFar
                            (value |> typeContainedVariables)
                    )
                    FastSet.empty

        TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union soFar
                            (value |> typeContainedVariables)
                    )
                    (FastSet.singleton typeRecordExtension.recordVariable)


typeNotVariableMapVariables :
    (variable -> variableMapped)
    -> TypeNotVariable variable
    -> TypeNotVariable variableMapped
typeNotVariableMapVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            TypeUnit

        TypeConstruct typeConstruct ->
            TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map (\arg -> arg |> typeMapVariables variableMap)
                }

        TypeTuple typeTuple ->
            TypeTuple
                { part0 = typeTuple.part0 |> typeMapVariables variableMap
                , part1 = typeTuple.part1 |> typeMapVariables variableMap
                }

        TypeTriple typeTriple ->
            TypeTriple
                { part0 = typeTriple.part0 |> typeMapVariables variableMap
                , part1 = typeTriple.part1 |> typeMapVariables variableMap
                , part2 = typeTriple.part2 |> typeMapVariables variableMap
                }

        TypeRecord typeRecordFields ->
            TypeRecord
                (typeRecordFields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> typeMapVariables variableMap
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable =
                    typeRecordExtension.recordVariable
                        |> variableMap
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
                }

        TypeFunction typeFunction ->
            TypeFunction
                { input = typeFunction.input |> typeMapVariables variableMap
                , output = typeFunction.output |> typeMapVariables variableMap
                }


{-| How to map names and symbols used in a module to their origin module.
Create with [`importsToModuleOriginLookup`](#importsToModuleOriginLookup).

Contains variants, type alias names, choice type names, port names, value/function declaration names
and whether `(|.)` and or `(|=)` are imported from `Parser.Advanced`.

Also contains locally declared names when available.

Type- and expression/pattern-level members
are separated since you can for example have a local `List` variant
while also using an (implicitly) imported `List` type.

-}
type alias ModuleOriginLookup =
    { references :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , typeConstructs :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , keepOperatorIsExposedFromParserAdvanced : Bool
    , ignoreOperatorIsExposedFromParserAdvanced : Bool
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed [`ModuleTypes`](#ModuleTypes)
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleOriginLookup :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleOriginLookup
importsToModuleOriginLookup modulesTypes imports =
    let
        importsNormal :
            List
                { moduleName : Elm.Syntax.ModuleName.ModuleName
                , alias : Maybe String
                , typeExposes : List String
                , referenceExposes : List String
                }
        importsNormal =
            implicitImports
                ++ (imports
                        |> List.map
                            (\(Elm.Syntax.Node.Node _ syntaxImport) ->
                                let
                                    importModuleName : Elm.Syntax.ModuleName.ModuleName
                                    importModuleName =
                                        syntaxImport.moduleName |> Elm.Syntax.Node.value
                                in
                                { moduleName = importModuleName
                                , alias =
                                    syntaxImport.moduleAlias
                                        |> Maybe.map
                                            (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                                                syntaxAlias |> String.join "."
                                            )
                                , typeExposes =
                                    case syntaxImport.exposingList of
                                        Nothing ->
                                            []

                                        Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                            case modulesTypes |> FastDict.get importModuleName of
                                                Nothing ->
                                                    []

                                                Just moduleTypes ->
                                                    case syntaxExposing of
                                                        Elm.Syntax.Exposing.All _ ->
                                                            (moduleTypes.typeAliases |> FastDict.keys)
                                                                ++ (moduleTypes.choiceTypes
                                                                        |> FastDict.foldl
                                                                            (\choiceTypeName _ soFar ->
                                                                                choiceTypeName :: soFar
                                                                            )
                                                                            []
                                                                   )

                                                        Elm.Syntax.Exposing.Explicit exposes ->
                                                            exposes
                                                                |> List.filterMap
                                                                    (\(Elm.Syntax.Node.Node _ expose) ->
                                                                        case expose of
                                                                            Elm.Syntax.Exposing.InfixExpose _ ->
                                                                                Nothing

                                                                            Elm.Syntax.Exposing.FunctionExpose _ ->
                                                                                Nothing

                                                                            Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                                                Just name

                                                                            Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                Just choiceTypeExpose.name
                                                                    )
                                , referenceExposes =
                                    case syntaxImport.exposingList of
                                        Nothing ->
                                            []

                                        Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                            case modulesTypes |> FastDict.get importModuleName of
                                                Nothing ->
                                                    []

                                                Just moduleTypes ->
                                                    case syntaxExposing of
                                                        Elm.Syntax.Exposing.All _ ->
                                                            (moduleTypes.signatures |> FastDict.keys)
                                                                ++ (moduleTypes.typeAliases
                                                                        |> FastDict.foldl
                                                                            (\typeAliasName info soFar ->
                                                                                case info.recordFieldOrder of
                                                                                    Nothing ->
                                                                                        soFar

                                                                                    Just _ ->
                                                                                        typeAliasName :: soFar
                                                                            )
                                                                            []
                                                                   )
                                                                ++ (moduleTypes.choiceTypes
                                                                        |> FastDict.foldl
                                                                            (\_ choiceTypeInfo soFar ->
                                                                                (choiceTypeInfo.variants |> FastDict.keys)
                                                                                    ++ soFar
                                                                            )
                                                                            []
                                                                   )

                                                        Elm.Syntax.Exposing.Explicit exposes ->
                                                            exposes
                                                                |> List.foldl
                                                                    (\(Elm.Syntax.Node.Node _ expose) namesSoFar ->
                                                                        case expose of
                                                                            Elm.Syntax.Exposing.TypeOrAliasExpose _ ->
                                                                                namesSoFar

                                                                            Elm.Syntax.Exposing.InfixExpose operator ->
                                                                                operator :: namesSoFar

                                                                            Elm.Syntax.Exposing.FunctionExpose name ->
                                                                                name :: namesSoFar

                                                                            Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                case choiceTypeExpose.open of
                                                                                    Nothing ->
                                                                                        namesSoFar

                                                                                    Just _ ->
                                                                                        case moduleTypes.choiceTypes |> FastDict.get choiceTypeExpose.name of
                                                                                            Nothing ->
                                                                                                namesSoFar

                                                                                            Just choiceTypeDeclared ->
                                                                                                choiceTypeDeclared.variants
                                                                                                    |> FastDict.foldl
                                                                                                        (\name _ namesSoFarWithVariantNames ->
                                                                                                            name :: namesSoFarWithVariantNames
                                                                                                        )
                                                                                                        namesSoFar
                                                                    )
                                                                    []
                                }
                            )
                   )
                |> importsCombine

        operatorIsExposedFromParserAdvanced : String -> Bool
        operatorIsExposedFromParserAdvanced operator =
            importsNormal
                |> List.any
                    (\syntaxImport ->
                        (case syntaxImport.moduleName of
                            [ "Parser", "Advanced" ] ->
                                True

                            _ ->
                                False
                        )
                            && (syntaxImport.referenceExposes
                                    |> List.any
                                        (\syntaxExpose ->
                                            (syntaxExpose == operator)
                                                || (syntaxExpose == ("(" ++ operator ++ ")"))
                                        )
                               )
                    )
    in
    { references =
        importsNormal
            |> List.foldl
                (\syntaxImport soFar ->
                    case modulesTypes |> FastDict.get syntaxImport.moduleName of
                        Nothing ->
                            soFar

                        Just moduleTypes ->
                            let
                                exposedFromImportedModuleItself : List String
                                exposedFromImportedModuleItself =
                                    (moduleTypes.signatures |> FastDict.keys)
                                        ++ (moduleTypes.choiceTypes
                                                |> FastDict.foldl
                                                    (\_ choiceType variantNamesSoFar ->
                                                        (choiceType.variants |> FastDict.keys)
                                                            ++ variantNamesSoFar
                                                    )
                                                    []
                                           )
                            in
                            FastDict.union soFar
                                (FastDict.union
                                    (syntaxImport.referenceExposes
                                        |> listMapToFastDict
                                            (\expose ->
                                                { key = ( [], expose )
                                                , value = syntaxImport.moduleName
                                                }
                                            )
                                    )
                                    (case syntaxImport.alias of
                                        Nothing ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( syntaxImport.moduleName, exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )

                                        Just importAlias ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( [ importAlias ], exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )
                                    )
                                )
                )
                FastDict.empty
    , typeConstructs =
        importsNormal
            |> List.foldl
                (\syntaxImport soFar ->
                    case modulesTypes |> FastDict.get syntaxImport.moduleName of
                        Nothing ->
                            soFar

                        Just moduleTypes ->
                            let
                                exposedFromImportedModuleItself : List String
                                exposedFromImportedModuleItself =
                                    (moduleTypes.typeAliases |> FastDict.keys)
                                        ++ (moduleTypes.choiceTypes
                                                |> FastDict.foldl
                                                    (\choiceTypeName _ variantNamesSoFar ->
                                                        choiceTypeName :: variantNamesSoFar
                                                    )
                                                    []
                                           )
                            in
                            FastDict.union
                                (FastDict.union
                                    (syntaxImport.typeExposes
                                        |> listMapToFastDict
                                            (\expose ->
                                                { key = ( [], expose )
                                                , value = syntaxImport.moduleName
                                                }
                                            )
                                    )
                                    (case syntaxImport.alias of
                                        Nothing ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( syntaxImport.moduleName, exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )

                                        Just importAlias ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( [ importAlias ], exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )
                                    )
                                )
                                soFar
                )
                FastDict.empty
    , keepOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|."
    , ignoreOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|="
    }


implicitImports :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
implicitImports =
    [ { moduleName = [ "Basics" ]
      , alias = Nothing
      , typeExposes = [ "Int", "Float", "Order", "Bool", "Never" ]
      , referenceExposes =
            [ "(+)"
            , "(-)"
            , "(*)"
            , "(/)"
            , "(//)"
            , "(^)"
            , "toFloat"
            , "round"
            , "floor"
            , "ceiling"
            , "truncate"
            , "(==)"
            , "(/=)"
            , "(<)"
            , "(>)"
            , "(<=)"
            , "(>=)"
            , "max"
            , "min"
            , "compare"
            , "LT"
            , "EQ"
            , "GT"
            , "True"
            , "False"
            , "not"
            , "(&&)"
            , "(||)"
            , "xor"
            , "(++)"
            , "modBy"
            , "remainderBy"
            , "negate"
            , "abs"
            , "clamp"
            , "sqrt"
            , "logBase"
            , "e"
            , "pi"
            , "cos"
            , "sin"
            , "tan"
            , "acos"
            , "asin"
            , "atan"
            , "atan2"
            , "degrees"
            , "radians"
            , "turns"
            , "toPolar"
            , "fromPolar"
            , "isNaN"
            , "isInfinite"
            , "identity"
            , "always"
            , "(<|)"
            , "(|>)"
            , "(<<)"
            , "(>>)"
            , "never"
            ]
      }
    , { moduleName = [ "List" ], alias = Nothing, typeExposes = [ "List" ], referenceExposes = [ "(::)" ] }
    , { moduleName = [ "Maybe" ], alias = Nothing, typeExposes = [ "Maybe" ], referenceExposes = [ "Just", "Nothing" ] }
    , { moduleName = [ "Result" ], alias = Nothing, typeExposes = [ "Result" ], referenceExposes = [ "Ok", "Err" ] }
    , { moduleName = [ "String" ], alias = Nothing, typeExposes = [ "String" ], referenceExposes = [] }
    , { moduleName = [ "Char" ], alias = Nothing, typeExposes = [ "Char" ], referenceExposes = [] }
    , { moduleName = [ "Tuple" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Debug" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Platform" ], alias = Nothing, typeExposes = [ "Program" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Cmd" ], alias = Just "Cmd", typeExposes = [ "Cmd" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Sub" ], alias = Just "Sub", typeExposes = [ "Sub" ], referenceExposes = [] }
    ]


importsCombine :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importsMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importsMerge :
    { moduleName : Elm.Syntax.ModuleName.ModuleName
    , alias : Maybe String
    , typeExposes : List String
    , referenceExposes : List String
    }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importsMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , typeExposes =
        exposingCombine earlier.typeExposes later.typeExposes
    , referenceExposes =
        exposingCombine earlier.referenceExposes later.referenceExposes
    }


exposingCombine : List String -> List String -> List String
exposingCombine a b =
    a ++ b |> exposeListToNormal


exposeListToNormal :
    List String
    -> List String
exposeListToNormal syntaxExposeList =
    syntaxExposeList
        |> List.sort
        |> exposesCombine


exposesCombine : List String -> List String
exposesCombine syntaxExposes =
    exposesCombineFrom [] syntaxExposes


exposesCombineFrom : List String -> List String -> List String
exposesCombineFrom soFar syntaxExposes =
    case syntaxExposes of
        [] ->
            soFar

        [ onlyExpose ] ->
            onlyExpose :: soFar

        expose0 :: expose1 :: expose2Up ->
            case Basics.compare expose0 expose1 of
                EQ ->
                    exposesCombineFrom soFar (expose0 :: expose2Up)

                LT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)

                GT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)


syntaxToType :
    ModuleOriginLookup
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String (Type String)
syntaxToType moduleOriginLookup syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            okTypeUnit

        Elm.Syntax.TypeAnnotation.GenericType variableName ->
            Ok (TypeVariable variableName)

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( qualification, unqualifiedName )) argumentNodes ->
            case moduleOriginLookup.typeConstructs |> FastDict.get ( qualification, unqualifiedName ) of
                Nothing ->
                    Err
                        (case qualification of
                            [] ->
                                "could not find imported/local declaration for "
                                    ++ unqualifiedName

                            qualificationPart0 :: qualificationPart1Up ->
                                "could not find imported declaration for "
                                    ++ qualifiedToString
                                        { qualification = qualificationPart0 :: qualificationPart1Up
                                        , name = unqualifiedName
                                        }
                        )

                Just originModule ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = originModule
                                    , name = unqualifiedName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentNodes
                            |> listMapAndCombineOk
                                (\(Elm.Syntax.Node.Node _ argument) ->
                                    argument |> syntaxToType moduleOriginLookup
                                )
                        )

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [] ->
                    okTypeUnit

                [ Elm.Syntax.Node.Node _ inParens ] ->
                    inParens |> syntaxToType moduleOriginLookup

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1, Elm.Syntax.Node.Node _ syntaxPart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)
                        (syntaxPart2 |> syntaxToType moduleOriginLookup)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.TypeAnnotation.Record recordFields ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (recordFields
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariableName) (Elm.Syntax.Node.Node _ recordExtensionFields) ->
            case recordExtensionFields of
                [] ->
                    Err "record extension by 0 fields is invalid syntax"

                field0 :: field1Up ->
                    Result.map
                        (\fields ->
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = recordVariableName
                                    , fields = fields
                                    }
                                )
                        )
                        ((field0 :: field1Up)
                            |> listFoldlWhileOkFrom
                                FastDict.empty
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                                    Result.map
                                        (\fieldValueType ->
                                            soFar |> FastDict.insert fieldName fieldValueType
                                        )
                                        (fieldValue |> syntaxToType moduleOriginLookup)
                                )
                        )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation (Elm.Syntax.Node.Node _ syntaxInput) (Elm.Syntax.Node.Node _ syntaxOutput) ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (syntaxInput |> syntaxToType moduleOriginLookup)
                (syntaxOutput |> syntaxToType moduleOriginLookup)


qualifiedToString :
    { qualification : Elm.Syntax.ModuleName.ModuleName, name : String }
    -> String
qualifiedToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationUntilDot :: qualificationAfterDot ->
            ((qualificationUntilDot :: qualificationAfterDot)
                |> String.join "."
            )
                ++ "."
                ++ reference.name


typeSubstituteVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : Type TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariable declarationTypes replacement type_ =
    case replacement.type_ of
        TypeVariable argumentVariable ->
            Ok
                { type_ =
                    type_
                        |> typeMapVariables
                            (\variable ->
                                if variable == replacement.variable then
                                    argumentVariable

                                else
                                    variable
                            )
                , substitutions = variableSubstitutionsNone
                }

        TypeNotVariable argumentNotVariable ->
            type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    { variable = replacement.variable
                    , type_ = argumentNotVariable
                    }


typeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> Type TypeVariableFromContext
    ->
        Result
            String
            (Type
                TypeVariableFromContext
            )
typeApplyVariableSubstitutions declarationTypes substitutions originalType =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            typeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (originalType
                                    |> typeMapVariables
                                        (\originalVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalVariable
                                                |> Maybe.withDefault originalVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok originalType

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        originalType
                            |> typeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok typeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            typeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            typeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                typeWithVariableToTypeSubstitutionApplied.type_


typeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariableByNotVariable declarationTypes replacement type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable typeVariable ->
            if typeVariable == replacement.variable then
                case replacement.variable |> typeVariableIgnoringContext |> typeVariableConstraint of
                    Nothing ->
                        Ok
                            { type_ = TypeNotVariable replacement.type_
                            , substitutions = variableSubstitutionsNone
                            }

                    Just constraint ->
                        case constraint of
                            TypeVariableConstraintNumber ->
                                if
                                    replacement.type_
                                        |> typeNotVariableIsNumber declarationTypes
                                then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err
                                        ("cannot unify number type variable with types other than Int/Float, found: "
                                            ++ (replacement.type_ |> typeNotVariableToInfoString)
                                        )

                            TypeVariableConstraintAppendable ->
                                if
                                    replacement.type_
                                        |> typeNotVariableIsAppendable declarationTypes
                                then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify appendable type variable with types other than String/List _"

                            TypeVariableConstraintComparable ->
                                if
                                    replacement.type_
                                        |> typeNotVariableIsComparable declarationTypes
                                then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify comparable type variable with types other than Int/Float/String/Time.Posix/List of comparable/tuple of comparables/triple of comparable"

                            TypeVariableConstraintCompappend ->
                                if
                                    replacement.type_
                                        |> typeNotVariableIsCompappend declarationTypes
                                then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify compappend type variable with types other than String/List of comparable"

            else
                Ok
                    { type_ = TypeVariable typeVariable
                    , substitutions = variableSubstitutionsNone
                    }

        TypeNotVariable typeNotVariable ->
            Result.map
                (\typeAndSubstitutions ->
                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                    , substitutions = typeAndSubstitutions.substitutions
                    }
                )
                (typeNotVariable
                    |> typeNotVariableSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


typeToInfoString : Type TypeVariableFromContext -> String
typeToInfoString type_ =
    case type_ of
        TypeVariable typeVariable ->
            typeVariable |> typeVariableFromContextToInfoString

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableToInfoString


typeVariableFromContextToInfoString : TypeVariableFromContext -> String
typeVariableFromContextToInfoString ( context, variable ) =
    variable ++ "_" ++ (context |> String.join "_")


typeNotVariableToInfoString : TypeNotVariable TypeVariableFromContext -> String
typeNotVariableToInfoString typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typeToInfoString)
                ++ " -> "
                ++ (typeFunction.output |> typeToInfoString)
                ++ ")"

        TypeConstruct typeConstruct ->
            let
                typeReferenceAsString : String
                typeReferenceAsString =
                    qualifiedToString
                        { qualification = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
            in
            case typeConstruct.arguments of
                [] ->
                    typeReferenceAsString

                argument0 :: argument1Up ->
                    "("
                        ++ typeReferenceAsString
                        ++ (argument0
                                :: argument1Up
                                |> List.map (\argument -> " " ++ (argument |> typeToInfoString))
                                |> String.concat
                           )
                        ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ ", "
                ++ (parts.part2 |> typeToInfoString)
                ++ " )"

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension recordExtension ->
            "{ "
                ++ (recordExtension.recordVariable |> typeVariableFromContextToInfoString)
                ++ (recordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"


typeNotVariableSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableSubstituteVariableByNotVariable declarationTypes replacement typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            okTypeNotVariableUnitSubstitutionsNone

        TypeConstruct typeChoiceConstruct ->
            Result.map
                (\argumentsSubstituted ->
                    { type_ =
                        TypeConstruct
                            { moduleOrigin = typeChoiceConstruct.moduleOrigin
                            , name = typeChoiceConstruct.name
                            , arguments = argumentsSubstituted.arguments
                            }
                    , substitutions = argumentsSubstituted.substitutions
                    }
                )
                (typeChoiceConstruct.arguments
                    |> listFoldrWhileOkFrom
                        argumentsListEmptySubstitutionsNone
                        (\argument soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithArgument ->
                                            { arguments =
                                                argumentSubstituted.type_
                                                    :: soFar.arguments
                                            , substitutions = substitutionsWithArgument
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argument
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeTuple typeTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTuple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (typeTuple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTuple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeTriple typeTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTriple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    , part2 = part2Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (typeTriple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part2
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeRecord typeRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    { substitutions = fieldsSubstituted.substitutions
                    , type_ = TypeRecord fieldsSubstituted.types
                    }
                )
                (typeRecordFields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmpty
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            valueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            Result.andThen
                (\fieldsSubstituted ->
                    if typeRecordExtension.recordVariable /= replacement.variable then
                        Ok
                            { substitutions = fieldsSubstituted.substitutions
                            , type_ =
                                TypeRecordExtension
                                    { recordVariable = typeRecordExtension.recordVariable
                                    , fields = fieldsSubstituted.types
                                    }
                            }

                    else
                        case replacement.type_ of
                            TypeRecord replacementRecordFields ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ = TypeRecord fieldsMerged.types
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types =
                                                                        soFar.types
                                                                            |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    soFar.substitutions
                                                                    valueUnified.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordFields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            TypeRecordExtension replacementRecordExtension ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ =
                                            TypeRecordExtension
                                                { recordVariable = replacementRecordExtension.recordVariable
                                                , fields = fieldsMerged.types
                                                }
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types =
                                                                        soFar.types
                                                                            |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    soFar.substitutions
                                                                    valueUnified.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordExtension.fields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            TypeUnit ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeConstruct _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeTuple _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeTriple _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeFunction _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"
                )
                (typeRecordExtension.fields
                    |> fastDictFoldlWhileOkFrom
                        substitutionsNoneTypesDictEmpty
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            soFar.substitutions
                                            valueSubstituted.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeFunction typeFunction ->
            resultAndThen2
                (\inputSubstituted outputSubstituted ->
                    Result.map
                        (\substitutionsInputOutput ->
                            { type_ =
                                TypeFunction
                                    { input = inputSubstituted.type_
                                    , output = outputSubstituted.type_
                                    }
                            , substitutions = substitutionsInputOutput
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            inputSubstituted.substitutions
                            outputSubstituted.substitutions
                        )
                )
                (typeFunction.input
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeFunction.output
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


okTypeNotVariableUnitSubstitutionsNone :
    Result
        error_
        { type_ : TypeNotVariable TypeVariableFromContext
        , substitutions : VariableSubstitutions
        }
okTypeNotVariableUnitSubstitutionsNone =
    Ok
        { type_ = TypeUnit
        , substitutions = variableSubstitutionsNone
        }


substitutionsNoneTypesDictEmpty :
    { substitutions : VariableSubstitutions
    , types : FastDict.Dict String (Type TypeVariableFromContext)
    }
substitutionsNoneTypesDictEmpty =
    { substitutions = variableSubstitutionsNone
    , types = FastDict.empty
    }


typeIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsNumber declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsNumber declarationTypes
                typeNotVariable


typeNotVariableIsNumber :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsNumber declarationTypes type_ =
    case type_ of
        TypeConstruct typeConstruct ->
            case typeConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case typeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias declarationTypes
                            typeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsNumber declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsAppendable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsAppendable declarationTypes
                typeNotVariable


typeNotVariableIsAppendable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsAppendable declarationTypes type_ =
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            True

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias declarationTypes
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsAppendable declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsComparable declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    False

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    True

                Just TypeVariableConstraintNumber ->
                    True

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsComparable declarationTypes
                typeNotVariable


typeNotVariableIsComparable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsComparable declarationTypes typeNotVariable =
    -- IGNORE TCO
    case typeNotVariable of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "Basics" ] ->
                    case variableReplacementTypeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                [ "Time" ] ->
                    case variableReplacementTypeConstruct.name of
                        "Posix" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias declarationTypes
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsComparable declarationTypes
                                deAliasedTypeConstruct

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeIsComparable declarationTypes)
                && (typeTuple.part1 |> typeIsComparable declarationTypes)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeIsComparable declarationTypes)
                && (typeTriple.part1 |> typeIsComparable declarationTypes)
                && (typeTriple.part2 |> typeIsComparable declarationTypes)

        TypeUnit ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Bool
typeIsCompappend declarationTypes type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableIgnoringContext |> typeVariableConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    False

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    False

                Just TypeVariableConstraintNumber ->
                    False

        TypeNotVariable typeNotVariable ->
            typeNotVariableIsCompappend declarationTypes
                typeNotVariable


typeNotVariableIsCompappend :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> Bool
typeNotVariableIsCompappend declarationTypes type_ =
    -- IGNORE TCO
    case type_ of
        TypeConstruct variableReplacementTypeConstruct ->
            case variableReplacementTypeConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeConstruct.name of
                        "List" ->
                            variableReplacementTypeConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument
                                            |> typeIsComparable declarationTypes
                                    )

                        _ ->
                            False

                _ ->
                    case
                        typeConstructFullyExpandIfAlias declarationTypes
                            variableReplacementTypeConstruct
                    of
                        Nothing ->
                            False

                        Just deAliasedTypeConstruct ->
                            typeIsCompappend declarationTypes
                                deAliasedTypeConstruct

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeConstructFullyExpandIfAlias :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { name : String
        , arguments : List (Type TypeVariableFromContext)
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        }
    -> Maybe (Type TypeVariableFromContext)
typeConstructFullyExpandIfAlias declarationTypes typeConstructToExpand =
    case declarationTypes |> FastDict.get typeConstructToExpand.moduleOrigin of
        Nothing ->
            Nothing

        Just aOriginModuleTypes ->
            case aOriginModuleTypes.typeAliases |> FastDict.get typeConstructToExpand.name of
                Nothing ->
                    Nothing

                Just originAliasDeclaration ->
                    List.map2
                        (\parameterName argument ->
                            { variable = ( [], parameterName ), type_ = argument }
                        )
                        originAliasDeclaration.parameters
                        typeConstructToExpand.arguments
                        |> listFoldlWhileOkFrom
                            (originAliasDeclaration.type_
                                |> typeMapVariables (\aliasVariable -> ( [], aliasVariable ))
                            )
                            (\substitution typeSoFar ->
                                typeSoFar
                                    |> typeApplyVariableSubstitutions declarationTypes
                                        (variableSubstitutionsFromVariableToType
                                            substitution.variable
                                            substitution.type_
                                        )
                            )
                        |> Result.toMaybe


{-| All you need to turn a generic type with variables
into a concrete type with all the info we've inferred already.

While variable types in context get passed down,
variable substitutions get passed all the way to the top and only get processed there.

-}
type alias VariableSubstitutions =
    { equivalentVariables :
        List (FastSet.Set TypeVariableFromContext)
    , variableToType :
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    }


variableSubstitutionsNone : VariableSubstitutions
variableSubstitutionsNone =
    { equivalentVariables = []
    , variableToType = FastDict.empty
    }


variableSubstitutionsMerge :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge declarationTypes a b =
    -- IGNORE TCO
    FastDict.merge
        (\variable aType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable aType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        (\variable aType bType soFarOrError ->
            Result.andThen
                (\soFar ->
                    Result.andThen
                        (\abTypesUnified ->
                            Result.map
                                (\substitutionsWithAB ->
                                    case abTypesUnified.type_ of
                                        TypeVariable abUnifiedVariable ->
                                            { equivalentVariables =
                                                substitutionsWithAB.equivalentVariables
                                                    |> equivalentVariablesMergeWithSetOf2
                                                        variable
                                                        abUnifiedVariable
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                            }

                                        TypeNotVariable abUnifiedNotVariable ->
                                            { equivalentVariables = substitutionsWithAB.equivalentVariables
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                                    |> FastDict.insert variable abUnifiedNotVariable
                                            }
                                )
                                (variableSubstitutionsMerge declarationTypes
                                    soFar
                                    abTypesUnified.substitutions
                                )
                        )
                        (typeNotVariableUnify declarationTypes aType bType)
                )
                soFarOrError
        )
        (\variable bType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable bType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        a.variableToType
        b.variableToType
        (Ok
            { variableToType = FastDict.empty
            , equivalentVariables =
                equivalentVariableSetMerge
                    a.equivalentVariables
                    b.equivalentVariables
            }
        )


variableSubstitutionsMerge3 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge3 declarationTypes a b c =
    variableSubstitutionsMerge
        declarationTypes
        a
        b
        |> Result.andThen
            (\abSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abSubstitutions
                    c
            )


variableSubstitutionsMerge4 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge4 declarationTypes a b c d =
    variableSubstitutionsMerge3
        declarationTypes
        a
        b
        c
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abcSubstitutions
                    d
            )


equivalentVariablesMergeWithSetOf2 :
    comparable
    -> comparable
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariablesMergeWithSetOf2 aEquivalentVariable bEquivalentVariable equivalentVariables =
    equivalentVariablesMergeWithSetOf2Into [] aEquivalentVariable bEquivalentVariable equivalentVariables


equivalentVariablesMergeWithSetOf2Into :
    List (FastSet.Set comparable)
    -> comparable
    -> comparable
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariablesMergeWithSetOf2Into soFar aEquivalentVariable bEquivalentVariable equivalentVariables =
    case equivalentVariables of
        [] ->
            (FastSet.singleton aEquivalentVariable
                |> FastSet.insert bEquivalentVariable
            )
                :: soFar

        equivalentVariablesSet0 :: equivalentVariablesSet1Up ->
            if
                (equivalentVariablesSet0 |> FastSet.member aEquivalentVariable)
                    || (equivalentVariablesSet0 |> FastSet.member bEquivalentVariable)
            then
                (equivalentVariablesSet0
                    |> FastSet.insert aEquivalentVariable
                    |> FastSet.insert bEquivalentVariable
                )
                    :: soFar
                    ++ equivalentVariablesSet1Up

            else
                equivalentVariablesMergeWithSetOf2Into
                    (equivalentVariablesSet0 :: soFar)
                    aEquivalentVariable
                    bEquivalentVariable
                    equivalentVariablesSet1Up


equivalentVariableSetMerge :
    List (FastSet.Set comparableTypeVariable)
    -> List (FastSet.Set comparableTypeVariable)
    -> List (FastSet.Set comparableTypeVariable)
equivalentVariableSetMerge a b =
    let
        mergedIntoA :
            { sets : List (FastSet.Set comparableTypeVariable)
            , bRemaining : List (FastSet.Set comparableTypeVariable)
            }
        mergedIntoA =
            a
                |> List.foldl
                    (\aEquivalentVariableSet soFar ->
                        case
                            soFar.bRemaining
                                |> listMapAndFirstJustAndRemainingAnyOrder
                                    (\bEquivalentVariableSet ->
                                        if fastSetShareElements aEquivalentVariableSet bEquivalentVariableSet then
                                            Just bEquivalentVariableSet

                                        else
                                            Nothing
                                    )
                        of
                            Nothing ->
                                { sets = aEquivalentVariableSet :: soFar.sets
                                , bRemaining = soFar.bRemaining
                                }

                            Just bEquivalentVariableSetAndRemaining ->
                                { sets =
                                    FastSet.union aEquivalentVariableSet bEquivalentVariableSetAndRemaining.value
                                        :: soFar.sets
                                , bRemaining = bEquivalentVariableSetAndRemaining.remaining
                                }
                    )
                    { sets = [], bRemaining = b }
    in
    mergedIntoA.sets
        ++ mergedIntoA.bRemaining


fastSetShareElements : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetShareElements a b =
    FastSet.intersect a b /= FastSet.empty


listMapAndFirstJustAndRemainingAnyOrder :
    (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAnyOrder elementToMaybe list =
    listMapAndFirstJustAndRemainingAndOrderWithBefore [] elementToMaybe list


listMapAndFirstJustAndRemainingAndOrderWithBefore :
    List a
    -> (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAndOrderWithBefore elementsBeforeReverse elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybe of
                Just headValue ->
                    Just
                        { value = headValue
                        , remaining =
                            (elementsBeforeReverse |> List.reverse)
                                ++ tail
                        }

                Nothing ->
                    listMapAndFirstJustAndRemainingAndOrderWithBefore
                        (head :: elementsBeforeReverse)
                        elementToMaybe
                        tail


listFilledMapAndTypesUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> (a -> Type TypeVariableFromContext)
    -> ( a, List a )
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
listFilledMapAndTypesUnify declarationTypes elementToType ( head, tail ) =
    tail
        |> listFoldlWhileOkFrom
            { type_ = head |> elementToType
            , substitutions = variableSubstitutionsNone
            }
            (\element soFar ->
                Result.andThen
                    (\soFarTypeUnifiedWithElement ->
                        Result.map
                            (\substitutionsSoFarWithElement ->
                                { type_ = soFarTypeUnifiedWithElement.type_
                                , substitutions = substitutionsSoFarWithElement
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                soFarTypeUnifiedWithElement.substitutions
                            )
                    )
                    (typeUnify declarationTypes
                        soFar.type_
                        (element |> elementToType)
                    )
            )


typeUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnify declarationTypes a b =
    case a of
        TypeNotVariable aTypeNotVariable ->
            case b of
                TypeVariable bVariableName ->
                    Ok
                        { type_ = TypeNotVariable aTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton bVariableName
                                    aTypeNotVariable
                            , equivalentVariables = []
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    typeNotVariableUnify declarationTypes
                        aTypeNotVariable
                        bTypeNotVariable

        TypeVariable aVariable ->
            case b of
                TypeVariable bVariable ->
                    Ok
                        { type_ = TypeVariable aVariable
                        , substitutions =
                            { variableToType = FastDict.empty
                            , equivalentVariables =
                                [ FastSet.singleton aVariable
                                    |> FastSet.insert bVariable
                                ]
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    Ok
                        { type_ = TypeNotVariable bTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton aVariable
                                    bTypeNotVariable
                            , equivalentVariables = []
                            }
                        }


typeNotVariableUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnify declarationTypes a b =
    let
        maybeTypeConstructsWithSameName :
            Maybe
                { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                , name : String
                , aArguments : List (Type TypeVariableFromContext)
                , bArguments : List (Type TypeVariableFromContext)
                }
        maybeTypeConstructsWithSameName =
            case a of
                TypeConstruct aTypeConstruct ->
                    case b of
                        TypeConstruct bTypeConstruct ->
                            if
                                (aTypeConstruct.moduleOrigin
                                    == bTypeConstruct.moduleOrigin
                                )
                                    && (aTypeConstruct.name
                                            == bTypeConstruct.name
                                       )
                            then
                                Just
                                    { moduleOrigin = aTypeConstruct.moduleOrigin
                                    , name = aTypeConstruct.name
                                    , aArguments = aTypeConstruct.arguments
                                    , bArguments = bTypeConstruct.arguments
                                    }

                            else
                                Nothing

                        TypeUnit ->
                            Nothing

                        TypeTuple _ ->
                            Nothing

                        TypeTriple _ ->
                            Nothing

                        TypeRecord _ ->
                            Nothing

                        TypeRecordExtension _ ->
                            Nothing

                        TypeFunction _ ->
                            Nothing

                TypeUnit ->
                    Nothing

                TypeTuple _ ->
                    Nothing

                TypeTriple _ ->
                    Nothing

                TypeRecord _ ->
                    Nothing

                TypeRecordExtension _ ->
                    Nothing

                TypeFunction _ ->
                    Nothing

        maybeUnifiedWithTypeConstruct :
            Maybe
                (Result
                    String
                    { type_ : Type TypeVariableFromContext
                    , substitutions : VariableSubstitutions
                    }
                )
        maybeUnifiedWithTypeConstruct =
            case maybeTypeConstructsWithSameName of
                Just matchingTypeConstructs ->
                    Result.map
                        (\argumentsABUnified ->
                            { type_ =
                                TypeNotVariable
                                    (TypeConstruct
                                        { moduleOrigin = matchingTypeConstructs.moduleOrigin
                                        , name = matchingTypeConstructs.name
                                        , arguments = argumentsABUnified.arguments
                                        }
                                    )
                            , substitutions = argumentsABUnified.substitutions
                            }
                        )
                        (-- TODO single operation
                         List.map2
                            (\aArgument bArgument -> { a = aArgument, b = bArgument })
                            matchingTypeConstructs.aArguments
                            matchingTypeConstructs.bArguments
                            |> listFoldrWhileOkFrom
                                argumentsListEmptySubstitutionsNone
                                (\ab soFar ->
                                    Result.andThen
                                        (\argumentTypeUnifiedAndSubstitutions ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { arguments =
                                                        argumentTypeUnifiedAndSubstitutions.type_
                                                            :: soFar.arguments
                                                    , substitutions =
                                                        substitutionsWithArgument
                                                    }
                                                )
                                                (variableSubstitutionsMerge declarationTypes
                                                    soFar.substitutions
                                                    argumentTypeUnifiedAndSubstitutions.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes ab.a ab.b)
                                )
                        )
                        |> Just

                Nothing ->
                    case typeUnifyWithTryToExpandTypeConstruct declarationTypes a b of
                        Just result ->
                            Just result

                        Nothing ->
                            typeUnifyWithTryToExpandTypeConstruct declarationTypes b a
    in
    case maybeUnifiedWithTypeConstruct of
        Just result ->
            result

        Nothing ->
            case a of
                TypeUnit ->
                    case b of
                        TypeUnit ->
                            okTypeUnitSubstitutionsNone

                        TypeConstruct _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeTuple _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeTriple _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeRecord _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeRecordExtension _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeFunction _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                TypeConstruct aTypeConstruct ->
                    let
                        aDescription : String
                        aDescription =
                            "choice type "
                                ++ qualifiedToString
                                    { qualification = aTypeConstruct.moduleOrigin
                                    , name = aTypeConstruct.name
                                    }
                    in
                    case b of
                        TypeUnit ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeConstruct bTypeConstruct ->
                            Err
                                (aDescription
                                    ++ " cannot be unified be with a choice type with a different name: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                        TypeTuple _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeTriple _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeRecord _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeRecordExtension _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeFunction _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                TypeTuple aTuple ->
                    case b of
                        TypeTuple bTuple ->
                            resultAndThen2
                                (\part0ABUnified part1ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTuple.part0 bTuple.part0)
                                (typeUnify declarationTypes aTuple.part1 bTuple.part1)

                        TypeUnit ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeConstruct _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeTriple _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeRecord _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeRecordExtension _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeFunction _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                TypeTriple aTriple ->
                    case b of
                        TypeTriple bTriple ->
                            resultAndThen3
                                (\part0ABUnified part1ABUnified part2ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTriple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        , part2 = part2ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                            part2ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTriple.part0 bTriple.part0)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)

                        TypeUnit ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeConstruct _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeTuple _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeRecord _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeRecordExtension _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeFunction _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                TypeRecord aRecord ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\unified ->
                                    { type_ = TypeNotVariable unified.type_
                                    , substitutions = unified.substitutions
                                    }
                                )
                                (typeRecordUnify declarationTypes aRecord bRecord)

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\unified ->
                                    { type_ = TypeNotVariable unified.type_
                                    , substitutions = unified.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    bRecordExtension
                                    aRecord
                                )

                        TypeUnit ->
                            Err
                                ("record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeUnit |> typeNotVariableToInfoString)
                                )

                        TypeConstruct bTypeConstruct ->
                            Err
                                ("record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                        TypeTuple bParts ->
                            Err
                                ("record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                                )

                        TypeTriple bParts ->
                            Err
                                ("record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                                )

                        TypeFunction bTypeFunction ->
                            Err
                                ("record "
                                    ++ (TypeRecord aRecord |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                                )

                TypeRecordExtension aRecordExtension ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\unified ->
                                    { type_ = TypeNotVariable unified.type_
                                    , substitutions = unified.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    aRecordExtension
                                    bRecord
                                )

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\unified ->
                                    { type_ = TypeNotVariable unified.type_
                                    , substitutions = unified.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecordExtension declarationTypes
                                    aRecordExtension
                                    bRecordExtension
                                )

                        TypeUnit ->
                            Err
                                ("record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeUnit |> typeNotVariableToInfoString)
                                )

                        TypeConstruct bTypeConstruct ->
                            Err
                                ("record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                        TypeTuple bParts ->
                            Err
                                ("record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeTuple bParts |> typeNotVariableToInfoString)
                                )

                        TypeTriple bParts ->
                            Err
                                ("record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeTriple bParts |> typeNotVariableToInfoString)
                                )

                        TypeFunction bTypeFunction ->
                            Err
                                ("record extension "
                                    ++ (TypeRecordExtension aRecordExtension |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than record or record extension, found: "
                                    ++ (TypeFunction bTypeFunction |> typeNotVariableToInfoString)
                                )

                TypeFunction aFunction ->
                    case b of
                        TypeFunction bFunction ->
                            resultAndThen2
                                (\inputABUnified outputABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = inputABUnified.type_
                                                        , output = outputABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            inputABUnified.substitutions
                                            outputABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aFunction.input bFunction.input)
                                (typeUnify declarationTypes aFunction.output bFunction.output)

                        TypeUnit ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeUnit |> typeNotVariableToInfoString)
                                )

                        TypeConstruct bTypeConstruct ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeConstruct bTypeConstruct |> typeNotVariableToInfoString)
                                )

                        TypeTuple bTypeTuple ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeTuple bTypeTuple |> typeNotVariableToInfoString)
                                )

                        TypeTriple bTypeTriple ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeTriple bTypeTriple |> typeNotVariableToInfoString)
                                )

                        TypeRecord bTypeRecord ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeRecord bTypeRecord |> typeNotVariableToInfoString)
                                )

                        TypeRecordExtension bTypeRecordExtension ->
                            Err
                                ("function "
                                    ++ (TypeFunction aFunction |> typeNotVariableToInfoString)
                                    ++ " cannot be unified with types other than function: "
                                    ++ (TypeRecordExtension bTypeRecordExtension |> typeNotVariableToInfoString)
                                )


argumentsListEmptySubstitutionsNone :
    { arguments : List argument_
    , substitutions : VariableSubstitutions
    }
argumentsListEmptySubstitutionsNone =
    { arguments = []
    , substitutions = variableSubstitutionsNone
    }


okTypeUnitSubstitutionsNone : Result error_ { type_ : Type TypeVariableFromContext, substitutions : VariableSubstitutions }
okTypeUnitSubstitutionsNone =
    Ok
        { type_ = typeUnit
        , substitutions = variableSubstitutionsNone
        }


typeUnifyWithTryToExpandTypeConstruct :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Maybe
            (Result
                String
                { substitutions : VariableSubstitutions
                , type_ : Type TypeVariableFromContext
                }
            )
typeUnifyWithTryToExpandTypeConstruct declarationTypes aToExpand b =
    case aToExpand of
        TypeConstruct aTypeConstructToExpand ->
            case declarationTypes |> FastDict.get aTypeConstructToExpand.moduleOrigin of
                Nothing ->
                    Just
                        (Err
                            ("could not find declaration types in the origin module of the type construct "
                                ++ qualifiedToString
                                    { qualification = aTypeConstructToExpand.moduleOrigin
                                    , name = aTypeConstructToExpand.name
                                    }
                            )
                        )

                Just aOriginModuleTypes ->
                    case aOriginModuleTypes.typeAliases |> FastDict.get aTypeConstructToExpand.name of
                        Nothing ->
                            Nothing

                        Just aOriginAliasDeclaration ->
                            Result.andThen
                                (\constructedAliasedType ->
                                    Result.andThen
                                        (\constructedAliasedTypeUnifiedWithB ->
                                            Result.map
                                                (\fullSubstitutions ->
                                                    { type_ = constructedAliasedTypeUnifiedWithB.type_
                                                    , substitutions = fullSubstitutions
                                                    }
                                                )
                                                (variableSubstitutionsMerge declarationTypes
                                                    constructedAliasedTypeUnifiedWithB.substitutions
                                                    constructedAliasedType.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes
                                            constructedAliasedType.type_
                                            (TypeNotVariable b)
                                        )
                                )
                                (-- TODO single operation
                                 List.map2
                                    (\parameterName argument ->
                                        { variable = ( [], parameterName ), type_ = argument }
                                    )
                                    aOriginAliasDeclaration.parameters
                                    aTypeConstructToExpand.arguments
                                    |> listFoldlWhileOkFrom
                                        { type_ =
                                            aOriginAliasDeclaration.type_
                                                |> typeMapVariables (\aliasVariable -> ( [], aliasVariable ))
                                        , substitutions = variableSubstitutionsNone
                                        }
                                        (\substitution constructedAliasedTypeSoFar ->
                                            Result.andThen
                                                (\afterSubstitution ->
                                                    Result.map
                                                        (\substitutionsSoFarAndAfterSubstitution ->
                                                            { type_ = afterSubstitution.type_
                                                            , substitutions = substitutionsSoFarAndAfterSubstitution
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge declarationTypes
                                                            constructedAliasedTypeSoFar.substitutions
                                                            afterSubstitution.substitutions
                                                        )
                                                )
                                                (constructedAliasedTypeSoFar.type_
                                                    |> typeSubstituteVariable declarationTypes
                                                        substitution
                                                )
                                        )
                                )
                                |> Just

        TypeUnit ->
            Nothing

        TypeTuple _ ->
            Nothing

        TypeTriple _ ->
            Nothing

        TypeRecord _ ->
            Nothing

        TypeRecordExtension _ ->
            Nothing

        TypeFunction _ ->
            Nothing


typeRecordUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> FastDict.Dict String (Type TypeVariableFromContext)
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordUnify declarationTypes aFields bFields =
    Result.map
        (\fieldsUnified ->
            { type_ = TypeRecord fieldsUnified.fieldsUnified
            , substitutions = fieldsUnified.substitutions
            }
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            aFields
            bFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecord :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecord declarationTypes recordExtension recordFields =
    Result.andThen
        (\fieldsUnified ->
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecord fieldsUnified.fieldsUnified
                    }
                )
                (variableSubstitutionsMerge declarationTypes
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            recordExtension.recordVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record extension with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            recordExtension.fields
            recordFields
            okFieldsUnifiedEmptySubstitutionsNone
        )


typeRecordExtensionUnifyWithRecordExtension :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecordExtension declarationTypes aRecordExtension bRecordExtension =
    Result.andThen
        (\fieldsUnified ->
            let
                newBaseVariable : TypeVariableFromContext
                newBaseVariable =
                    let
                        ( aRecordVariableContext, aRecordVariableWithoutContext ) =
                            aRecordExtension.recordVariable
                    in
                    ( "base" :: aRecordVariableContext
                    , aRecordVariableWithoutContext
                    )

                bVariableReplacementFields : FastDict.Dict String (Type TypeVariableFromContext)
                bVariableReplacementFields =
                    FastDict.diff
                        aRecordExtension.fields
                        bRecordExtension.fields

                aVariableReplacementFields : FastDict.Dict String (Type TypeVariableFromContext)
                aVariableReplacementFields =
                    FastDict.diff
                        bRecordExtension.fields
                        aRecordExtension.fields
            in
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecordExtension
                            { recordVariable = newBaseVariable
                            , fields = fieldsUnified.fieldsUnified
                            }
                    }
                )
                (variableSubstitutionsMerge3 declarationTypes
                    fieldsUnified.substitutions
                    (variableSubstitutionsFromVariableToType
                        aRecordExtension.recordVariable
                        (if aVariableReplacementFields |> FastDict.isEmpty then
                            TypeVariable newBaseVariable

                         else
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields = aVariableReplacementFields
                                    }
                                )
                        )
                    )
                    (variableSubstitutionsFromVariableToType
                        bRecordExtension.recordVariable
                        (if bVariableReplacementFields |> FastDict.isEmpty then
                            TypeVariable newBaseVariable

                         else
                            TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields = bVariableReplacementFields
                                    }
                                )
                        )
                    )
                )
        )
        (FastDict.merge
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                abValueUnified.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            aRecordExtension.fields
            bRecordExtension.fields
            okFieldsUnifiedEmptySubstitutionsNone
        )


okFieldsUnifiedEmptySubstitutionsNone :
    Result
        error_
        { fieldsUnified : FastDict.Dict String (Type TypeVariableFromContext)
        , substitutions : VariableSubstitutions
        }
okFieldsUnifiedEmptySubstitutionsNone =
    Ok
        { fieldsUnified = FastDict.empty
        , substitutions = variableSubstitutionsNone
        }


{-| A part in the syntax tree with an attached

  - [range](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Range#Range) in the source
  - global [`Type`](#Type): concretely inferred,
    influenced by other branches and value/function (let) declaration type annotations

Since type is a parameter, you can fill it with any representation
like [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)

-}
type alias TypedNode value type_ =
    { range : Elm.Syntax.Range.Range
    , value : value
    , type_ : type_
    }


{-| Like [`Elm.Syntax.Expression.Expression`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Expression)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Expression type_
    = ExpressionUnit
    | ExpressionInteger
        { base : Base10Or16
        , value : Int
        }
    | ExpressionFloat Float
    | ExpressionString String
    | ExpressionChar Char
    | ExpressionReference
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    | ExpressionOperatorFunction
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , symbol : String
        }
    | ExpressionRecordAccessFunction String
    | ExpressionNegation (TypedNode (Expression type_) type_)
    | ExpressionParenthesized (TypedNode (Expression type_) type_)
    | ExpressionTuple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        }
    | ExpressionTriple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        , part2 : TypedNode (Expression type_) type_
        }
    | ExpressionRecordAccess
        { record : TypedNode (Expression type_) type_
        , fieldNameRange : Elm.Syntax.Range.Range
        , fieldName : String
        }
    | ExpressionInfixOperation
        { operator :
            { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
            , symbol : String
            , type_ : type_
            }
        , left : TypedNode (Expression type_) type_
        , right : TypedNode (Expression type_) type_
        }
    | ExpressionIfThenElse
        { condition : TypedNode (Expression type_) type_
        , onTrue : TypedNode (Expression type_) type_
        , onFalse : TypedNode (Expression type_) type_
        }
    | ExpressionList (List (TypedNode (Expression type_) type_))
    | ExpressionCall
        { called : TypedNode (Expression type_) type_
        , argument0 : TypedNode (Expression type_) type_
        , argument1Up : List (TypedNode (Expression type_) type_)
        }
    | ExpressionRecord
        (List
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        )
    | ExpressionRecordUpdate
        { recordVariable :
            TypedNode
                { moduleOrigin :
                    -- `[]` for current module
                    Elm.Syntax.ModuleName.ModuleName
                , name : String
                }
                type_
        , field0 :
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        , field1Up :
            List
                { range : Elm.Syntax.Range.Range
                , name : String
                , nameRange : Elm.Syntax.Range.Range
                , value : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLambda
        { parameter0 : TypedNode (Pattern type_) type_
        , parameter1Up : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionCaseOf
        { matchedExpression : TypedNode (Expression type_) type_
        , case0 :
            { pattern : TypedNode (Pattern type_) type_
            , result : TypedNode (Expression type_) type_
            }
        , case1Up :
            List
                { pattern : TypedNode (Pattern type_) type_
                , result : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLetIn
        { declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration type_
            }
        , declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration type_
                }
        , result : TypedNode (Expression type_) type_
        }


{-| Like [`Elm.Syntax.Expression.LetDeclaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#LetDeclaration)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type LetDeclaration type_
    = LetDestructuring
        { pattern : TypedNode (Pattern type_) type_
        , expression : TypedNode (Expression type_) type_
        }
    | LetValueOrFunctionDeclaration
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType :
                    -- variables names in here might not correspond
                    -- with those in .type_
                    Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        , type_ : type_
        }


{-| Like [`Elm.Syntax.Pattern.Pattern`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern#Pattern)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Pattern type_
    = PatternIgnored
    | PatternVariable String
    | PatternParenthesized (TypedNode (Pattern type_) type_)
    | PatternAs
        { pattern : TypedNode (Pattern type_) type_
        , variable : TypedNode String type_
        }
    | PatternUnit
    | PatternChar Char
    | PatternString String
    | PatternInt { base : Base10Or16, value : Int }
    | PatternTuple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        }
    | PatternTriple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        , part2 : TypedNode (Pattern type_) type_
        }
    | PatternRecord (List (TypedNode String type_))
    | PatternListCons
        { head : TypedNode (Pattern type_) type_
        , tail : TypedNode (Pattern type_) type_
        }
    | PatternListExact (List (TypedNode (Pattern type_) type_))
    | PatternVariant
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        , values : List (TypedNode (Pattern type_) type_)
        }


{-| Either decimal or hexadecimal.
Used by [`PatternInt`](#Pattern) and [`ExpressionInteger`](#Expression)
-}
type Base10Or16
    = Base10
    | Base16


typeBasicsFloat : Type variable_
typeBasicsFloat =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Float"
            , arguments = []
            }
        )


typeBasicsBool : Type variable_
typeBasicsBool =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Bool"
            , arguments = []
            }
        )


typeBasicsInt : Type variable_
typeBasicsInt =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Int"
            , arguments = []
            }
        )


typeStringString : Type variable_
typeStringString =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "String" ]
            , name = "String"
            , arguments = []
            }
        )


typeCharChar : Type variable_
typeCharChar =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Char" ]
            , name = "Char"
            , arguments = []
            }
        )


typeListList : Type variable -> Type variable
typeListList a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameList
            , name = "List"
            , arguments = [ a ]
            }
        )


typeParserParser : Type variable -> Type variable
typeParserParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameParser
            , name = "Parser"
            , arguments = [ a ]
            }
        )


typeParserAdvancedParser : Type variable -> Type variable -> Type variable -> Type variable
typeParserAdvancedParser context problem value =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameParserAdvanced
            , name = "Parser"
            , arguments = [ context, problem, value ]
            }
        )


typeUrlParserParser : Type variable -> Type variable -> Type variable
typeUrlParserParser a b =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameUrlParser
            , name = "Parser"
            , arguments = [ a, b ]
            }
        )


typeUrlParserQueryParser : Type variable -> Type variable
typeUrlParserQueryParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = moduleNameUrlParserQuery
            , name = "Parser"
            , arguments = [ a ]
            }
        )


patternTypedNodeIntroducedVariables : TypedNode (Pattern type_) type_ -> FastDict.Dict String type_
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            FastDict.empty

        PatternIgnored ->
            FastDict.empty

        PatternInt _ ->
            FastDict.empty

        PatternString _ ->
            FastDict.empty

        PatternChar _ ->
            FastDict.empty

        PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        PatternRecord fieldVariables ->
            fieldVariables
                |> listMapToFastDict
                    (\fieldVariable ->
                        { key = fieldVariable.value, value = fieldVariable.type_ }
                    )

        PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern |> patternTypedNodeIntroducedVariables)

        PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        PatternListCons listCons ->
            FastDict.union
                (listCons.head |> patternTypedNodeIntroducedVariables)
                (listCons.tail |> patternTypedNodeIntroducedVariables)

        PatternTuple parts ->
            FastDict.union
                (parts.part0 |> patternTypedNodeIntroducedVariables)
                (parts.part1 |> patternTypedNodeIntroducedVariables)

        PatternTriple parts ->
            (parts.part0 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part1 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part2 |> patternTypedNodeIntroducedVariables)

        PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables

        PatternVariant variant ->
            variant.values
                |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables


patternContextToInPath :
    String
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
patternContextToInPath innermostPathPart context =
    { path = innermostPathPart :: context.path
    , moduleOriginLookup = context.moduleOriginLookup
    , declarationTypes = context.declarationTypes
    }


patternTypeInfer :
    { path : List String
    , moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypeInfer context (Elm.Syntax.Node.Node fullRange pattern) =
    -- IGNORE TCO
    case pattern of
        Elm.Syntax.Pattern.FloatPattern _ ->
            Err "float patterns are invalid syntax"

        Elm.Syntax.Pattern.AllPattern ->
            Ok
                { range = fullRange
                , value = PatternIgnored
                , type_ = TypeVariable ( context.path, "ignored" )
                }

        Elm.Syntax.Pattern.UnitPattern ->
            Ok
                { range = fullRange
                , value = PatternUnit
                , type_ = typeUnit
                }

        Elm.Syntax.Pattern.CharPattern charValue ->
            Ok
                { range = fullRange
                , value = PatternChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Pattern.IntPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base10, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.HexPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base16, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.StringPattern stringValue ->
            Ok
                { range = fullRange
                , value = PatternString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Pattern.VarPattern variableName ->
            Ok
                { range = fullRange
                , value = PatternVariable variableName
                , type_ = TypeVariable ( context.path, variableName )
                }

        Elm.Syntax.Pattern.ParenthesizedPattern parenthesizedInParens ->
            Result.map
                (\inParens ->
                    { range = fullRange
                    , value = PatternParenthesized inParens
                    , type_ = inParens.type_
                    }
                )
                (parenthesizedInParens
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.AsPattern innerPatternNode (Elm.Syntax.Node.Node variableNameRange variableName) ->
            Result.map
                (\inner ->
                    { range = fullRange
                    , value =
                        PatternAs
                            { pattern = inner
                            , variable =
                                { value = variableName
                                , range = variableNameRange
                                , type_ = inner.type_
                                }
                            }
                    , type_ = inner.type_
                    }
                )
                (innerPatternNode
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.TuplePattern parts ->
            case parts of
                [] ->
                    -- should be handled by UnitPattern
                    Ok
                        { range = fullRange
                        , value = PatternUnit
                        , type_ = typeUnit
                        }

                [ parenthesizedInParens ] ->
                    -- should be handled by ParenthesizedPattern
                    Result.map
                        (\inParens ->
                            { range = fullRange
                            , value = PatternParenthesized inParens
                            , type_ = inParens.type_
                            }
                        )
                        (parenthesizedInParens
                            |> patternTypeInfer context
                        )

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            { range = fullRange
                            , value =
                                PatternTuple
                                    { part0 = part0
                                    , part1 = part1
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "part0"
                                )
                        )
                        (tuplePart1
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "part1"
                                )
                        )

                [ tuplePart0, tuplePart1, tuplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            { range = fullRange
                            , value =
                                PatternTriple
                                    { part0 = part0
                                    , part1 = part1
                                    , part2 = part2
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        , part2 = part2.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "part0"
                                )
                        )
                        (tuplePart1
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "part1"
                                )
                        )
                        (tuplePart2
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "part2"
                                )
                        )

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.Pattern.RecordPattern recordFields ->
            let
                fieldTypedNodes : List (TypedNode String (Type TypeVariableFromContext))
                fieldTypedNodes =
                    recordFields
                        |> List.map
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) ->
                                { range = fieldRange
                                , value = fieldName
                                , type_ =
                                    TypeVariable ( "field" :: context.path, fieldName )
                                }
                            )
            in
            Ok
                { range = fullRange
                , value = PatternRecord fieldTypedNodes
                , type_ =
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable =
                                ( context.path, "record" )
                            , fields =
                                fieldTypedNodes
                                    |> listMapToFastDict
                                        (\fieldVariable ->
                                            { key = fieldVariable.value
                                            , value = fieldVariable.type_
                                            }
                                        )
                            }
                        )
                }

        Elm.Syntax.Pattern.UnConsPattern headNode tailNode ->
            resultAndThen2
                (\headInferred tailInferred ->
                    Result.andThen
                        (\fullListTypeUnified ->
                            Result.map2
                                (\headAfterUnification tailAfterUnification ->
                                    { range = fullRange
                                    , value =
                                        PatternListCons
                                            { head = headAfterUnification
                                            , tail = tailAfterUnification
                                            }
                                    , type_ = fullListTypeUnified.type_
                                    }
                                )
                                (headInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                                (tailInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            (typeListList headInferred.type_)
                            tailInferred.type_
                        )
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "head")
                    headNode
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "tail")
                    tailNode
                )

        Elm.Syntax.Pattern.ListPattern elementNodes ->
            case elementNodes of
                [] ->
                    Ok
                        { range = fullRange
                        , value = patternListExactEmpty
                        , type_ =
                            typeListList
                                (TypeVariable ( context.path, "element" ))
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailInferred ->
                            Result.andThen
                                (\unifiedElementType ->
                                    Result.map2
                                        (\headInferredAfterUnification tailInferredAfterUnification ->
                                            { range = fullRange
                                            , value =
                                                PatternListExact
                                                    (headInferredAfterUnification :: tailInferredAfterUnification)
                                            , type_ =
                                                typeListList unifiedElementType.type_
                                            }
                                        )
                                        (headInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                unifiedElementType.substitutions
                                        )
                                        (tailInferred.nodes
                                            |> listFoldrWhileOkFrom []
                                                (\tailElementInferred tailAfterUnificationSoFar ->
                                                    Result.map
                                                        (\tailElementAfterUnification ->
                                                            tailElementAfterUnification
                                                                :: tailAfterUnificationSoFar
                                                        )
                                                        (tailElementInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                unifiedElementType.substitutions
                                                        )
                                                )
                                        )
                                )
                                (( headInferred, tailInferred.nodes )
                                    |> listFilledMapAndTypesUnify context.declarationTypes
                                        .type_
                                )
                        )
                        (head
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "element0"
                                )
                        )
                        (tail
                            |> listFoldrWhileOkFrom
                                indexFromEnd0NodesEmpty
                                (\elementNode soFar ->
                                    Result.map
                                        (\elementInferred ->
                                            { indexFromEnd = soFar.indexFromEnd + 1
                                            , nodes =
                                                elementInferred
                                                    :: soFar.nodes
                                            }
                                        )
                                        (patternTypeInfer
                                            (context
                                                |> patternContextToInPath
                                                    ("elementFromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                            )
                                            elementNode
                                        )
                                )
                        )

        Elm.Syntax.Pattern.NamedPattern qualified values ->
            let
                moduleOriginInfoOrError :
                    Result
                        String
                        { name : Elm.Syntax.ModuleName.ModuleName
                        , declarationTypes : ModuleTypes
                        }
                moduleOriginInfoOrError =
                    case context.moduleOriginLookup.references |> FastDict.get ( qualified.moduleName, qualified.name ) of
                        Nothing ->
                            Err
                                ("no module origin found for the pattern variant "
                                    ++ qualifiedToString
                                        { qualification = qualified.moduleName
                                        , name = qualified.name
                                        }
                                )

                        Just moduleOrigin ->
                            case context.declarationTypes |> FastDict.get moduleOrigin of
                                Nothing ->
                                    Err
                                        ("no declaration types found at the module origin of the variant reference "
                                            ++ qualifiedToString
                                                { qualification = moduleOrigin
                                                , name = qualified.name
                                                }
                                        )

                                Just moduleOriginDeclarationTypes ->
                                    Ok
                                        { name = moduleOrigin
                                        , declarationTypes = moduleOriginDeclarationTypes
                                        }
            in
            case moduleOriginInfoOrError of
                Err error ->
                    Err error

                Ok moduleOriginInfo ->
                    case
                        moduleOriginInfo.declarationTypes.choiceTypes
                            |> fastDictMapAndSmallestJust
                                (\choiceTypeName choiceTypeInfo ->
                                    choiceTypeInfo.variants
                                        |> FastDict.get qualified.name
                                        |> Maybe.map
                                            (\variantParameters ->
                                                { variantParameters = variantParameters
                                                , choiceTypeName = choiceTypeName
                                                , choiceTypeParameters = choiceTypeInfo.parameters
                                                }
                                            )
                                )
                    of
                        Nothing ->
                            Err
                                ("no choice type found at the module origin with the variant reference "
                                    ++ qualifiedToString
                                        { qualification = moduleOriginInfo.name
                                        , name = qualified.name
                                        }
                                )

                        Just variant ->
                            patternVariantTypeInfer context
                                { fullRange = fullRange
                                , qualification = qualified.moduleName
                                , moduleOrigin = moduleOriginInfo.name
                                , name = qualified.name
                                , variantValueTypes = variant.variantParameters
                                , choiceTypeName = variant.choiceTypeName
                                , choiceTypeParameters = variant.choiceTypeParameters
                                , values = values
                                }


patternListExactEmpty : Pattern (Type TypeVariableFromContext)
patternListExactEmpty =
    PatternListExact []


patternVariantTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , choiceTypeName : String
        , choiceTypeParameters : List String
        , variantValueTypes : List (Type String)
        , values : List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
        }
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternVariantTypeInfer context patternVariant =
    Result.map
        (\valuesAndResultTypeUnified ->
            { range = patternVariant.fullRange
            , value =
                PatternVariant
                    { moduleOrigin = patternVariant.moduleOrigin
                    , qualification = patternVariant.qualification
                    , name = patternVariant.name
                    , values = valuesAndResultTypeUnified.values
                    }
            , type_ = valuesAndResultTypeUnified.resultType
            }
        )
        (-- TODO single operation
         List.map2
            (\typeInVariant argumentPattern ->
                { typeInVariant =
                    typeInVariant
                        |> typeMapVariables
                            (\variableName -> ( context.path, variableName ))
                , pattern = argumentPattern
                }
            )
            patternVariant.variantValueTypes
            patternVariant.values
            |> listFoldrWhileOkFrom
                { indexFromEnd = 0
                , values = []
                , resultType =
                    TypeNotVariable
                        (TypeConstruct
                            { moduleOrigin = patternVariant.moduleOrigin
                            , name = patternVariant.choiceTypeName
                            , arguments =
                                patternVariant.choiceTypeParameters
                                    |> List.map
                                        (\parameter ->
                                            TypeVariable ( context.path, parameter )
                                        )
                            }
                        )
                }
                (\value soFar ->
                    Result.andThen
                        (\valueInferred ->
                            Result.andThen
                                (\valueTypeUnified ->
                                    Result.map2
                                        (\resultTypeAfterUnification valueInferredAfterUnification ->
                                            { indexFromEnd = soFar.indexFromEnd + 1
                                            , resultType = resultTypeAfterUnification
                                            , values =
                                                valueInferredAfterUnification
                                                    :: soFar.values
                                            }
                                        )
                                        (soFar.resultType
                                            |> typeApplyVariableSubstitutions context.declarationTypes
                                                valueTypeUnified.substitutions
                                        )
                                        (valueInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                valueTypeUnified.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    valueInferred.type_
                                    value.typeInVariant
                                )
                        )
                        (value.pattern
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath
                                        ("valueFromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                )
                        )
                )
        )


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


expressionTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionTypeInfer context syntaxExpressionNode =
    Result.mapError
        (\error ->
            if error |> String.startsWith "(" then
                error

            else
                "("
                    ++ (syntaxExpressionNode |> Elm.Syntax.Node.range |> rangeToInfoString)
                    ++ ") "
                    ++ error
        )
        (expressionTypeInferInner context syntaxExpressionNode)


expressionTypeInferInner :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionTypeInferInner context (Elm.Syntax.Node.Node fullRange expression) =
    -- IGNORE TCO
    case expression of
        Elm.Syntax.Expression.UnitExpr ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionUnit
                    , type_ = typeUnit
                    }
                , introducedTypeVariables = FastSet.empty
                }

        Elm.Syntax.Expression.Integer intValue ->
            let
                introducedNumberTypeVariable : TypeVariableFromContext
                introducedNumberTypeVariable =
                    ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base10, value = intValue }
                    , type_ = TypeVariable introducedNumberTypeVariable
                    }
                , introducedTypeVariables = FastSet.singleton introducedNumberTypeVariable
                }

        Elm.Syntax.Expression.Hex intValue ->
            let
                introducedNumberTypeVariable : TypeVariableFromContext
                introducedNumberTypeVariable =
                    ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base16, value = intValue }
                    , type_ = TypeVariable introducedNumberTypeVariable
                    }
                , introducedTypeVariables = FastSet.singleton introducedNumberTypeVariable
                }

        Elm.Syntax.Expression.Floatable floatValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionFloat floatValue
                    , type_ = typeBasicsFloat
                    }
                , introducedTypeVariables = FastSet.empty
                }

        Elm.Syntax.Expression.Literal stringValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionString stringValue
                    , type_ = typeStringString
                    }
                , introducedTypeVariables = FastSet.empty
                }

        Elm.Syntax.Expression.CharLiteral charValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node =
                    { range = fullRange
                    , value = ExpressionChar charValue
                    , type_ = typeCharChar
                    }
                , introducedTypeVariables = FastSet.empty
                }

        Elm.Syntax.Expression.PrefixOperator operator ->
            Result.map
                (\operatorInferred ->
                    { node =
                        { range = fullRange
                        , value =
                            ExpressionOperatorFunction
                                { symbol = operator
                                , moduleOrigin = operatorInferred.moduleOrigin
                                }
                        , type_ = operatorInferred.type_
                        }
                    , substitutions = variableSubstitutionsNone
                    , introducedTypeVariables =
                        operatorInferred.introducedTypeVariables
                    }
                )
                (operatorFunctionType
                    { path = context.path
                    , moduleOriginLookup = context.moduleOriginLookup
                    }
                    operator
                )

        Elm.Syntax.Expression.FunctionOrValue qualification name ->
            Result.map
                (\inferred ->
                    { substitutions = variableSubstitutionsNone
                    , node =
                        { type_ = inferred.node.type_
                        , range = inferred.node.range
                        , value = ExpressionReference inferred.node.value
                        }
                    , introducedTypeVariables = inferred.introducedTypeVariables
                    }
                )
                (expressionReferenceTypeInfer context
                    { fullRange = fullRange
                    , qualification = qualification
                    , name = name
                    }
                )

        Elm.Syntax.Expression.RecordAccessFunction dotFieldName ->
            let
                fieldName : String
                fieldName =
                    dotFieldName |> String.replace "." ""

                introducedRecordTypeVariable : TypeVariableFromContext
                introducedRecordTypeVariable =
                    ( context.path, "record" )

                introducedFieldValueTypeVariable : TypeVariableFromContext
                introducedFieldValueTypeVariable =
                    ( "field" :: context.path, fieldName )

                fieldValueType : Type TypeVariableFromContext
                fieldValueType =
                    TypeVariable introducedFieldValueTypeVariable
            in
            Ok
                { node =
                    { range = fullRange
                    , value =
                        ExpressionRecordAccessFunction fieldName
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable =
                                                introducedRecordTypeVariable
                                            , fields =
                                                FastDict.singleton fieldName
                                                    fieldValueType
                                            }
                                        )
                                , output = fieldValueType
                                }
                            )
                    }
                , substitutions = variableSubstitutionsNone
                , introducedTypeVariables =
                    FastSet.singleton introducedRecordTypeVariable
                        |> FastSet.insert introducedFieldValueTypeVariable
                }

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            Result.map
                (\inParensInferred ->
                    { node =
                        { range = fullRange
                        , value = ExpressionParenthesized inParensInferred.node
                        , type_ = inParensInferred.node.type_
                        }
                    , substitutions = inParensInferred.substitutions
                    , introducedTypeVariables =
                        inParensInferred.introducedTypeVariables
                    }
                )
                (inParens
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.Negation negated ->
            Result.andThen
                (\negatedInferred ->
                    let
                        introducedNumberTypeVariable : TypeVariableFromContext
                        introducedNumberTypeVariable =
                            ( context.path, "number" )
                    in
                    { node =
                        { range = fullRange
                        , value =
                            ExpressionNegation negatedInferred.node
                        , type_ = negatedInferred.node.type_
                        }
                    , substitutions = negatedInferred.substitutions
                    , introducedTypeVariables =
                        negatedInferred.introducedTypeVariables
                            |> FastSet.insert introducedNumberTypeVariable
                    }
                        |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                            context.declarationTypes
                            (variableSubstitutionsFromVariableToType
                                introducedNumberTypeVariable
                                negatedInferred.node.type_
                            )
                )
                (negated
                    |> expressionTypeInfer
                        (context
                            |> expressionContextToInPath "negated"
                        )
                )

        Elm.Syntax.Expression.RecordAccess recordNode fieldNameNode ->
            Result.andThen
                (\accessedRecordInferred ->
                    let
                        fieldName : String
                        fieldName =
                            fieldNameNode |> Elm.Syntax.Node.value

                        introducedFieldValueTypeVariable : TypeVariableFromContext
                        introducedFieldValueTypeVariable =
                            ( "field" :: context.path, fieldName )

                        introducedRecordTypeVariable : TypeVariableFromContext
                        introducedRecordTypeVariable =
                            ( context.path, "record" )
                    in
                    Result.andThen
                        (\recordWithAccessedFieldUnified ->
                            { node =
                                { range = fullRange
                                , value =
                                    ExpressionRecordAccess
                                        { record = accessedRecordInferred.node
                                        , fieldName = fieldName
                                        , fieldNameRange =
                                            fieldNameNode |> Elm.Syntax.Node.range
                                        }
                                , type_ = TypeVariable introducedFieldValueTypeVariable
                                }
                            , substitutions = accessedRecordInferred.substitutions
                            , introducedTypeVariables =
                                accessedRecordInferred.introducedTypeVariables
                                    |> FastSet.insert introducedRecordTypeVariable
                                    |> FastSet.insert introducedFieldValueTypeVariable
                            }
                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                    context.declarationTypes
                                    recordWithAccessedFieldUnified.substitutions
                        )
                        (typeUnify context.declarationTypes
                            accessedRecordInferred.node.type_
                            (TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable = introducedRecordTypeVariable
                                    , fields =
                                        FastDict.singleton fieldName
                                            (TypeVariable introducedFieldValueTypeVariable)
                                    }
                                )
                            )
                        )
                )
                (recordNode
                    |> expressionTypeInfer
                        (context
                            |> expressionContextToInPath "record"
                        )
                )

        Elm.Syntax.Expression.OperatorApplication operator _ left right ->
            expressionInfixOperationTypeInfer context
                { fullRange = fullRange
                , operator = operator
                , left = left
                , right = right
                }

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            resultAndThen3
                (\conditionInferred onTrueInferred onFalseInferred ->
                    resultAndThen2
                        (\conditionTypeInferredUnifiedWithBool onTrueOnFalseTypesUnified ->
                            Result.andThen
                                (\onFalseOnTrueInferredSubstitutions ->
                                    resultAndThen2
                                        (\conditionSubstituted onTrueOnFalseSubstituted ->
                                            Result.map
                                                (\fullSubstitutions ->
                                                    { substitutions = fullSubstitutions
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            conditionSubstituted.introducedTypeVariables
                                                            onTrueOnFalseSubstituted.introducedTypeVariables
                                                    , node =
                                                        { range = fullRange
                                                        , value =
                                                            ExpressionIfThenElse
                                                                { condition = conditionSubstituted.node
                                                                , onTrue = onTrueOnFalseSubstituted.node.onTrue
                                                                , onFalse = onTrueOnFalseSubstituted.node.onFalse
                                                                }
                                                        , type_ = onTrueOnFalseSubstituted.node.onTrue.type_
                                                        }
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    conditionSubstituted.substitutions
                                                    onTrueOnFalseSubstituted.substitutions
                                                )
                                        )
                                        (conditionInferred
                                            |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                                context.declarationTypes
                                                conditionTypeInferredUnifiedWithBool.substitutions
                                        )
                                        ({ substitutions = onFalseOnTrueInferredSubstitutions
                                         , introducedTypeVariables =
                                            onTrueInferred.introducedTypeVariables
                                                |> FastSet.union onFalseInferred.introducedTypeVariables
                                         }
                                            |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                                                { declarationTypes = context.declarationTypes
                                                , nodeApplyVariableSubstitutions =
                                                    \substitutionsToApply ->
                                                        Result.map2
                                                            (\onTrueSubstituted onFalseSubstituted ->
                                                                { onTrue = onTrueSubstituted, onFalse = onFalseSubstituted }
                                                            )
                                                            (onTrueInferred.node
                                                                |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                    substitutionsToApply
                                                            )
                                                            (onFalseInferred.node
                                                                |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                    substitutionsToApply
                                                            )
                                                }
                                                onTrueOnFalseTypesUnified.substitutions
                                        )
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    onTrueInferred.substitutions
                                    onFalseInferred.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            conditionInferred.node.type_
                            typeBasicsBool
                        )
                        (typeUnify context.declarationTypes
                            onTrueInferred.node.type_
                            onFalseInferred.node.type_
                        )
                )
                (condition
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "condition")
                )
                (onTrue
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onTrue")
                )
                (onFalse
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onFalse")
                )

        Elm.Syntax.Expression.TupledExpression tupleParts ->
            case tupleParts of
                [] ->
                    -- should be handled by UnitExpr
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , node =
                            { range = fullRange
                            , value = ExpressionUnit
                            , type_ = typeUnit
                            }
                        , introducedTypeVariables = FastSet.empty
                        }

                [ inParens ] ->
                    -- should be handled by ParenthesizedExpression
                    Result.map
                        (\inParensInferred ->
                            { node =
                                { range = fullRange
                                , value = ExpressionParenthesized inParensInferred.node
                                , type_ = inParensInferred.node.type_
                                }
                            , substitutions = inParensInferred.substitutions
                            , introducedTypeVariables = inParensInferred.introducedTypeVariables
                            }
                        )
                        (inParens
                            |> expressionTypeInfer context
                        )

                [ part0, part1 ] ->
                    resultAndThen2
                        (\part0Inferred part1Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTuple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTuple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    }
                                                )
                                        }
                                    , introducedTypeVariables =
                                        FastSet.union
                                            part0Inferred.introducedTypeVariables
                                            part1Inferred.introducedTypeVariables
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )

                [ part0, part1, part2 ] ->
                    resultAndThen3
                        (\part0Inferred part1Inferred part2Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTriple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                , part2 = part2Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTriple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    , part2 = part2Inferred.node.type_
                                                    }
                                                )
                                        }
                                    , introducedTypeVariables =
                                        part0Inferred.introducedTypeVariables
                                            |> FastSet.union part1Inferred.introducedTypeVariables
                                            |> FastSet.union part2Inferred.introducedTypeVariables
                                    }
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                    part2Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )
                        (part2
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "2")
                        )

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.Expression.ListExpr elements ->
            case elements of
                [] ->
                    let
                        introducedElementTypeVariable : TypeVariableFromContext
                        introducedElementTypeVariable =
                            ( context.path, "element" )
                    in
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , node =
                            { range = fullRange
                            , value = expressionListEmpty
                            , type_ =
                                typeListList
                                    (TypeVariable introducedElementTypeVariable)
                            }
                        , introducedTypeVariables =
                            FastSet.singleton introducedElementTypeVariable
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailElementsInferred ->
                            Result.andThen
                                (\elementTypeUnified ->
                                    Result.andThen
                                        (\substitutionsAcrossElements ->
                                            { substitutions = substitutionsAcrossElements
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionList
                                                        (headInferred.node
                                                            :: tailElementsInferred.nodes
                                                        )
                                                , type_ = typeListList headInferred.node.type_
                                                }
                                            , introducedTypeVariables =
                                                FastSet.union
                                                    headInferred.introducedTypeVariables
                                                    tailElementsInferred.introducedTypeVariables
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                                    context.declarationTypes
                                                    elementTypeUnified.substitutions
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            headInferred.substitutions
                                            tailElementsInferred.substitutions
                                        )
                                )
                                (listFilledMapAndTypesUnify context.declarationTypes
                                    .type_
                                    ( headInferred.node, tailElementsInferred.nodes )
                                )
                        )
                        (expressionTypeInfer
                            (context |> expressionContextToInPath "head")
                            head
                        )
                        (tail
                            |> listFoldrWhileOkFrom
                                indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty
                                (\elementNode soFar ->
                                    Result.andThen
                                        (\elementInferred ->
                                            Result.map
                                                (\substitutionsWithElement ->
                                                    { indexFromEnd = soFar.indexFromEnd + 1
                                                    , nodes =
                                                        elementInferred.node
                                                            :: soFar.nodes
                                                    , substitutions = substitutionsWithElement
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            soFar.introducedTypeVariables
                                                            elementInferred.introducedTypeVariables
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    elementInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (expressionTypeInfer
                                            (context
                                                |> expressionContextToInPath
                                                    ("fromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                            )
                                            elementNode
                                        )
                                )
                        )

        Elm.Syntax.Expression.Application application ->
            case application of
                [] ->
                    Err "empty application is invalid syntax"

                [ subExpression ] ->
                    -- never produced by elm-syntax
                    subExpression |> expressionTypeInfer context

                called :: argument0 :: argument1Up ->
                    resultAndThen3
                        (\calledInferred argument0Inferred argument1UpInferred ->
                            let
                                introducedResultTypeVariable : TypeVariableFromContext
                                introducedResultTypeVariable =
                                    ( context.path, "callResult" )
                            in
                            Result.andThen
                                (\callTypeUnified ->
                                    Result.andThen
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCall
                                                        { called = calledInferred.node
                                                        , argument0 = argument0Inferred.node
                                                        , argument1Up = argument1UpInferred.nodes
                                                        }
                                                , type_ = TypeVariable introducedResultTypeVariable
                                                }
                                            , introducedTypeVariables =
                                                calledInferred.introducedTypeVariables
                                                    |> FastSet.union
                                                        argument0Inferred.introducedTypeVariables
                                                    |> FastSet.union
                                                        argument1UpInferred.introducedTypeVariables
                                                    |> FastSet.insert introducedResultTypeVariable
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                                    context.declarationTypes
                                                    callTypeUnified.substitutions
                                        )
                                        (variableSubstitutionsMerge3 context.declarationTypes
                                            calledInferred.substitutions
                                            argument0Inferred.substitutions
                                            argument1UpInferred.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = argument0Inferred.node.type_
                                            , output =
                                                argument1UpInferred.nodes
                                                    |> List.foldr
                                                        (\argumentInferred output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentInferred.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        (TypeVariable introducedResultTypeVariable)
                                            }
                                        )
                                    )
                                    calledInferred.node.type_
                                )
                        )
                        (called
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "called")
                        )
                        (argument0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "argument0")
                        )
                        (argument1Up
                            |> listFoldrWhileOkFrom
                                indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty
                                (\argumentNode soFar ->
                                    Result.andThen
                                        (\argumentInferred ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { indexFromEnd = soFar.indexFromEnd + 1
                                                    , substitutions = substitutionsWithArgument
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            soFar.introducedTypeVariables
                                                            argumentInferred.introducedTypeVariables
                                                    , nodes =
                                                        argumentInferred.node
                                                            :: soFar.nodes
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    argumentInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (argumentNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("argumentFromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.RecordExpr fields ->
            Result.map
                (\fieldsInferred ->
                    { substitutions = fieldsInferred.substitutions
                    , node =
                        { range = fullRange
                        , value =
                            ExpressionRecord
                                fieldsInferred.nodes
                        , type_ =
                            TypeNotVariable
                                (TypeRecord
                                    (fieldsInferred.nodes
                                        |> List.foldl
                                            (\field soFar ->
                                                soFar
                                                    |> FastDict.insert field.name
                                                        field.value.type_
                                            )
                                            FastDict.empty
                                    )
                                )
                        }
                    , introducedTypeVariables = fieldsInferred.introducedTypeVariables
                    }
                )
                (fields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneIntroducedTypeVariablesEmptyNodesEmpty
                        (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node fieldNameRange fieldName, fieldValueNode )) soFar ->
                            Result.andThen
                                (\fieldValueInferred ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { nodes =
                                                { range = fieldRange
                                                , name = fieldName
                                                , nameRange = fieldNameRange
                                                , value = fieldValueInferred.node
                                                }
                                                    :: soFar.nodes
                                            , substitutions = substitutionsWithField
                                            , introducedTypeVariables =
                                                FastSet.union
                                                    soFar.introducedTypeVariables
                                                    fieldValueInferred.introducedTypeVariables
                                            }
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            fieldValueInferred.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValueNode
                                    |> expressionTypeInfer
                                        (context |> expressionContextToInPath fieldName)
                                )
                        )
                )

        Elm.Syntax.Expression.RecordUpdateExpression (Elm.Syntax.Node.Node recordVariableRange recordVariable) fields ->
            case fields of
                [] ->
                    Err "record update without fields is invalid syntax"

                (Elm.Syntax.Node.Node field0Range ( Elm.Syntax.Node.Node field0NameRange field0Name, field0ValueNode )) :: field1Up ->
                    resultAndThen3
                        (\recordVariableInferred field0Inferred field1UpInferred ->
                            let
                                introducedRecordTypeVariable : TypeVariableFromContext
                                introducedRecordTypeVariable =
                                    ( context.path, recordVariableInferred.node.value.name )
                            in
                            Result.andThen
                                (\recordVariableUnifiedWithUpdate ->
                                    Result.andThen
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionRecordUpdate
                                                        { recordVariable =
                                                            { range = recordVariableInferred.node.range
                                                            , value =
                                                                { moduleOrigin =
                                                                    recordVariableInferred.node.value.moduleOrigin
                                                                , name = recordVariableInferred.node.value.name
                                                                }
                                                            , type_ = recordVariableInferred.node.type_
                                                            }
                                                        , field0 = field0Inferred.node
                                                        , field1Up = field1UpInferred.nodes
                                                        }
                                                , type_ = recordVariableInferred.node.type_
                                                }
                                            , introducedTypeVariables =
                                                field0Inferred.introducedTypeVariables
                                                    |> FastSet.union field1UpInferred.introducedTypeVariables
                                                    |> FastSet.insert introducedRecordTypeVariable
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                                    context.declarationTypes
                                                    recordVariableUnifiedWithUpdate.substitutions
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            field0Inferred.substitutions
                                            field1UpInferred.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    recordVariableInferred.node.type_
                                    (TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable = introducedRecordTypeVariable
                                            , fields =
                                                field1UpInferred.nodes
                                                    |> List.foldl
                                                        (\fieldInferred soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldInferred.name
                                                                    fieldInferred.value.type_
                                                        )
                                                        (FastDict.singleton
                                                            field0Inferred.node.name
                                                            field0Inferred.node.value.type_
                                                        )
                                            }
                                        )
                                    )
                                )
                        )
                        ({ fullRange = recordVariableRange
                         , qualification = []
                         , name = recordVariable
                         }
                            |> expressionReferenceTypeInfer
                                (context |> expressionContextToInPath "record")
                        )
                        (Result.map
                            (\valueInferred ->
                                { substitutions = valueInferred.substitutions
                                , introducedTypeVariables = valueInferred.introducedTypeVariables
                                , node =
                                    { range = field0Range
                                    , name = field0Name
                                    , nameRange = field0NameRange
                                    , value = valueInferred.node
                                    }
                                }
                            )
                            (field0ValueNode
                                |> expressionTypeInfer
                                    (context
                                        |> expressionContextToInPath
                                            ("field" ++ stringFirstCharToUpper field0Name)
                                    )
                            )
                        )
                        (field1Up
                            |> listFoldrWhileOkFrom
                                substitutionsNoneIntroducedTypeVariablesEmptyNodesEmpty
                                (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node nameRange name, valueNode )) soFar ->
                                    Result.andThen
                                        (\fieldValueInferred ->
                                            Result.map
                                                (\substitutionsWithField ->
                                                    { substitutions = substitutionsWithField
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            soFar.introducedTypeVariables
                                                            fieldValueInferred.introducedTypeVariables
                                                    , nodes =
                                                        { range = fieldRange
                                                        , name = name
                                                        , nameRange = nameRange
                                                        , value = fieldValueInferred.node
                                                        }
                                                            :: soFar.nodes
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    soFar.substitutions
                                                    fieldValueInferred.substitutions
                                                )
                                        )
                                        (valueNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("field" ++ stringFirstCharToUpper name)
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.LambdaExpression lambda ->
            case lambda.args of
                [] ->
                    Err "lambda without parameter patterns is invalid syntax"

                parameter0 :: parameter1Up ->
                    resultAndThen2
                        (\parameter0Inferred parameter1UpInferred ->
                            Result.andThen
                                (\resultInferred ->
                                    let
                                        parameterIntroducedTypeVariables : FastSet.Set TypeVariableFromContext
                                        parameterIntroducedTypeVariables =
                                            (parameter0Inferred :: parameter1UpInferred.nodes)
                                                |> listMapToFastSetsAndUnify
                                                    (\parameterInferred ->
                                                        parameterInferred.type_ |> typeContainedVariables
                                                    )
                                    in
                                    { substitutions = variableSubstitutionsNone
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionLambda
                                                { parameter0 = parameter0Inferred
                                                , parameter1Up = parameter1UpInferred.nodes
                                                , result = resultInferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = parameter0Inferred.type_
                                                    , output =
                                                        parameter1UpInferred.nodes
                                                            |> List.foldr
                                                                (\argumentTypedNode output ->
                                                                    TypeNotVariable
                                                                        (TypeFunction
                                                                            { input = argumentTypedNode.type_
                                                                            , output = output
                                                                            }
                                                                        )
                                                                )
                                                                resultInferred.node.type_
                                                    }
                                                )
                                        }
                                    , introducedTypeVariables =
                                        FastSet.union
                                            parameterIntroducedTypeVariables
                                            resultInferred.introducedTypeVariables
                                    }
                                        |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                            context.declarationTypes
                                            resultInferred.substitutions
                                )
                                (lambda.expression
                                    |> expressionTypeInfer
                                        { containingDeclarationName = context.containingDeclarationName
                                        , path = "lambdaResult" :: context.path
                                        , declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                (List.foldl
                                                    (\parameter soFar ->
                                                        FastDict.union soFar
                                                            (parameter |> patternTypedNodeIntroducedVariables)
                                                    )
                                                    (parameter0Inferred |> patternTypedNodeIntroducedVariables)
                                                    parameter1UpInferred.nodes
                                                )
                                        }
                                )
                        )
                        (parameter0
                            |> patternTypeInfer
                                { path = "parameter0" :: context.path
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (parameter1Up
                            |> listFoldrWhileOkFrom
                                indexFromEnd0NodesEmpty
                                (\pattern soFar ->
                                    Result.map
                                        (\patternInferred ->
                                            { indexFromEnd = soFar.indexFromEnd + 1
                                            , nodes =
                                                patternInferred
                                                    :: soFar.nodes
                                            }
                                        )
                                        (pattern
                                            |> patternTypeInfer
                                                { path =
                                                    ("parameterFromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                                        :: context.path
                                                , declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            case caseOf.cases of
                [] ->
                    Err "case-of without case branches is invalid syntax"

                case0 :: case1Up ->
                    resultAndThen3
                        (\matchedInferred case0Inferred case1UpInferred ->
                            Result.andThen
                                (\unifiedTypes ->
                                    Result.andThen
                                        (\allIndividualSubstitutions ->
                                            { substitutions = allIndividualSubstitutions
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCaseOf
                                                        { matchedExpression = matchedInferred.node
                                                        , case0 = case0Inferred.node
                                                        , case1Up = case1UpInferred.nodes
                                                        }
                                                , type_ = case0Inferred.node.result.type_
                                                }
                                            , introducedTypeVariables =
                                                matchedInferred.introducedTypeVariables
                                                    |> FastSet.union case0Inferred.introducedTypeVariables
                                                    |> FastSet.union case1UpInferred.introducedTypeVariables
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                                    context.declarationTypes
                                                    unifiedTypes.substitutions
                                        )
                                        (variableSubstitutionsMerge3 context.declarationTypes
                                            matchedInferred.substitutions
                                            case0Inferred.substitutions
                                            case1UpInferred.substitutions
                                        )
                                )
                                (case1UpInferred.nodes
                                    |> listFoldlWhileOkFromResult
                                        (Result.map
                                            (\matchedExpressionCase0PatternUnifiedType ->
                                                { resultType = case0Inferred.node.result.type_
                                                , matchedType = matchedExpressionCase0PatternUnifiedType.type_
                                                , substitutions = matchedExpressionCase0PatternUnifiedType.substitutions
                                                }
                                            )
                                            (typeUnify context.declarationTypes
                                                matchedInferred.node.type_
                                                case0Inferred.node.pattern.type_
                                            )
                                        )
                                        (\caseInferred soFar ->
                                            resultAndThen2
                                                (\matchedTypeUnifiedWithCasePattern resultTypeUnifiedWithCaseResult ->
                                                    Result.map
                                                        (\substitutionsWithCase ->
                                                            { substitutions = substitutionsWithCase
                                                            , matchedType = matchedTypeUnifiedWithCasePattern.type_
                                                            , resultType = resultTypeUnifiedWithCaseResult.type_
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge3 context.declarationTypes
                                                            soFar.substitutions
                                                            matchedTypeUnifiedWithCasePattern.substitutions
                                                            resultTypeUnifiedWithCaseResult.substitutions
                                                        )
                                                )
                                                (typeUnify context.declarationTypes
                                                    soFar.matchedType
                                                    caseInferred.pattern.type_
                                                )
                                                (typeUnify context.declarationTypes
                                                    soFar.resultType
                                                    caseInferred.result.type_
                                                )
                                        )
                                )
                        )
                        (caseOf.expression
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "matched")
                        )
                        (case0
                            |> expressionCaseTypeInfer
                                { declarationTypes = context.declarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , partiallyInferredDeclarationTypes =
                                    context.locallyIntroducedDeclarationTypes
                                , containingDeclarationName = context.containingDeclarationName
                                , path = "case0" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    context.locallyIntroducedExpressionVariables
                                }
                        )
                        (case1Up
                            |> listFoldrWhileOkFrom
                                indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty
                                (\case_ soFar ->
                                    Result.andThen
                                        (\caseInferred ->
                                            Result.map
                                                (\substitutionsSoFarAndCase ->
                                                    { indexFromEnd = soFar.indexFromEnd + 1
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            soFar.introducedTypeVariables
                                                            caseInferred.introducedTypeVariables
                                                    , substitutions = substitutionsSoFarAndCase
                                                    , nodes = caseInferred.node :: soFar.nodes
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    soFar.substitutions
                                                    caseInferred.substitutions
                                                )
                                        )
                                        (case_
                                            |> expressionCaseTypeInfer
                                                { declarationTypes = context.declarationTypes
                                                , partiallyInferredDeclarationTypes =
                                                    context.locallyIntroducedDeclarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , containingDeclarationName = context.containingDeclarationName
                                                , path =
                                                    ("caseFromEnd" ++ (soFar.indexFromEnd |> String.fromInt))
                                                        :: context.path
                                                , locallyIntroducedExpressionVariables = context.locallyIntroducedExpressionVariables
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.LetExpression letIn ->
            case letIn.declarations of
                [] ->
                    Err "let-in without declarations is invalid syntax"

                letDeclaration0Node :: letDeclaration1Up ->
                    let
                        acrossLetIn :
                            { introducedExpressionVariables :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            , introducedDeclarationTypes :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            }
                        acrossLetIn =
                            (letDeclaration0Node :: letDeclaration1Up)
                                |> List.foldl
                                    (\(Elm.Syntax.Node.Node _ letDeclaration) soFar ->
                                        let
                                            contextPath : List String
                                            contextPath =
                                                ("letDeclaration"
                                                    ++ (soFar.index |> String.fromInt)
                                                )
                                                    :: context.path
                                        in
                                        case letDeclaration of
                                            Elm.Syntax.Expression.LetDestructuring patternNode _ ->
                                                case
                                                    patternNode
                                                        |> patternTypeInfer
                                                            { path = "pattern" :: contextPath
                                                            , declarationTypes = context.declarationTypes
                                                            , moduleOriginLookup = context.moduleOriginLookup
                                                            }
                                                of
                                                    Err _ ->
                                                        { index = soFar.index + 1
                                                        , introducedDeclarationTypes =
                                                            soFar.introducedDeclarationTypes
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        }

                                                    Ok patternInferred ->
                                                        { index = soFar.index + 1
                                                        , introducedDeclarationTypes =
                                                            soFar.introducedDeclarationTypes
                                                        , introducedExpressionVariables =
                                                            FastDict.union soFar.introducedExpressionVariables
                                                                (patternInferred |> patternTypedNodeIntroducedVariables)
                                                        }

                                            Elm.Syntax.Expression.LetFunction letValueOrFunctionDeclaration ->
                                                let
                                                    name : String
                                                    name =
                                                        letValueOrFunctionDeclaration.declaration
                                                            |> Elm.Syntax.Node.value
                                                            |> .name
                                                            |> Elm.Syntax.Node.value
                                                in
                                                case
                                                    letValueOrFunctionDeclaration.signature
                                                        |> Maybe.andThen
                                                            (\(Elm.Syntax.Node.Node _ signature) ->
                                                                signature.typeAnnotation
                                                                    |> Elm.Syntax.Node.value
                                                                    |> syntaxToType context.moduleOriginLookup
                                                                    |> Result.toMaybe
                                                            )
                                                of
                                                    Just type_ ->
                                                        { index = soFar.index + 1
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        , introducedDeclarationTypes =
                                                            soFar.introducedDeclarationTypes
                                                                |> FastDict.insert name
                                                                    (type_
                                                                        |> typeMapVariables (\variable -> ( [], variable ))
                                                                    )
                                                        }

                                                    Nothing ->
                                                        { index = soFar.index + 1
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        , introducedDeclarationTypes =
                                                            soFar.introducedDeclarationTypes
                                                                |> FastDict.insert name
                                                                    (TypeVariable
                                                                        ( contextPath, name )
                                                                    )
                                                        }
                                    )
                                    index0AndIntroducedDeclarationTypesEmptyIntroducedExpressionVariablesEmpty
                                |> (\result ->
                                        { introducedExpressionVariables = result.introducedExpressionVariables
                                        , introducedDeclarationTypes = result.introducedDeclarationTypes
                                        }
                                   )

                        acrossLetInIncludingContextSoFar :
                            { locallyIntroducedExpressionVariables :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            , introducedDeclarationTypes :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            }
                        acrossLetInIncludingContextSoFar =
                            { locallyIntroducedExpressionVariables =
                                FastDict.union
                                    acrossLetIn.introducedExpressionVariables
                                    context.locallyIntroducedExpressionVariables
                            , introducedDeclarationTypes =
                                FastDict.union
                                    acrossLetIn.introducedDeclarationTypes
                                    (FastDict.union
                                        acrossLetIn.introducedDeclarationTypes
                                        context.locallyIntroducedDeclarationTypes
                                    )
                            }
                    in
                    resultAndThen3
                        (\declaration0Inferred declaration1UpInferred resultInferred ->
                            Result.andThen
                                (\fullSubstitutions ->
                                    { introducedTypeVariables =
                                        declaration0Inferred.introducedTypeVariables
                                            |> FastSet.union declaration1UpInferred.introducedTypeVariables
                                            |> FastSet.union resultInferred.introducedTypeVariables
                                    , substitutions = variableSubstitutionsNone
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionLetIn
                                                { declaration0 = declaration0Inferred.node
                                                , declaration1Up = declaration1UpInferred.nodes
                                                , result = resultInferred.node
                                                }
                                        , type_ = resultInferred.node.type_
                                        }
                                    }
                                        |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                            context.declarationTypes
                                            fullSubstitutions
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    declaration0Inferred.substitutions
                                    declaration1UpInferred.substitutions
                                    resultInferred.substitutions
                                )
                        )
                        (letDeclaration0Node
                            |> letDeclarationTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letDeclaration0" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                , locallyIntroducedDeclarationTypes =
                                    acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (letDeclaration1Up
                            |> listFoldrWhileOkFrom
                                indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty
                                (\letDeclarationNode soFar ->
                                    Result.andThen
                                        (\letDeclarationInferred ->
                                            Result.map
                                                (\substitutionsWithLetDeclaration ->
                                                    { indexFromEnd = soFar.indexFromEnd + 1
                                                    , substitutions = substitutionsWithLetDeclaration
                                                    , nodes =
                                                        letDeclarationInferred.node
                                                            :: soFar.nodes
                                                    , introducedTypeVariables =
                                                        FastSet.union soFar.introducedTypeVariables
                                                            letDeclarationInferred.introducedTypeVariables
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    letDeclarationInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (letDeclarationNode
                                            |> letDeclarationTypeInfer
                                                { containingDeclarationName = context.containingDeclarationName
                                                , path =
                                                    ("letDeclarationFromEnd"
                                                        ++ (soFar.indexFromEnd |> String.fromInt)
                                                    )
                                                        :: context.path
                                                , locallyIntroducedExpressionVariables =
                                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                                , locallyIntroducedDeclarationTypes =
                                                    acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , declarationTypes = context.declarationTypes
                                                }
                                        )
                                )
                        )
                        (letIn.expression
                            |> expressionTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letInResult" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                , locallyIntroducedDeclarationTypes =
                                    acrossLetInIncludingContextSoFar.introducedDeclarationTypes
                                }
                        )

        Elm.Syntax.Expression.Operator _ ->
            Err "Elm.Syntax.Expression.Operator is not valid syntax"

        Elm.Syntax.Expression.GLSLExpression _ ->
            Err "glsl shader expressions not supported"


typeUnit : Type TypeVariableFromContext
typeUnit =
    TypeNotVariable TypeUnit


expressionListEmpty : Expression (Type TypeVariableFromContext)
expressionListEmpty =
    ExpressionList []


substitutionsNoneIntroducedTypeVariablesEmptyNodesEmpty :
    { substitutions : VariableSubstitutions
    , introducedTypeVariables : FastSet.Set TypeVariableFromContext
    , nodes : List nodes_
    }
substitutionsNoneIntroducedTypeVariablesEmptyNodesEmpty =
    { substitutions = variableSubstitutionsNone
    , introducedTypeVariables = FastSet.empty
    , nodes = []
    }


indexFromEnd0NodesEmpty : { nodes : List node_, indexFromEnd : Int }
indexFromEnd0NodesEmpty =
    { indexFromEnd = 0
    , nodes = []
    }


index0AndIntroducedDeclarationTypesEmptyIntroducedExpressionVariablesEmpty :
    { index : Int
    , introducedDeclarationTypes : FastDict.Dict String declarationType_
    , introducedExpressionVariables : FastDict.Dict String variableType_
    }
index0AndIntroducedDeclarationTypesEmptyIntroducedExpressionVariablesEmpty =
    { index = 0
    , introducedDeclarationTypes = FastDict.empty
    , introducedExpressionVariables = FastDict.empty
    }


indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty :
    { indexFromEnd : Int
    , nodes : List node_
    , introducedTypeVariables : FastSet.Set TypeVariableFromContext
    , substitutions : VariableSubstitutions
    }
indexFromEnd0AndNodesEmptyAndIntroducedTypeVariablesEmptySubstitutionsEmpty =
    { indexFromEnd = 0
    , nodes = []
    , introducedTypeVariables = FastSet.empty
    , substitutions = variableSubstitutionsNone
    }


expressionCaseTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        ( Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
        , Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        )
    ->
        Result
            String
            { node :
                { pattern :
                    TypedNode
                        (Pattern (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                , result :
                    TypedNode
                        (Expression (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                }
            , substitutions : VariableSubstitutions
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionCaseTypeInfer context ( casePattern, caseResult ) =
    Result.andThen
        (\patternInferred ->
            Result.andThen
                (\resultInferred ->
                    { substitutions = variableSubstitutionsNone
                    , introducedTypeVariables =
                        FastSet.union
                            (patternInferred.type_
                                |> typeContainedVariables
                            )
                            resultInferred.introducedTypeVariables
                    }
                        |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                            { declarationTypes = context.declarationTypes
                            , nodeApplyVariableSubstitutions =
                                \substitutionsToApply ->
                                    Result.map2
                                        (\patternInferredSubstituted resultInferredSubstituted ->
                                            { pattern = patternInferredSubstituted
                                            , result = resultInferredSubstituted
                                            }
                                        )
                                        (patternInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                substitutionsToApply
                                        )
                                        (resultInferred.node
                                            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                substitutionsToApply
                                        )
                            }
                            resultInferred.substitutions
                )
                (caseResult
                    |> expressionTypeInfer
                        { declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , locallyIntroducedDeclarationTypes =
                            context.partiallyInferredDeclarationTypes
                        , containingDeclarationName = context.containingDeclarationName
                        , path = "result" :: context.path
                        , locallyIntroducedExpressionVariables =
                            FastDict.union context.locallyIntroducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                )
        )
        (casePattern
            |> patternTypeInfer
                { declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                , path = "pattern" :: context.path
                }
        )


expressionReferenceTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    ->
        Result
            String
            { node :
                TypedNode
                    { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                    , qualification : Elm.Syntax.ModuleName.ModuleName
                    , name : String
                    }
                    (Type TypeVariableFromContext)
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionReferenceTypeInfer context expressionReference =
    let
        useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration :
            Maybe
                { node :
                    TypedNode
                        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                        , qualification : Elm.Syntax.ModuleName.ModuleName
                        , name : String
                        }
                        (Type TypeVariableFromContext)
                , introducedTypeVariables : FastSet.Set TypeVariableFromContext
                }
        useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration =
            case expressionReference.qualification of
                _ :: _ ->
                    Nothing

                [] ->
                    case
                        context.locallyIntroducedExpressionVariables
                            |> FastDict.get expressionReference.name
                    of
                        Just locallyIntroducedExpressionVariableType ->
                            Just
                                { node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = []
                                        , moduleOrigin = []
                                        , name = expressionReference.name
                                        }
                                    , type_ = locallyIntroducedExpressionVariableType
                                    }
                                , introducedTypeVariables = FastSet.empty
                                }

                        Nothing ->
                            case
                                context.locallyIntroducedDeclarationTypes
                                    |> FastDict.get expressionReference.name
                            of
                                Nothing ->
                                    Nothing

                                Just partiallyInferredType ->
                                    let
                                        type_ : Type TypeVariableFromContext
                                        type_ =
                                            partiallyInferredType
                                                |> typeMapVariables
                                                    (\( partiallyInferredTypeVariableContext, partiallyInferredTypeVariableName ) ->
                                                        ( partiallyInferredTypeVariableContext
                                                            ++ context.path
                                                        , partiallyInferredTypeVariableName
                                                        )
                                                    )
                                    in
                                    Just
                                        { node =
                                            { range = expressionReference.fullRange
                                            , value =
                                                { qualification = []
                                                , moduleOrigin = []
                                                , name = expressionReference.name
                                                }
                                            , type_ = type_
                                            }
                                        , introducedTypeVariables =
                                            type_ |> typeContainedVariables
                                        }
    in
    case useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration of
        Just inferred ->
            Ok inferred

        Nothing ->
            let
                moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                moduleOrigin =
                    context.moduleOriginLookup.references
                        |> FastDict.get ( expressionReference.qualification, expressionReference.name )
                        |> Maybe.withDefault []
            in
            case context.declarationTypes |> FastDict.get moduleOrigin of
                Nothing ->
                    Err
                        ("No declaration types found for the reference "
                            ++ qualifiedToString
                                { qualification = expressionReference.qualification
                                , name = expressionReference.name
                                }
                            ++ ". I looked for some in the module "
                            ++ (moduleOrigin |> moduleNameToString)
                        )

                Just originModuleDeclarationTypes ->
                    case
                        originModuleDeclarationTypes.signatures
                            |> FastDict.get expressionReference.name
                    of
                        Just signatureType ->
                            let
                                signatureTypeWithContext : Type TypeVariableFromContext
                                signatureTypeWithContext =
                                    signatureType
                                        |> typeMapVariables
                                            (\variableName -> ( context.path, variableName ))
                            in
                            Ok
                                { node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = expressionReference.qualification
                                        , moduleOrigin = moduleOrigin
                                        , name = expressionReference.name
                                        }
                                    , type_ = signatureTypeWithContext
                                    }
                                , introducedTypeVariables =
                                    signatureTypeWithContext |> typeContainedVariables
                                }

                        Nothing ->
                            case
                                originModuleDeclarationTypes.choiceTypes
                                    |> fastDictMapAndSmallestJust
                                        (\choiceTypeName choiceTypeInfo ->
                                            choiceTypeInfo.variants
                                                |> FastDict.get expressionReference.name
                                                |> Maybe.map
                                                    (\variantValues ->
                                                        { variantValues = variantValues
                                                        , choiceTypeName = choiceTypeName
                                                        , choiceTypeParameters = choiceTypeInfo.parameters
                                                        }
                                                    )
                                        )
                            of
                                Just variant ->
                                    let
                                        resultType : Type String
                                        resultType =
                                            TypeNotVariable
                                                (TypeConstruct
                                                    { moduleOrigin = moduleOrigin
                                                    , name = variant.choiceTypeName
                                                    , arguments =
                                                        variant.choiceTypeParameters
                                                            |> List.map TypeVariable
                                                    }
                                                )

                                        fullType : Type TypeVariableFromContext
                                        fullType =
                                            variant.variantValues
                                                |> List.foldr
                                                    (\argument output ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = argument
                                                                , output = output
                                                                }
                                                            )
                                                    )
                                                    resultType
                                                |> typeMapVariables
                                                    (\variableName -> ( context.path, variableName ))
                                    in
                                    Ok
                                        { node =
                                            { range = expressionReference.fullRange
                                            , value =
                                                { qualification = expressionReference.qualification
                                                , moduleOrigin = moduleOrigin
                                                , name = expressionReference.name
                                                }
                                            , type_ = fullType
                                            }
                                        , introducedTypeVariables =
                                            fullType |> typeContainedVariables
                                        }

                                Nothing ->
                                    case originModuleDeclarationTypes.typeAliases |> FastDict.get expressionReference.name of
                                        Just originTypeAliasDeclaration ->
                                            case ( originTypeAliasDeclaration.recordFieldOrder, originTypeAliasDeclaration.type_ ) of
                                                ( Just fieldOrder, TypeNotVariable (TypeRecord fields) ) ->
                                                    let
                                                        type_ : Type TypeVariableFromContext
                                                        type_ =
                                                            fieldOrder
                                                                |> List.foldr
                                                                    (\fieldName outputTypeSoFar ->
                                                                        case fields |> FastDict.get fieldName of
                                                                            Nothing ->
                                                                                outputTypeSoFar

                                                                            Just fieldValueType ->
                                                                                TypeNotVariable
                                                                                    (TypeFunction
                                                                                        { input =
                                                                                            fieldValueType
                                                                                                |> typeMapVariables
                                                                                                    (\name ->
                                                                                                        ( context.path, name )
                                                                                                    )
                                                                                        , output = outputTypeSoFar
                                                                                        }
                                                                                    )
                                                                    )
                                                                    (TypeNotVariable
                                                                        (TypeConstruct
                                                                            { moduleOrigin = moduleOrigin
                                                                            , name = expressionReference.name
                                                                            , arguments =
                                                                                originTypeAliasDeclaration.parameters
                                                                                    |> List.map
                                                                                        (\parameterName ->
                                                                                            TypeVariable ( context.path, parameterName )
                                                                                        )
                                                                            }
                                                                        )
                                                                    )
                                                    in
                                                    Ok
                                                        { node =
                                                            { range = expressionReference.fullRange
                                                            , value =
                                                                { qualification = expressionReference.qualification
                                                                , moduleOrigin = moduleOrigin
                                                                , name = expressionReference.name
                                                                }
                                                            , type_ = type_
                                                            }
                                                        , introducedTypeVariables =
                                                            type_ |> typeContainedVariables
                                                        }

                                                _ ->
                                                    Err
                                                        ("no value/function/port/variant/record type alias constructor was found in the origin module of the reference "
                                                            ++ qualifiedToString
                                                                { qualification = moduleOrigin
                                                                , name = expressionReference.name
                                                                }
                                                        )

                                        Nothing ->
                                            Err
                                                ("No value/function/port/variant/record type alias constructor found in the origin module of the reference "
                                                    ++ qualifiedToString
                                                        { qualification = moduleOrigin, name = expressionReference.name }
                                                )


type alias RangeAsComparable =
    ( -- start
      LocationAsComparable
    , --end
      LocationAsComparable
    )


type alias LocationAsComparable =
    ( -- row
      Int
    , --column
      Int
    )


rangeAsComparable : Elm.Syntax.Range.Range -> RangeAsComparable
rangeAsComparable range =
    ( range.start |> locationAsComparable
    , range.end |> locationAsComparable
    )


locationAsComparable : Elm.Syntax.Range.Location -> LocationAsComparable
locationAsComparable location =
    ( location.row, location.column )


expressionTypedNodeUsesOfPartiallyInferredDeclarations :
    { partiallyInferredDeclarations :
        FastDict.Dict
            String
            { nameRange : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
    }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        FastDict.Dict
            ( -- partially inferred declaration name range
              RangeAsComparable
            , -- name
              String
            )
            { partiallyInferredDeclarationType : Type TypeVariableFromContext
            , uses :
                List
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            }
expressionTypedNodeUsesOfPartiallyInferredDeclarations context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            FastDict.empty

        ExpressionInteger _ ->
            FastDict.empty

        ExpressionFloat _ ->
            FastDict.empty

        ExpressionString _ ->
            FastDict.empty

        ExpressionChar _ ->
            FastDict.empty

        ExpressionOperatorFunction _ ->
            FastDict.empty

        ExpressionRecordAccessFunction _ ->
            FastDict.empty

        ExpressionReference reference ->
            case reference.moduleOrigin of
                _ :: _ ->
                    FastDict.empty

                [] ->
                    case context.partiallyInferredDeclarations |> FastDict.get reference.name of
                        Nothing ->
                            FastDict.empty

                        Just partiallyInferredDeclaration ->
                            FastDict.singleton
                                ( partiallyInferredDeclaration.nameRange |> rangeAsComparable
                                , reference.name
                                )
                                { partiallyInferredDeclarationType =
                                    partiallyInferredDeclaration.type_
                                , uses =
                                    [ { type_ = expressionTypedNode.type_
                                      , range = expressionTypedNode.range
                                      }
                                    ]
                                }

        ExpressionParenthesized inParens ->
            expressionTypedNodeUsesOfPartiallyInferredDeclarations context inParens

        ExpressionNegation negated ->
            expressionTypedNodeUsesOfPartiallyInferredDeclarations context negated

        ExpressionTuple parts ->
            usesOfPartiallyInferredDeclarationsMerge
                (parts.part0 |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                (parts.part1 |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)

        ExpressionTriple parts ->
            (parts.part0 |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                |> usesOfPartiallyInferredDeclarationsMerge
                    (parts.part1 |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                |> usesOfPartiallyInferredDeclarationsMerge
                    (parts.part2 |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)

        ExpressionRecordAccess recordAccess ->
            expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                recordAccess.record

        ExpressionInfixOperation infixOperation ->
            usesOfPartiallyInferredDeclarationsMerge
                (infixOperation.left |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                (infixOperation.right |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)

        ExpressionIfThenElse ifThenElse ->
            (ifThenElse.condition |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                |> usesOfPartiallyInferredDeclarationsMerge
                    (ifThenElse.onTrue |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)
                |> usesOfPartiallyInferredDeclarationsMerge
                    (ifThenElse.onFalse |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context)

        ExpressionLambda lambda ->
            expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                lambda.result

        ExpressionList elements ->
            elements
                |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                    (\element ->
                        element |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                    )

        ExpressionRecord fields ->
            fields
                |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                    (\field ->
                        field.value
                            |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                    )

        ExpressionCall call ->
            call.called
                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                |> usesOfPartiallyInferredDeclarationsMerge
                    (call.argument0
                        |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                    )
                |> usesOfPartiallyInferredDeclarationsMerge
                    (call.argument1Up
                        |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                            (\argument ->
                                argument |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                            )
                    )

        ExpressionRecordUpdate recordUpdate ->
            let
                fieldUsesOfPartiallyInferredDeclarations :
                    FastDict.Dict
                        ( RangeAsComparable, String )
                        { partiallyInferredDeclarationType : Type TypeVariableFromContext
                        , uses :
                            List
                                { type_ : Type TypeVariableFromContext
                                , range : Elm.Syntax.Range.Range
                                }
                        }
                fieldUsesOfPartiallyInferredDeclarations =
                    (recordUpdate.field0 :: recordUpdate.field1Up)
                        |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                            (\field ->
                                field.value
                                    |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                            )
            in
            case recordUpdate.recordVariable.value.moduleOrigin of
                _ :: _ ->
                    fieldUsesOfPartiallyInferredDeclarations

                [] ->
                    case context.partiallyInferredDeclarations |> FastDict.get recordUpdate.recordVariable.value.name of
                        Nothing ->
                            fieldUsesOfPartiallyInferredDeclarations

                        Just partiallyInferredDeclaration ->
                            FastDict.insert
                                ( partiallyInferredDeclaration.nameRange |> rangeAsComparable
                                , recordUpdate.recordVariable.value.name
                                )
                                { partiallyInferredDeclarationType =
                                    partiallyInferredDeclaration.type_
                                , uses =
                                    [ { type_ = recordUpdate.recordVariable.type_
                                      , range = recordUpdate.recordVariable.range
                                      }
                                    ]
                                }
                                fieldUsesOfPartiallyInferredDeclarations

        ExpressionCaseOf caseOf ->
            usesOfPartiallyInferredDeclarationsMerge
                (caseOf.matchedExpression
                    |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                )
                ((caseOf.case0 :: caseOf.case1Up)
                    |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                        (\case_ ->
                            case_.result
                                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations context
                        )
                )

        ExpressionLetIn letIn ->
            let
                contextWithIntroducedPartiallyInferredDeclarations :
                    { partiallyInferredDeclarations :
                        FastDict.Dict
                            String
                            { nameRange : Elm.Syntax.Range.Range
                            , type_ : Type TypeVariableFromContext
                            }
                    }
                contextWithIntroducedPartiallyInferredDeclarations =
                    { partiallyInferredDeclarations =
                        (letIn.declaration0 :: letIn.declaration1Up)
                            |> List.foldl
                                (\letDeclaration soFar ->
                                    case letDeclaration.declaration of
                                        LetDestructuring _ ->
                                            soFar

                                        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
                                            case letValueOrFunctionDeclaration.signature of
                                                Just _ ->
                                                    soFar

                                                Nothing ->
                                                    soFar
                                                        |> FastDict.insert
                                                            letValueOrFunctionDeclaration.name
                                                            { nameRange = letValueOrFunctionDeclaration.nameRange
                                                            , type_ = letValueOrFunctionDeclaration.type_
                                                            }
                                )
                                context.partiallyInferredDeclarations
                    }
            in
            letIn.result
                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations contextWithIntroducedPartiallyInferredDeclarations
                |> usesOfPartiallyInferredDeclarationsMerge
                    ((letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToUsesOfPartiallyInferredDeclarationsAndMerge
                            (\letDeclaration ->
                                case letDeclaration.declaration of
                                    LetDestructuring letDestructuring ->
                                        letDestructuring.expression
                                            |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                contextWithIntroducedPartiallyInferredDeclarations

                                    LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
                                        letValueOrFunctionDeclaration.result
                                            |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                { partiallyInferredDeclarations =
                                                    contextWithIntroducedPartiallyInferredDeclarations.partiallyInferredDeclarations
                                                        |> FastDict.remove letValueOrFunctionDeclaration.name
                                                }
                            )
                    )


usesOfPartiallyInferredDeclarationsMerge :
    FastDict.Dict
        ( RangeAsComparable, String )
        { partiallyInferredDeclarationType : Type TypeVariableFromContext
        , uses :
            List
                { type_ : Type TypeVariableFromContext
                , range : Elm.Syntax.Range.Range
                }
        }
    ->
        FastDict.Dict
            ( RangeAsComparable, String )
            { partiallyInferredDeclarationType : Type TypeVariableFromContext
            , uses :
                List
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            }
    ->
        FastDict.Dict
            ( RangeAsComparable, String )
            { partiallyInferredDeclarationType : Type TypeVariableFromContext
            , uses :
                List
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            }
usesOfPartiallyInferredDeclarationsMerge aUses bUses =
    FastDict.merge
        (\key a soFar -> soFar |> FastDict.insert key a)
        (\key a b soFar ->
            soFar
                |> FastDict.insert key
                    { partiallyInferredDeclarationType = a.partiallyInferredDeclarationType
                    , uses = a.uses ++ b.uses
                    }
        )
        (\key b soFar -> soFar |> FastDict.insert key b)
        aUses
        bUses
        FastDict.empty


listMapToUsesOfPartiallyInferredDeclarationsAndMerge :
    (a
     ->
        FastDict.Dict
            ( RangeAsComparable, String )
            { partiallyInferredDeclarationType : Type TypeVariableFromContext
            , uses :
                List
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            }
    )
    -> List a
    ->
        FastDict.Dict
            ( RangeAsComparable, String )
            { partiallyInferredDeclarationType : Type TypeVariableFromContext
            , uses :
                List
                    { type_ : Type TypeVariableFromContext
                    , range : Elm.Syntax.Range.Range
                    }
            }
listMapToUsesOfPartiallyInferredDeclarationsAndMerge elementToUsesOfPartiallyInferredDeclarations list =
    list
        |> List.foldl
            (\element soFar ->
                usesOfPartiallyInferredDeclarationsMerge
                    soFar
                    (element |> elementToUsesOfPartiallyInferredDeclarations)
            )
            FastDict.empty


letDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
letDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letDeclaration) =
    case letDeclaration of
        Elm.Syntax.Expression.LetDestructuring letDestructuringPattern letDestructuringExpression ->
            resultAndThen2
                (\patternInferred expressionInferred ->
                    Result.andThen
                        (\patternExpressionUnified ->
                            Result.andThen
                                (\substitutionsWithUnification ->
                                    { substitutions = substitutionsWithUnification
                                    , introducedTypeVariables =
                                        FastSet.union
                                            (patternInferred |> patternTypedNodeContainedTypeVariables)
                                            expressionInferred.introducedTypeVariables
                                    }
                                        |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                                            { declarationTypes = context.declarationTypes
                                            , nodeApplyVariableSubstitutions =
                                                \substitutionsToApply ->
                                                    Result.map2
                                                        (\patternSubstituted expressionSubstituted ->
                                                            { range = letDeclarationRange
                                                            , declaration =
                                                                LetDestructuring
                                                                    { pattern = patternSubstituted
                                                                    , expression = expressionSubstituted
                                                                    }
                                                            }
                                                        )
                                                        (patternInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                substitutionsToApply
                                                        )
                                                        (expressionInferred.node
                                                            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                substitutionsToApply
                                                        )
                                            }
                                            substitutionsWithUnification
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    expressionInferred.substitutions
                                    patternExpressionUnified.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            patternInferred.type_
                            expressionInferred.node.type_
                        )
                )
                (letDestructuringPattern
                    |> patternTypeInfer
                        { path = "pattern" :: context.path
                        , declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        }
                )
                (letDestructuringExpression
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "expression")
                )

        Elm.Syntax.Expression.LetFunction letValueOrFunction ->
            letFunctionOrValueDeclarationTypeInfer context
                (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction)


letFunctionOrValueDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Function
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
letFunctionOrValueDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction) =
    let
        implementation : Elm.Syntax.Expression.FunctionImplementation
        implementation =
            letValueOrFunction.declaration |> Elm.Syntax.Node.value
    in
    Result.andThen
        (\parametersInferred ->
            let
                name : String
                name =
                    implementation.name |> Elm.Syntax.Node.value
            in
            case letValueOrFunction.signature of
                Nothing ->
                    let
                        letDeclarationTypeVariable : TypeVariableFromContext
                        letDeclarationTypeVariable =
                            ( context.path, name )
                    in
                    Result.andThen
                        (\resultInferred ->
                            { substitutions =
                                variableSubstitutionsFromVariableToType
                                    letDeclarationTypeVariable
                                    (parametersInferred.nodes
                                        |> List.foldr
                                            (\parameterTypedNode outputSoFar ->
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = parameterTypedNode.type_
                                                        , output = outputSoFar
                                                        }
                                                    )
                                            )
                                            resultInferred.node.type_
                                    )
                            , introducedTypeVariables =
                                parametersInferred.nodes
                                    |> listMapToFastSetsAndUnify
                                        patternTypedNodeContainedTypeVariables
                                    |> FastSet.union resultInferred.introducedTypeVariables
                            }
                                |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                                    { declarationTypes = context.declarationTypes
                                    , nodeApplyVariableSubstitutions =
                                        \substitutionsToApply ->
                                            Result.map2
                                                (\parametersSubstituted resultSubstituted ->
                                                    { range = letDeclarationRange
                                                    , declaration =
                                                        LetValueOrFunctionDeclaration
                                                            { signature = Nothing
                                                            , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                            , name = name
                                                            , parameters = parametersSubstituted
                                                            , result = resultSubstituted
                                                            , type_ = TypeVariable letDeclarationTypeVariable
                                                            }
                                                    }
                                                )
                                                (parametersInferred.nodes
                                                    |> listFoldrWhileOkFrom []
                                                        (\parameterInferred soFar ->
                                                            Result.map
                                                                (\parameterSubstituted ->
                                                                    parameterSubstituted :: soFar
                                                                )
                                                                (parameterInferred
                                                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                        substitutionsToApply
                                                                )
                                                        )
                                                )
                                                (resultInferred.node
                                                    |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                        substitutionsToApply
                                                )
                                    }
                                    resultInferred.substitutions
                        )
                        (implementation.expression
                            |> expressionTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letDeclarationResult" :: context.path
                                , declarationTypes = context.declarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , locallyIntroducedDeclarationTypes =
                                    context.locallyIntroducedDeclarationTypes
                                        |> -- elm declarations do not allow "polymorphic recursion"
                                           -- https://github.com/elm/compiler/issues/2275
                                           -- so instead of putting it in partiallyInferredDeclarationTypes
                                           -- we treat it as an introduced variable (sharing the same type variables)
                                           FastDict.remove name
                                , locallyIntroducedExpressionVariables =
                                    FastDict.union
                                        parametersInferred.introducedExpressionVariables
                                        context.locallyIntroducedExpressionVariables
                                        |> FastDict.insert name
                                            (TypeVariable letDeclarationTypeVariable)
                                }
                        )

                Just (Elm.Syntax.Node.Node signatureRange letValueOrFunctionSignature) ->
                    Result.andThen
                        (\annotationAsType ->
                            let
                                annotationAsTypeWithContext : Type TypeVariableFromContext
                                annotationAsTypeWithContext =
                                    annotationAsType
                                        |> typeMapVariables
                                            (\variable ->
                                                ( [ context.containingDeclarationName ], variable )
                                            )
                            in
                            Result.andThen
                                (\resultInferred ->
                                    Result.andThen
                                        (\typeUnifiedWithAnnotation ->
                                            Result.andThen
                                                (\fullSubstitutions ->
                                                    let
                                                        parametersInferredContainedTypeVariables : FastSet.Set TypeVariableFromContext
                                                        parametersInferredContainedTypeVariables =
                                                            parametersInferred.nodes
                                                                |> listMapToFastSetsAndUnify
                                                                    (\parameterInferred ->
                                                                        parameterInferred.type_ |> typeContainedVariables
                                                                    )
                                                    in
                                                    { substitutions = variableSubstitutionsNone
                                                    , introducedTypeVariables =
                                                        FastSet.union
                                                            parametersInferredContainedTypeVariables
                                                            resultInferred.introducedTypeVariables
                                                    }
                                                        |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                                                            { declarationTypes = context.declarationTypes
                                                            , nodeApplyVariableSubstitutions =
                                                                \variableSubstitutionsToApply ->
                                                                    Result.map3
                                                                        (\parametersSubstituted resultSubstituted typeSubstituted ->
                                                                            { range = letDeclarationRange
                                                                            , declaration =
                                                                                LetValueOrFunctionDeclaration
                                                                                    { signature =
                                                                                        Just
                                                                                            { range = signatureRange
                                                                                            , nameRange =
                                                                                                letValueOrFunctionSignature.name |> Elm.Syntax.Node.range
                                                                                            , annotationType =
                                                                                                letValueOrFunctionSignature.typeAnnotation
                                                                                                    |> Elm.Syntax.Node.value
                                                                                            , annotationTypeRange =
                                                                                                letValueOrFunctionSignature.typeAnnotation
                                                                                                    |> Elm.Syntax.Node.range
                                                                                            }
                                                                                    , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                                    , name = name
                                                                                    , parameters = parametersSubstituted
                                                                                    , result = resultSubstituted
                                                                                    , type_ = typeSubstituted
                                                                                    }
                                                                            }
                                                                        )
                                                                        (parametersInferred.nodes
                                                                            |> listFoldrWhileOkFrom []
                                                                                (\parameter soFar ->
                                                                                    Result.map
                                                                                        (\parameterInferredSubstituted ->
                                                                                            parameterInferredSubstituted :: soFar
                                                                                        )
                                                                                        (parameter
                                                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                                                variableSubstitutionsToApply
                                                                                        )
                                                                                )
                                                                        )
                                                                        (resultInferred.node
                                                                            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                                variableSubstitutionsToApply
                                                                        )
                                                                        (typeUnifiedWithAnnotation.type_
                                                                            |> typeApplyVariableSubstitutions context.declarationTypes
                                                                                variableSubstitutionsToApply
                                                                        )
                                                            }
                                                            fullSubstitutions
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    resultInferred.substitutions
                                                    typeUnifiedWithAnnotation.substitutions
                                                )
                                        )
                                        (typeUnify context.declarationTypes
                                            annotationAsTypeWithContext
                                            (parametersInferred.nodes
                                                |> List.foldr
                                                    (\parameterTypedNode outputSoFar ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = parameterTypedNode.type_
                                                                , output = outputSoFar
                                                                }
                                                            )
                                                    )
                                                    resultInferred.node.type_
                                            )
                                        )
                                )
                                (implementation.expression
                                    |> expressionTypeInfer
                                        { containingDeclarationName = context.containingDeclarationName
                                        , path = "letDeclarationResult" :: context.path
                                        , declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , locallyIntroducedDeclarationTypes =
                                            context.locallyIntroducedDeclarationTypes
                                                |> -- elm declarations do not allow "polymorphic recursion"
                                                   -- https://github.com/elm/compiler/issues/2275
                                                   -- so instead of putting it in partiallyInferredDeclarationTypes
                                                   -- we treat it as an introduced variable (sharing the same type variables)
                                                   FastDict.remove name
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                parametersInferred.introducedExpressionVariables
                                                |> FastDict.insert name
                                                    annotationAsTypeWithContext
                                        }
                                )
                        )
                        (letValueOrFunctionSignature.typeAnnotation
                            |> Elm.Syntax.Node.value
                            |> syntaxToType context.moduleOriginLookup
                        )
        )
        (implementation.arguments
            |> parameterPatternsTypeInfer
                { path = context.path
                , declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


moduleNameToString : Elm.Syntax.ModuleName.ModuleName -> String
moduleNameToString moduleName =
    moduleName |> String.join "."


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toLower headChar) tailString


expressionInfixOperationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , locallyIntroducedDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , operator : String
        , left : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        , right : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionInfixOperationTypeInfer context infixOperation =
    resultAndThen3
        (\operatorAsFunctionType leftInferred rightInferred ->
            let
                introducedResultTypeVariable : TypeVariableFromContext
                introducedResultTypeVariable =
                    ( context.path, "operationResult" )
            in
            Result.andThen
                (\unifiedType ->
                    Result.andThen
                        (\leftRightSubstitutions ->
                            { substitutions = leftRightSubstitutions
                            , node =
                                { range = infixOperation.fullRange
                                , value =
                                    ExpressionInfixOperation
                                        { operator =
                                            { type_ = operatorAsFunctionType.type_
                                            , moduleOrigin = operatorAsFunctionType.moduleOrigin
                                            , symbol = infixOperation.operator
                                            }
                                        , left = leftInferred.node
                                        , right = rightInferred.node
                                        }
                                , type_ = TypeVariable introducedResultTypeVariable
                                }
                            , introducedTypeVariables =
                                operatorAsFunctionType.introducedTypeVariables
                                    |> FastSet.union leftInferred.introducedTypeVariables
                                    |> FastSet.union rightInferred.introducedTypeVariables
                                    |> FastSet.insert introducedResultTypeVariable
                            }
                                |> expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables
                                    context.declarationTypes
                                    unifiedType.substitutions
                        )
                        (variableSubstitutionsMerge context.declarationTypes
                            leftInferred.substitutions
                            rightInferred.substitutions
                        )
                )
                (typeUnify context.declarationTypes
                    operatorAsFunctionType.type_
                    (TypeNotVariable
                        (TypeFunction
                            { input = leftInferred.node.type_
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = rightInferred.node.type_
                                        , output = TypeVariable introducedResultTypeVariable
                                        }
                                    )
                            }
                        )
                    )
                )
        )
        (operatorFunctionType
            { path = "operator" :: context.path
            , moduleOriginLookup = context.moduleOriginLookup
            }
            infixOperation.operator
        )
        (infixOperation.left
            |> expressionTypeInfer
                (context
                    |> expressionContextToInPath "left"
                )
        )
        (infixOperation.right
            |> expressionTypeInfer
                (context
                    |> expressionContextToInPath "right"
                )
        )


operatorFunctionType :
    { path : List String, moduleOriginLookup : ModuleOriginLookup }
    -> String
    ->
        Result
            String
            { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
            , type_ : Type TypeVariableFromContext
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
operatorFunctionType context operator =
    case operator of
        "|>" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = a
                                                    , output = b
                                                    }
                                                )
                                        , output = b
                                        }
                                    )
                            }
                        )
                }

        "<|" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = a
                                        , output = b
                                        }
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = a
                                        , output = b
                                        }
                                    )
                            }
                        )
                }

        ">>" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                cVariable : TypeVariableFromContext
                cVariable =
                    ( context.path, "c" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable

                c : Type TypeVariableFromContext
                c =
                    TypeVariable cVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                        |> FastSet.insert cVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = a
                                        , output = b
                                        }
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = b
                                                    , output = c
                                                    }
                                                )
                                        , output =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = a
                                                    , output = c
                                                    }
                                                )
                                        }
                                    )
                            }
                        )
                }

        "<<" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                cVariable : TypeVariableFromContext
                cVariable =
                    ( context.path, "c" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable

                c : Type TypeVariableFromContext
                c =
                    TypeVariable cVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                        |> FastSet.insert cVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = b
                                        , output = c
                                        }
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = a
                                                    , output = b
                                                    }
                                                )
                                        , output =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = a
                                                    , output = c
                                                    }
                                                )
                                        }
                                    )
                            }
                        )
                }

        "++" ->
            let
                appendableVariable : TypeVariableFromContext
                appendableVariable =
                    ( context.path, "appendable" )

                appendable : Type TypeVariableFromContext
                appendable =
                    TypeVariable appendableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton appendableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = appendable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = appendable
                                        , output = appendable
                                        }
                                    )
                            }
                        )
                }

        "==" ->
            let
                equatableVariable : TypeVariableFromContext
                equatableVariable =
                    ( context.path, "equatable" )

                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable equatableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton equatableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = equatable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = equatable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        "/=" ->
            let
                equatableVariable : TypeVariableFromContext
                equatableVariable =
                    ( context.path, "equatable" )

                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable equatableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton equatableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = equatable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = equatable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        "::" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "element" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton aVariable
                , moduleOrigin = moduleNameList
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = a
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeListList a
                                        , output = typeListList a
                                        }
                                    )
                            }
                        )
                }

        "*" ->
            let
                numberVariable : TypeVariableFromContext
                numberVariable =
                    ( context.path, "number" )

                number : Type TypeVariableFromContext
                number =
                    TypeVariable numberVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton numberVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = number
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = number
                                        , output = number
                                        }
                                    )
                            }
                        )
                }

        "+" ->
            let
                numberVariable : TypeVariableFromContext
                numberVariable =
                    ( context.path, "number" )

                number : Type TypeVariableFromContext
                number =
                    TypeVariable numberVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton numberVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = number
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = number
                                        , output = number
                                        }
                                    )
                            }
                        )
                }

        "-" ->
            let
                numberVariable : TypeVariableFromContext
                numberVariable =
                    ( context.path, "number" )

                number : Type TypeVariableFromContext
                number =
                    TypeVariable numberVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton numberVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = number
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = number
                                        , output = number
                                        }
                                    )
                            }
                        )
                }

        "/" ->
            okFdivOperatorInfo

        "^" ->
            let
                numberVariable : TypeVariableFromContext
                numberVariable =
                    ( context.path, "number" )

                number : Type TypeVariableFromContext
                number =
                    TypeVariable numberVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton numberVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = number
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = number
                                        , output = number
                                        }
                                    )
                            }
                        )
                }

        "<=" ->
            let
                comparableVariable : TypeVariableFromContext
                comparableVariable =
                    ( context.path, "comparable" )

                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable comparableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton comparableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = comparable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = comparable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        ">=" ->
            let
                comparableVariable : TypeVariableFromContext
                comparableVariable =
                    ( context.path, "comparable" )

                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable comparableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton comparableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = comparable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = comparable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        ">" ->
            let
                comparableVariable : TypeVariableFromContext
                comparableVariable =
                    ( context.path, "comparable" )

                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable comparableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton comparableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = comparable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = comparable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        "<" ->
            let
                comparableVariable : TypeVariableFromContext
                comparableVariable =
                    ( context.path, "comparable" )

                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable comparableVariable
            in
            Ok
                { introducedTypeVariables = FastSet.singleton comparableVariable
                , moduleOrigin = moduleNameBasics
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = comparable
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = comparable
                                        , output = typeBasicsBool
                                        }
                                    )
                            }
                        )
                }

        "//" ->
            okIdivOperatorInfo

        "&&" ->
            okAndOperatorInfo

        "||" ->
            okOrOperatorInfo

        "|." ->
            Ok
                (if context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced then
                    let
                        varContextVariable : TypeVariableFromContext
                        varContextVariable =
                            ( context.path, "context" )

                        problemVariable : TypeVariableFromContext
                        problemVariable =
                            ( context.path, "problem" )

                        keepVariable : TypeVariableFromContext
                        keepVariable =
                            ( context.path, "keep" )

                        ignoreVariable : TypeVariableFromContext
                        ignoreVariable =
                            ( context.path, "ignore" )

                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable varContextVariable

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable problemVariable

                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable keepVariable

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ignoreVariable
                    in
                    { introducedTypeVariables =
                        FastSet.singleton varContextVariable
                            |> FastSet.insert problemVariable
                            |> FastSet.insert keepVariable
                            |> FastSet.insert ignoreVariable
                    , moduleOrigin = moduleNameParserAdvanced
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeParserAdvancedParser varContext problem keep
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = typeParserAdvancedParser varContext problem ignore
                                            , output = typeParserAdvancedParser varContext problem keep
                                            }
                                        )
                                }
                            )
                    }

                 else
                    let
                        keepVariable : TypeVariableFromContext
                        keepVariable =
                            ( context.path, "keep" )

                        ignoreVariable : TypeVariableFromContext
                        ignoreVariable =
                            ( context.path, "ignore" )

                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable keepVariable

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ignoreVariable
                    in
                    { introducedTypeVariables =
                        FastSet.singleton keepVariable
                            |> FastSet.insert ignoreVariable
                    , moduleOrigin = moduleNameParser
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeParserParser keep
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = typeParserParser ignore
                                            , output = typeParserParser keep
                                            }
                                        )
                                }
                            )
                    }
                )

        "|=" ->
            Ok
                (if context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced then
                    let
                        varContextVariable : TypeVariableFromContext
                        varContextVariable =
                            ( context.path, "context" )

                        problemVariable : TypeVariableFromContext
                        problemVariable =
                            ( context.path, "problem" )

                        aVariable : TypeVariableFromContext
                        aVariable =
                            ( context.path, "a" )

                        bVariable : TypeVariableFromContext
                        bVariable =
                            ( context.path, "b" )

                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable varContextVariable

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable problemVariable

                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable aVariable

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable bVariable
                    in
                    { introducedTypeVariables =
                        FastSet.singleton varContextVariable
                            |> FastSet.insert problemVariable
                            |> FastSet.insert aVariable
                            |> FastSet.insert bVariable
                    , moduleOrigin = moduleNameParserAdvanced
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input =
                                    typeParserAdvancedParser
                                        varContext
                                        problem
                                        (TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = typeParserAdvancedParser varContext problem a
                                            , output = typeParserAdvancedParser varContext problem b
                                            }
                                        )
                                }
                            )
                    }

                 else
                    let
                        aVariable : TypeVariableFromContext
                        aVariable =
                            ( context.path, "a" )

                        bVariable : TypeVariableFromContext
                        bVariable =
                            ( context.path, "b" )

                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable aVariable

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable bVariable
                    in
                    { introducedTypeVariables =
                        FastSet.singleton aVariable
                            |> FastSet.insert bVariable
                    , moduleOrigin = moduleNameParser
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input =
                                    typeParserParser
                                        (TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = typeParserParser a
                                            , output = typeParserParser b
                                            }
                                        )
                                }
                            )
                    }
                )

        "</>" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                cVariable : TypeVariableFromContext
                cVariable =
                    ( context.path, "c" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable

                c : Type TypeVariableFromContext
                c =
                    TypeVariable cVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                        |> FastSet.insert cVariable
                , moduleOrigin = moduleNameUrlParser
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input = typeUrlParserParser a b
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeUrlParserParser b c
                                        , output = typeUrlParserParser a c
                                        }
                                    )
                            }
                        )
                }

        "<?>" ->
            let
                aVariable : TypeVariableFromContext
                aVariable =
                    ( context.path, "a" )

                bVariable : TypeVariableFromContext
                bVariable =
                    ( context.path, "b" )

                queryVariable : TypeVariableFromContext
                queryVariable =
                    ( context.path, "query" )

                a : Type TypeVariableFromContext
                a =
                    TypeVariable aVariable

                b : Type TypeVariableFromContext
                b =
                    TypeVariable bVariable

                query : Type TypeVariableFromContext
                query =
                    TypeVariable queryVariable
            in
            Ok
                { introducedTypeVariables =
                    FastSet.singleton aVariable
                        |> FastSet.insert bVariable
                        |> FastSet.insert queryVariable
                , moduleOrigin = moduleNameUrlParser
                , type_ =
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                typeUrlParserParser
                                    a
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = query
                                            , output = b
                                            }
                                        )
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeUrlParserQueryParser query
                                        , output = typeUrlParserParser a b
                                        }
                                    )
                            }
                        )
                }

        unknownOperator ->
            Err ("unknown operator (" ++ unknownOperator ++ ")")


okIdivOperatorInfo :
    Result
        error_
        { introducedTypeVariables : FastSet.Set variable
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , type_ : Type variable
        }
okIdivOperatorInfo =
    Ok
        { introducedTypeVariables = FastSet.empty
        , moduleOrigin = moduleNameBasics
        , type_ =
            TypeNotVariable
                (TypeFunction
                    { input = typeBasicsInt
                    , output =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeBasicsInt
                                , output = typeBasicsInt
                                }
                            )
                    }
                )
        }


okFdivOperatorInfo :
    Result
        error_
        { introducedTypeVariables : FastSet.Set variable
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , type_ : Type variable
        }
okFdivOperatorInfo =
    Ok
        { introducedTypeVariables = FastSet.empty
        , moduleOrigin = moduleNameBasics
        , type_ =
            TypeNotVariable
                (TypeFunction
                    { input = typeBasicsFloat
                    , output =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeBasicsFloat
                                , output = typeBasicsFloat
                                }
                            )
                    }
                )
        }


okOrOperatorInfo :
    Result
        error_
        { introducedTypeVariables : FastSet.Set variable
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , type_ : Type variable
        }
okOrOperatorInfo =
    Ok
        { introducedTypeVariables = FastSet.empty
        , moduleOrigin = moduleNameBasics
        , type_ =
            TypeNotVariable
                (TypeFunction
                    { input = typeBasicsBool
                    , output =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeBasicsBool
                                , output = typeBasicsBool
                                }
                            )
                    }
                )
        }


okAndOperatorInfo :
    Result
        error_
        { introducedTypeVariables : FastSet.Set variable
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , type_ : Type variable
        }
okAndOperatorInfo =
    Ok
        { introducedTypeVariables = FastSet.empty
        , moduleOrigin = moduleNameBasics
        , type_ =
            TypeNotVariable
                (TypeFunction
                    { input = typeBasicsBool
                    , output =
                        TypeNotVariable
                            (TypeFunction
                                { input = typeBasicsBool
                                , output = typeBasicsBool
                                }
                            )
                    }
                )
        }


moduleNameBasics : Elm.Syntax.ModuleName.ModuleName
moduleNameBasics =
    [ "Basics" ]


moduleNameList : Elm.Syntax.ModuleName.ModuleName
moduleNameList =
    [ "List" ]


moduleNameParserAdvanced : Elm.Syntax.ModuleName.ModuleName
moduleNameParserAdvanced =
    [ "Parser", "Advanced" ]


moduleNameParser : Elm.Syntax.ModuleName.ModuleName
moduleNameParser =
    [ "Parser" ]


moduleNameUrlParserQuery : Elm.Syntax.ModuleName.ModuleName
moduleNameUrlParserQuery =
    [ "Url", "Parser", "Query" ]


moduleNameUrlParser : Elm.Syntax.ModuleName.ModuleName
moduleNameUrlParser =
    [ "Url", "Parser" ]


expressionContextToInPath :
    String
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , locallyIntroducedDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , locallyIntroducedDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
expressionContextToInPath innermostPathDescription context =
    { containingDeclarationName = context.containingDeclarationName
    , path = innermostPathDescription :: context.path
    , declarationTypes = context.declarationTypes
    , locallyIntroducedExpressionVariables =
        context.locallyIntroducedExpressionVariables
    , locallyIntroducedDeclarationTypes =
        context.locallyIntroducedDeclarationTypes
    , moduleOriginLookup = context.moduleOriginLookup
    }


{-| Infer types of
value/[`Elm.Syntax.Expression.Function`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Function) declarations
in a module.

    import Elm.Syntax.Node
    import Elm.Syntax.Expression
    import ElmSyntaxTypeInfer


    [ { declaration =
            Elm.Syntax.Node.empty
                { name = Elm.Syntax.Node.empty "hello"
                , expression =
                    Elm.Syntax.Node.empty
                        (Elm.Syntax.Expression.Literal "world")
                , arguments = []
                }
      , signature = Nothing
      , documentation = Nothing
      }
    ]
        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
            { importedTypes = ElmSyntaxTypeInfer.elmCoreTypes
            , moduleOriginLookup = exampleModuleOriginLookup
            , otherModuleDeclaredTypes =
                []
                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                        exampleModuleOriginLookup
                    |> .types
            }
    -->
    Ok
        (FastDict.singleton "hello"
            { type_ =
                ElmSyntaxTypeInfer.TypeNotVariable
                    (ElmSyntaxTypeInfer.TypeConstruct
                        { moduleOrigin = [ "String" ], name = "String", arguments = [] }
                    )
            ...
            }
        )


    exampleModuleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
    exampleModuleOriginLookup =
        []
            |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                ElmSyntaxTypeInfer.elmCoreTypes
    
See [`ModuleTypes`](#ModuleTypes) and [`ModuleOriginLookup`](#ModuleOriginLookup)

Warning! Always first verify that provided type alias declarations aren't (mutually) recursive.
Otherwise this function might never terminate. 

-}
valueAndFunctionDeclarations :
    { importedTypes :
        FastDict.Dict
            Elm.Syntax.ModuleName.ModuleName
            ModuleTypes
    , moduleOriginLookup : ModuleOriginLookup
    , otherModuleDeclaredTypes : ModuleTypes
    }
    -> List Elm.Syntax.Expression.Function
    ->
        Result
            String
            (FastDict.Dict
                String
                { parameters :
                    List (TypedNode (Pattern (Type String)) (Type String))
                , result : TypedNode (Expression (Type String)) (Type String)
                , type_ : Type String
                , nameRange : Elm.Syntax.Range.Range
                , documentation :
                    Maybe
                        { content : String
                        , range : Elm.Syntax.Range.Range
                        }
                , signature :
                    Maybe
                        { range : Elm.Syntax.Range.Range
                        , nameRange : Elm.Syntax.Range.Range
                        , annotationTypeRange : Elm.Syntax.Range.Range
                        , -- variables names in here might not correspond
                          -- with those in .type_
                          annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                        }
                }
            )
valueAndFunctionDeclarations typesAndOriginLookup syntaxValueAndFunctionDeclarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            { keepOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced
            , ignoreOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced
            , typeConstructs =
                typesAndOriginLookup.moduleOriginLookup.typeConstructs
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> fastDictMapToFastDict
                                (\typeAliasName _ ->
                                    { key = ( [], typeAliasName ), value = [] }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                            |> FastDict.foldl
                                (\choiceTypeName _ soFar ->
                                    soFar
                                        |> FastDict.insert ( [], choiceTypeName ) []
                                )
                                FastDict.empty
                        )
            , references =
                typesAndOriginLookup.moduleOriginLookup.references
                    |> FastDict.union
                        (syntaxValueAndFunctionDeclarations
                            |> listMapToFastDict
                                (\valueOrFunctionDeclaration ->
                                    { key =
                                        ( []
                                        , valueOrFunctionDeclaration.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .name
                                            |> Elm.Syntax.Node.value
                                        )
                                    , value = []
                                    }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                            |> fastDictMapToFastDict
                                (\signatureName _ ->
                                    { key = ( [], signatureName ), value = [] }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> FastDict.foldl
                                (\typeAliasName info soFar ->
                                    case info.recordFieldOrder of
                                        Nothing ->
                                            soFar

                                        Just _ ->
                                            soFar |> FastDict.insert ( [], typeAliasName ) []
                                )
                                FastDict.empty
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                            |> FastDict.foldl
                                (\_ info soFar ->
                                    soFar
                                        |> FastDict.union
                                            (info.variants
                                                |> fastDictMapToFastDict
                                                    (\variantName _ ->
                                                        { key = ( [], variantName ), value = [] }
                                                    )
                                            )
                                )
                                FastDict.empty
                        )
            }

        acrossValueAndFunctionDeclarationsToInfer :
            { partiallyInferredDeclarationTypes :
                FastDict.Dict String (Type TypeVariableFromContext)
            , annotated : FastDict.Dict String (Type String)
            }
        acrossValueAndFunctionDeclarationsToInfer =
            syntaxValueAndFunctionDeclarations
                |> List.foldl
                    (\syntaxValueOrFunctionDeclaration soFar ->
                        let
                            name : String
                            name =
                                syntaxValueOrFunctionDeclaration.declaration
                                    |> Elm.Syntax.Node.value
                                    |> .name
                                    |> Elm.Syntax.Node.value
                        in
                        case
                            syntaxValueOrFunctionDeclaration.signature
                                |> Maybe.andThen
                                    (\(Elm.Syntax.Node.Node _ signature) ->
                                        signature.typeAnnotation
                                            |> Elm.Syntax.Node.value
                                            |> syntaxToType moduleOriginLookup
                                            |> Result.toMaybe
                                    )
                        of
                            Just type_ ->
                                { partiallyInferredDeclarationTypes =
                                    soFar.partiallyInferredDeclarationTypes
                                , annotated =
                                    soFar.annotated
                                        |> FastDict.insert name type_
                                }

                            Nothing ->
                                { annotated = soFar.annotated
                                , partiallyInferredDeclarationTypes =
                                    soFar.partiallyInferredDeclarationTypes
                                        |> FastDict.insert name
                                            (TypeVariable ( [ name ], name ))
                                }
                    )
                    partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty

        declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        declarationTypes =
            typesAndOriginLookup.importedTypes
                |> FastDict.map
                    (\moduleName moduleDeclarationTypes ->
                        moduleDeclarationTypes
                            |> moduleTypesSetLocalTypesToOrigin moduleName
                    )
                |> FastDict.insert []
                    { signatures =
                        FastDict.union
                            typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                            acrossValueAndFunctionDeclarationsToInfer.annotated
                    , typeAliases = typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                    , choiceTypes = typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                    }
    in
    syntaxValueAndFunctionDeclarations
        |> listFoldlWhileOkFrom
            substitutionsNoneDeclarationsDictEmpty
            (\valueOrFunctionDeclarationToInfer soFar ->
                let
                    implementation : Elm.Syntax.Expression.FunctionImplementation
                    implementation =
                        valueOrFunctionDeclarationToInfer.declaration
                            |> Elm.Syntax.Node.value

                    name : String
                    name =
                        implementation.name |> Elm.Syntax.Node.value
                in
                Result.andThen
                    (\parametersInferred ->
                        let
                            maybeDocumentationAndRange : Maybe { range : Elm.Syntax.Range.Range, content : String }
                            maybeDocumentationAndRange =
                                case valueOrFunctionDeclarationToInfer.documentation of
                                    Nothing ->
                                        Nothing

                                    Just (Elm.Syntax.Node.Node documentationRange documentationContent) ->
                                        Just
                                            { range = documentationRange
                                            , content = documentationContent
                                            }
                        in
                        case valueOrFunctionDeclarationToInfer.signature of
                            Nothing ->
                                let
                                    fullTypeVariable : TypeVariableFromContext
                                    fullTypeVariable =
                                        ( [ name ], name )
                                in
                                Result.andThen
                                    (\resultInferred ->
                                        Result.map
                                            (\soFarAndArgumentAndResultAndTypeUnifySubstitutions ->
                                                { substitutions =
                                                    soFarAndArgumentAndResultAndTypeUnifySubstitutions
                                                , declarations =
                                                    soFar.declarations
                                                        |> FastDict.insert name
                                                            { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                            , documentation = maybeDocumentationAndRange
                                                            , signature = Nothing
                                                            , result = resultInferred.node
                                                            , type_ = TypeVariable fullTypeVariable
                                                            , parameters = parametersInferred.nodes
                                                            }
                                                }
                                            )
                                            (variableSubstitutionsMerge3 declarationTypes
                                                soFar.substitutions
                                                resultInferred.substitutions
                                                (variableSubstitutionsFromVariableToType
                                                    fullTypeVariable
                                                    (parametersInferred.nodes
                                                        |> List.foldr
                                                            (\parameterTypedNode typeSoFar ->
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input = parameterTypedNode.type_
                                                                        , output = typeSoFar
                                                                        }
                                                                    )
                                                            )
                                                            resultInferred.node.type_
                                                    )
                                                )
                                            )
                                    )
                                    (implementation.expression
                                        |> expressionTypeInfer
                                            { declarationTypes = declarationTypes
                                            , locallyIntroducedExpressionVariables =
                                                -- elm declarations do not allow "polymorphic recursion"
                                                -- https://github.com/elm/compiler/issues/2275
                                                -- so instead of putting it in partiallyInferredDeclarationTypes
                                                -- we treat it as an introduced variable (sharing the same type variables)
                                                parametersInferred.introducedExpressionVariables
                                                    |> FastDict.insert name (TypeVariable fullTypeVariable)
                                            , locallyIntroducedDeclarationTypes =
                                                acrossValueAndFunctionDeclarationsToInfer.partiallyInferredDeclarationTypes
                                                    |> FastDict.remove name
                                            , containingDeclarationName = name
                                            , path = [ "declarationResult", name ]
                                            , moduleOriginLookup = moduleOriginLookup
                                            }
                                    )

                            Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                Result.andThen
                                    (\resultInferred ->
                                        let
                                            inferredFullType : Type TypeVariableFromContext
                                            inferredFullType =
                                                parametersInferred.nodes
                                                    |> List.foldr
                                                        (\parameterTypedNode typeSoFar ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = parameterTypedNode.type_
                                                                    , output = typeSoFar
                                                                    }
                                                                )
                                                        )
                                                        resultInferred.node.type_

                                            fullType : Type TypeVariableFromContext
                                            fullType =
                                                case
                                                    acrossValueAndFunctionDeclarationsToInfer.annotated
                                                        |> FastDict.get name
                                                of
                                                    Just annotationType ->
                                                        annotationType
                                                            |> typeMapVariables
                                                                (\variable -> ( [ name ], variable ))

                                                    Nothing ->
                                                        inferredFullType
                                        in
                                        Result.andThen
                                            (\fullSubstitutionsInDeclaration ->
                                                { substitutions = variableSubstitutionsNone
                                                , introducedTypeVariables =
                                                    FastSet.union
                                                        resultInferred.introducedTypeVariables
                                                        (parametersInferred.nodes
                                                            |> listMapToFastSetsAndUnify
                                                                patternTypedNodeContainedTypeVariables
                                                        )
                                                }
                                                    |> typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
                                                        { declarationTypes = declarationTypes
                                                        , nodeApplyVariableSubstitutions =
                                                            \substitutionsToApply ->
                                                                Result.map3
                                                                    (\typeSubstituted resultSubstituted parametersSubstituted ->
                                                                        { result = resultSubstituted
                                                                        , type_ = typeSubstituted
                                                                        , parameters = parametersSubstituted
                                                                        }
                                                                    )
                                                                    (fullType
                                                                        |> typeApplyVariableSubstitutions declarationTypes
                                                                            substitutionsToApply
                                                                    )
                                                                    (resultInferred.node
                                                                        |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                                            substitutionsToApply
                                                                    )
                                                                    (parametersInferred.nodes
                                                                        |> listFoldrWhileOkFrom []
                                                                            (\parameterInferred parametersSubstitutedSoFar ->
                                                                                Result.map
                                                                                    (\parameterSubstituted ->
                                                                                        parameterSubstituted :: parametersSubstitutedSoFar
                                                                                    )
                                                                                    (parameterInferred
                                                                                        |> patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                                                            substitutionsToApply
                                                                                    )
                                                                            )
                                                                    )
                                                        }
                                                        fullSubstitutionsInDeclaration
                                                    |> Result.andThen
                                                        (\substituted ->
                                                            Result.map
                                                                (\substitutionsSoFarWithCurrentDeclaration ->
                                                                    { substitutions = substitutionsSoFarWithCurrentDeclaration
                                                                    , declarations =
                                                                        soFar.declarations
                                                                            |> FastDict.insert name
                                                                                { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                                , documentation = maybeDocumentationAndRange
                                                                                , signature =
                                                                                    Just
                                                                                        { range = signatureRange
                                                                                        , nameRange = signature.name |> Elm.Syntax.Node.range
                                                                                        , annotationType = signature.typeAnnotation |> Elm.Syntax.Node.value
                                                                                        , annotationTypeRange = signature.typeAnnotation |> Elm.Syntax.Node.range
                                                                                        }
                                                                                , result = substituted.node.result
                                                                                , type_ = substituted.node.type_
                                                                                , parameters = substituted.node.parameters
                                                                                }
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    soFar.substitutions
                                                                    substituted.substitutions
                                                                )
                                                        )
                                            )
                                            (Result.andThen
                                                (\annotationUnifiedWithInferred ->
                                                    variableSubstitutionsMerge declarationTypes
                                                        annotationUnifiedWithInferred.substitutions
                                                        resultInferred.substitutions
                                                )
                                                (typeUnify declarationTypes
                                                    fullType
                                                    inferredFullType
                                                )
                                            )
                                    )
                                    (implementation.expression
                                        |> expressionTypeInfer
                                            { declarationTypes = declarationTypes
                                            , locallyIntroducedExpressionVariables =
                                                parametersInferred.nodes
                                                    |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                            , locallyIntroducedDeclarationTypes =
                                                acrossValueAndFunctionDeclarationsToInfer.partiallyInferredDeclarationTypes
                                            , containingDeclarationName = name
                                            , path = [ "declarationResult", name ]
                                            , moduleOriginLookup = moduleOriginLookup
                                            }
                                    )
                    )
                    (implementation.arguments
                        |> parameterPatternsTypeInfer
                            { declarationTypes = declarationTypes
                            , path = [ name ]
                            , moduleOriginLookup = moduleOriginLookup
                            }
                    )
                    |> Result.mapError
                        (\inferError ->
                            "inferring the value/function declaration "
                                ++ name
                                ++ ", I found a problem: "
                                ++ inferError
                        )
            )
        |> Result.andThen
            (\intermediate ->
                intermediate.declarations
                    |> valueAndFunctionDeclarationsApplySubstitutions
                        { declarationTypes = declarationTypes
                        , substitutions = intermediate.substitutions
                        }
            )
        |> Result.map
            (\fullySubstitutedDeclarationsTypedWithContext ->
                fullySubstitutedDeclarationsTypedWithContext
                    |> FastDict.map
                        (\_ declaration ->
                            declaration |> declarationValueOrFunctionInfoDisambiguateTypeVariables
                        )
            )


partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty :
    { partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , annotated : FastDict.Dict String (Type String)
    }
partiallyInferredDeclarationTypesEmptyAndAnnotatedEmpty =
    { partiallyInferredDeclarationTypes = FastDict.empty
    , annotated = FastDict.empty
    }


moduleTypesSetLocalTypesToOrigin : Elm.Syntax.ModuleName.ModuleName -> ModuleTypes -> ModuleTypes
moduleTypesSetLocalTypesToOrigin moduleOrigin moduleTypes =
    { signatures =
        moduleTypes.signatures
            |> FastDict.map
                (\_ type_ ->
                    type_ |> typeSetLocalToOrigin moduleOrigin
                )
    , typeAliases =
        moduleTypes.typeAliases
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , recordFieldOrder = typeAlias.recordFieldOrder
                    , type_ =
                        typeAlias.type_
                            |> typeSetLocalToOrigin moduleOrigin
                    }
                )
    , choiceTypes =
        moduleTypes.choiceTypes
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , variants =
                        typeAlias.variants
                            |> FastDict.map
                                (\_ values ->
                                    values
                                        |> List.map
                                            (\type_ ->
                                                type_ |> typeSetLocalToOrigin moduleOrigin
                                            )
                                )
                    }
                )
    }


typeSetLocalToOrigin : Elm.Syntax.ModuleName.ModuleName -> Type variable -> Type variable
typeSetLocalToOrigin moduleOrigin type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariable variable

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariableSetLocalToOrigin moduleOrigin typeNotVariable)


typeNotVariableSetLocalToOrigin :
    Elm.Syntax.ModuleName.ModuleName
    -> TypeNotVariable variable
    -> TypeNotVariable variable
typeNotVariableSetLocalToOrigin moduleOrigin typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            TypeConstruct
                { name = typeConstruct.name
                , moduleOrigin =
                    case typeConstruct.moduleOrigin of
                        [] ->
                            moduleOrigin

                        moduleOriginPart0 :: moduleOriginPart1Up ->
                            moduleOriginPart0 :: moduleOriginPart1Up
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }

        TypeUnit ->
            TypeUnit

        TypeFunction parts ->
            TypeFunction
                { input =
                    parts.input
                        |> typeSetLocalToOrigin moduleOrigin
                , output =
                    parts.output
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTuple parts ->
            TypeTuple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTriple parts ->
            TypeTriple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                , part2 =
                    parts.part2
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeRecord fields ->
            TypeRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue
                                |> typeSetLocalToOrigin moduleOrigin
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable = typeRecordExtension.recordVariable
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }


variableSubstitutionsFromVariableToType :
    TypeVariableFromContext
    -> Type TypeVariableFromContext
    -> VariableSubstitutions
variableSubstitutionsFromVariableToType variableToReplace replacementType =
    case replacementType of
        TypeNotVariable replacementTypeNotVariable ->
            { variableToType =
                FastDict.singleton variableToReplace
                    replacementTypeNotVariable
            , equivalentVariables = []
            }

        TypeVariable replacementVariable ->
            if variableToReplace == replacementVariable then
                variableSubstitutionsNone

            else
                { variableToType = FastDict.empty
                , equivalentVariables =
                    [ FastSet.singleton variableToReplace
                        |> FastSet.insert replacementVariable
                    ]
                }


type alias ValueOrFunctionDeclarationInfo type_ =
    { nameRange : Elm.Syntax.Range.Range
    , documentation :
        Maybe
            { content : String
            , range : Elm.Syntax.Range.Range
            }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , -- variables names in here might not correspond
              -- with those in .type_
              annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters :
        List (TypedNode (Pattern type_) type_)
    , result : TypedNode (Expression type_) type_
    , type_ : type_
    }


type alias ModuleLevelDeclarationTypesAvailableInModule =
    FastDict.Dict
        -- `[]` means declared in the same module
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes


declarationValueOrFunctionInfoDisambiguateTypeVariables :
    ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    -> ValueOrFunctionDeclarationInfo (Type String)
declarationValueOrFunctionInfoDisambiguateTypeVariables declarationValueOrFunctionInfo =
    let
        globalTypeVariableDisambiguationLookup : FastDict.Dict TypeVariableFromContext String
        globalTypeVariableDisambiguationLookup =
            typeVariablesFromContextToDisambiguationLookup
                (declarationValueOrFunctionInfo
                    |> valueOrFunctionDeclarationInfoContainedTypeVariables
                )
    in
    declarationValueOrFunctionInfo
        |> declarationValueOrFunctionInfoMapTypeVariables
            (\variable ->
                globalTypeVariableDisambiguationLookup
                    |> FastDict.get variable
                    |> Maybe.withDefault
                        "thisIsABugInDisambiguationPleaseReportToElmSyntaxTypeInfer"
            )


valueOrFunctionDeclarationInfoContainedTypeVariables :
    ValueOrFunctionDeclarationInfo (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
valueOrFunctionDeclarationInfoContainedTypeVariables declarationValueOrFunction =
    FastSet.union
        (declarationValueOrFunction.parameters
            |> listMapToFastSetsAndUnify
                patternTypedNodeContainedTypeVariables
        )
        (FastSet.union
            (declarationValueOrFunction.type_
                |> typeContainedVariables
            )
            (declarationValueOrFunction.result
                |> expressionTypedNodeContainedTypeVariables
            )
        )


patternTypedNodeContainedTypeVariables :
    TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
patternTypedNodeContainedTypeVariables patternTypedNode =
    FastSet.union
        (patternTypedNode.type_
            |> typeContainedVariables
        )
        (patternTypedNode.value
            |> patternContainedTypeVariables
        )


patternContainedTypeVariables :
    Pattern (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
patternContainedTypeVariables pattern =
    case pattern of
        PatternIgnored ->
            FastSet.empty

        PatternUnit ->
            FastSet.empty

        PatternChar _ ->
            FastSet.empty

        PatternString _ ->
            FastSet.empty

        PatternInt _ ->
            FastSet.empty

        PatternVariable _ ->
            FastSet.empty

        PatternParenthesized inParens ->
            patternTypedNodeContainedTypeVariables
                inParens

        PatternAs patternAs ->
            FastSet.union
                (patternAs.variable.type_
                    |> typeContainedVariables
                )
                (patternAs.pattern
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTuple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTriple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (parts.part1
                        |> patternTypedNodeContainedTypeVariables
                    )
                    (parts.part2
                        |> patternTypedNodeContainedTypeVariables
                    )
                )

        PatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head
                    |> patternTypedNodeContainedTypeVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternListExact elements ->
            elements
                |> listMapToFastSetsAndUnify
                    (\element ->
                        element
                            |> patternTypedNodeContainedTypeVariables
                    )

        PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastSetsAndUnify
                    (\value ->
                        value
                            |> patternTypedNodeContainedTypeVariables
                    )

        PatternRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\fieldTypedNode ->
                        fieldTypedNode.type_
                            |> typeContainedVariables
                    )


listMapToFastSetsAndUnify : (a -> FastSet.Set comparable) -> List a -> FastSet.Set comparable
listMapToFastSetsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


listMapToFastDictsAndUnify :
    (a -> FastDict.Dict comparable value)
    -> List a
    -> FastDict.Dict comparable value
listMapToFastDictsAndUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastDict.union
                    (element |> elementToSet)
                    soFar
            )
            FastDict.empty


expressionTypedNodeContainedTypeVariables :
    TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
expressionTypedNodeContainedTypeVariables expressionTypedNode =
    FastSet.union
        (expressionTypedNode.type_
            |> typeContainedVariables
        )
        (expressionTypedNode.value
            |> expressionContainedTypeVariables
        )


expressionContainedTypeVariables :
    Expression (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
expressionContainedTypeVariables expression =
    case expression of
        ExpressionUnit ->
            FastSet.empty

        ExpressionInteger _ ->
            FastSet.empty

        ExpressionFloat _ ->
            FastSet.empty

        ExpressionString _ ->
            FastSet.empty

        ExpressionChar _ ->
            FastSet.empty

        ExpressionReference _ ->
            FastSet.empty

        ExpressionOperatorFunction _ ->
            FastSet.empty

        ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ExpressionNegation negated ->
            expressionTypedNodeContainedTypeVariables
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeContainedTypeVariables
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeContainedTypeVariables
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            FastSet.union
                (expressionInfixOperation.left
                    |> expressionTypedNodeContainedTypeVariables
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTuple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTriple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (parts.part1
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (parts.part2
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionIfThenElse expressionIfThenElse ->
            FastSet.union
                (expressionIfThenElse.condition
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    (\element ->
                        element
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionCall expressionCall ->
            FastSet.union
                (expressionCall.called
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionCall.argument0
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionCall.argument1Up
                        |> listMapToFastSetsAndUnify
                            (\argument ->
                                argument
                                    |> expressionTypedNodeContainedTypeVariables
                            )
                    )
                )

        ExpressionLambda expressionLambda ->
            FastSet.union
                (expressionLambda.parameter0
                    |> patternTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionLambda.parameter1Up
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (expressionLambda.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.union
                (expressionRecordUpdate.recordVariable.type_
                    |> typeContainedVariables
                )
                (FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionRecordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> expressionTypedNodeContainedTypeVariables
                            )
                    )
                )

        ExpressionCaseOf expressionCaseOf ->
            FastSet.union
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionCaseOf.case0
                        |> expressionCaseOfCaseContainedTypeVariables
                    )
                    (expressionCaseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            expressionCaseOfCaseContainedTypeVariables
                    )
                )

        ExpressionLetIn expressionLetIn ->
            FastSet.union
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationContainedTypeVariables
                )
                (FastSet.union
                    (expressionLetIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclaration ->
                                letDeclaration.declaration
                                    |> letDeclarationContainedTypeVariables
                            )
                    )
                    (expressionLetIn.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )


letDeclarationContainedTypeVariables :
    LetDeclaration (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
letDeclarationContainedTypeVariables letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            FastSet.union
                (letDestructuring.pattern
                    |> patternTypedNodeContainedTypeVariables
                )
                (letDestructuring.expression
                    |> expressionTypedNodeContainedTypeVariables
                )

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            FastSet.union
                (letValueOrFunctionDeclaration.type_
                    |> typeContainedVariables
                )
                (FastSet.union
                    (letValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (letValueOrFunctionDeclaration.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )


expressionCaseOfCaseContainedTypeVariables :
    { pattern : TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    , result : TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    }
    -> FastSet.Set comparableTypeVariable
expressionCaseOfCaseContainedTypeVariables syntaxCase =
    FastSet.union
        (syntaxCase.pattern
            |> patternTypedNodeContainedTypeVariables
        )
        (syntaxCase.result
            |> expressionTypedNodeContainedTypeVariables
        )


createEquivalentVariablesToCondensedVariableLookup :
    List (FastSet.Set TypeVariableFromContext)
    -> Result String (FastDict.Dict TypeVariableFromContext TypeVariableFromContext)
createEquivalentVariablesToCondensedVariableLookup equivalentVariables =
    equivalentVariables
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\equivalentVariableSet soFar ->
                Result.map
                    (\unifiedVariable ->
                        equivalentVariableSet
                            |> FastSet.foldl
                                (\variable soFarInSet ->
                                    soFarInSet
                                        |> FastDict.insert variable unifiedVariable
                                )
                                soFar
                    )
                    (equivalentVariablesCreateCondensedVariable equivalentVariableSet)
            )


valueAndFunctionDeclarationsGetPartiallyInferred :
    FastDict.Dict
        String
        (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        FastDict.Dict
            String
            { nameRange : Elm.Syntax.Range.Range
            , type_ : Type TypeVariableFromContext
            }
valueAndFunctionDeclarationsGetPartiallyInferred valueAndFunctionDeclarationsSoFar =
    valueAndFunctionDeclarationsSoFar
        |> FastDict.foldl
            (\name declarationValueOrFunction moduleLevelPartiallyInferredDeclarationsSoFar ->
                case declarationValueOrFunction.signature of
                    Just _ ->
                        moduleLevelPartiallyInferredDeclarationsSoFar

                    Nothing ->
                        moduleLevelPartiallyInferredDeclarationsSoFar
                            |> FastDict.insert name
                                { nameRange = declarationValueOrFunction.nameRange
                                , type_ = declarationValueOrFunction.type_
                                }
            )
            FastDict.empty


valueAndFunctionDeclarationsApplySubstitutions :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , substitutions : VariableSubstitutions
    }
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            (FastDict.Dict
                String
                (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            )
valueAndFunctionDeclarationsApplySubstitutions state valueAndFunctionDeclarationsSoFar =
    let
        moduleLevelPartiallyInferredDeclarations :
            FastDict.Dict
                String
                { nameRange : Elm.Syntax.Range.Range
                , type_ : Type TypeVariableFromContext
                }
        moduleLevelPartiallyInferredDeclarations =
            valueAndFunctionDeclarationsSoFar
                |> valueAndFunctionDeclarationsGetPartiallyInferred
    in
    case state.substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case equivalentVariablesCreateCondensedVariable equivalentVariableSet0 of
                Err error ->
                    Err error

                Ok condensedVariable ->
                    let
                        allPartiallyInferredDeclarationsAndUsesBeforeSubstitution :
                            FastDict.Dict
                                ( RangeAsComparable, String )
                                { partiallyInferredDeclarationType : Type TypeVariableFromContext
                                , uses :
                                    List
                                        { type_ : Type TypeVariableFromContext
                                        , range : Elm.Syntax.Range.Range
                                        }
                                }
                        allPartiallyInferredDeclarationsAndUsesBeforeSubstitution =
                            valueAndFunctionDeclarationsSoFar
                                |> FastDict.foldl
                                    (\_ declarationValueOrFunction usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                        usesOfPartiallyInferredDeclarationsMerge
                                            usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                            (declarationValueOrFunction.result
                                                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                    { partiallyInferredDeclarations =
                                                        moduleLevelPartiallyInferredDeclarations
                                                    }
                                            )
                                    )
                                    FastDict.empty

                        variableToCondensedIfNecessary : TypeVariableFromContext -> TypeVariableFromContext
                        variableToCondensedIfNecessary variable =
                            if equivalentVariableSet0 |> FastSet.member variable then
                                condensedVariable

                            else
                                variable

                        valueAndFunctionDeclarationsCondensed :
                            FastDict.Dict
                                String
                                (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
                        valueAndFunctionDeclarationsCondensed =
                            valueAndFunctionDeclarationsSoFar
                                |> FastDict.map
                                    (\_ declarationValueOrFunctionToCondenseVariablesIn ->
                                        declarationValueOrFunctionToCondenseVariablesIn
                                            |> declarationValueOrFunctionInfoMapTypeVariables
                                                variableToCondensedIfNecessary
                                    )

                        moduleLevelPartiallyInferredDeclarationsCondensed :
                            FastDict.Dict
                                String
                                { nameRange : Elm.Syntax.Range.Range
                                , type_ : Type TypeVariableFromContext
                                }
                        moduleLevelPartiallyInferredDeclarationsCondensed =
                            valueAndFunctionDeclarationsCondensed
                                |> valueAndFunctionDeclarationsGetPartiallyInferred

                        allPartiallyInferredDeclarationsAndUsesCondensed :
                            FastDict.Dict
                                ( RangeAsComparable, String )
                                { partiallyInferredDeclarationType : Type TypeVariableFromContext
                                , uses :
                                    List
                                        { type_ : Type TypeVariableFromContext
                                        , range : Elm.Syntax.Range.Range
                                        }
                                }
                        allPartiallyInferredDeclarationsAndUsesCondensed =
                            valueAndFunctionDeclarationsCondensed
                                |> FastDict.foldl
                                    (\_ declarationValueOrFunction usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                        usesOfPartiallyInferredDeclarationsMerge
                                            usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                            (declarationValueOrFunction.result
                                                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                    { partiallyInferredDeclarations =
                                                        moduleLevelPartiallyInferredDeclarationsCondensed
                                                    }
                                            )
                                    )
                                    FastDict.empty

                        partialTypeVariablesAmongEquivalentVariablesThatGotMoreStrictByCondensing :
                            List
                                { uses :
                                    List
                                        { type_ : Type TypeVariableFromContext
                                        , range : Elm.Syntax.Range.Range
                                        }
                                , partiallyInferredDeclarationType : Type TypeVariableFromContext
                                }
                        partialTypeVariablesAmongEquivalentVariablesThatGotMoreStrictByCondensing =
                            allPartiallyInferredDeclarationsAndUsesCondensed
                                |> FastDict.foldl
                                    (\partiallyInferredDeclarationId info partialTypeVariableAmongEquivalentVariablesSoFar ->
                                        let
                                            partiallyInferredDeclarationTypeContainedVariables : FastSet.Set TypeVariableFromContext
                                            partiallyInferredDeclarationTypeContainedVariables =
                                                info.partiallyInferredDeclarationType
                                                    |> typeContainedVariables
                                        in
                                        if
                                            partiallyInferredDeclarationTypeContainedVariables
                                                |> FastSet.member condensedVariable
                                        then
                                            -- if we don't check whether the condensed type
                                            -- is _actually_ more strict, we could end up in an endless loop
                                            -- if partially declared types cross-influence each other.
                                            -- How do we check it's gotten more strict?
                                            --   - each variable has at most one corresponding condensed variable
                                            --     so if we have less condensed variables, the type is more limited
                                            --   - also, if any condensed variable has more constraints,
                                            --     the type is also more limited
                                            case
                                                allPartiallyInferredDeclarationsAndUsesBeforeSubstitution
                                                    |> FastDict.get partiallyInferredDeclarationId
                                            of
                                                Just infoBeforeSubstitution ->
                                                    let
                                                        partiallyInferredDeclarationBeforeSubstitutionTypeContainedVariables : FastSet.Set TypeVariableFromContext
                                                        partiallyInferredDeclarationBeforeSubstitutionTypeContainedVariables =
                                                            infoBeforeSubstitution.partiallyInferredDeclarationType
                                                                |> typeContainedVariables
                                                    in
                                                    if
                                                        (partiallyInferredDeclarationBeforeSubstitutionTypeContainedVariables
                                                            |> FastSet.size
                                                        )
                                                            == (partiallyInferredDeclarationTypeContainedVariables
                                                                    |> FastSet.size
                                                               )
                                                            && ((partiallyInferredDeclarationBeforeSubstitutionTypeContainedVariables
                                                                    |> fastSetToListHighestToLowestAndMap
                                                                        (\( _, variableBeforeSubstitution ) ->
                                                                            variableBeforeSubstitution
                                                                                |> typeVariableConstraint
                                                                                |> maybeTypeVariableConstraintToString
                                                                        )
                                                                    |> List.sort
                                                                )
                                                                    == (partiallyInferredDeclarationTypeContainedVariables
                                                                            |> fastSetToListHighestToLowestAndMap
                                                                                (\( _, variableBeforeSubstitution ) ->
                                                                                    variableBeforeSubstitution
                                                                                        |> typeVariableConstraint
                                                                                        |> maybeTypeVariableConstraintToString
                                                                                )
                                                                            |> List.sort
                                                                       )
                                                               )
                                                    then
                                                        partialTypeVariableAmongEquivalentVariablesSoFar

                                                    else
                                                        info :: partialTypeVariableAmongEquivalentVariablesSoFar

                                                Nothing ->
                                                    partialTypeVariableAmongEquivalentVariablesSoFar

                                        else
                                            partialTypeVariableAmongEquivalentVariablesSoFar
                                    )
                                    []

                        variableCondenseLookup : FastDict.Dict TypeVariableFromContext TypeVariableFromContext
                        variableCondenseLookup =
                            equivalentVariableSet0
                                |> FastSet.foldl
                                    (\variable soFarInSet ->
                                        soFarInSet
                                            |> FastDict.insert variable condensedVariable
                                    )
                                    FastDict.empty

                        newSubstitutionsOrError : Result String VariableSubstitutions
                        newSubstitutionsOrError =
                            partialTypeVariablesAmongEquivalentVariablesThatGotMoreStrictByCondensing
                                |> listFoldlWhileOkFromResult
                                    (Result.map
                                        (\variableSubstitutionsCondensed ->
                                            { equivalentVariables =
                                                equivalentVariableSetMerge
                                                    variableSubstitutionsCondensed.equivalentVariables
                                                    equivalentVariableSet1Up
                                            , variableToType =
                                                variableSubstitutionsCondensed.variableToType
                                            }
                                        )
                                        (state.substitutions.variableToType
                                            |> variableToTypeSubstitutionsCondenseVariables
                                                state.declarationTypes
                                                variableCondenseLookup
                                        )
                                    )
                                    (\partialTypeVariableAmongEquivalentVariables substitutionsWithPartialUsesUpdatedSoFar ->
                                        partialTypeVariableAmongEquivalentVariables.uses
                                            |> listFoldlWhileOkFrom
                                                substitutionsWithPartialUsesUpdatedSoFar
                                                (\use unificationSubstitutionsSoFar ->
                                                    let
                                                        usePathSegment : String
                                                        usePathSegment =
                                                            use.range |> rangeToInfoString

                                                        partialTypeNewInstance : Type TypeVariableFromContext
                                                        partialTypeNewInstance =
                                                            partialTypeVariableAmongEquivalentVariables.partiallyInferredDeclarationType
                                                                |> typeMapVariables
                                                                    (\( variableContext, variableName ) ->
                                                                        ( usePathSegment :: variableContext
                                                                        , variableName
                                                                        )
                                                                    )
                                                    in
                                                    Result.andThen
                                                        (\unified ->
                                                            variableSubstitutionsMerge state.declarationTypes
                                                                unificationSubstitutionsSoFar
                                                                -- TODO partialTypeNewInstance could
                                                                -- create accidental overlaps in the second
                                                                -- cycle. We should explicitly
                                                                -- check that for uses and disambiguate accordingly
                                                                -- (seems too complicated)
                                                                unified.substitutions
                                                        )
                                                        (typeUnify state.declarationTypes
                                                            partialTypeNewInstance
                                                            use.type_
                                                        )
                                                )
                                    )
                    in
                    case newSubstitutionsOrError of
                        Err error ->
                            Err error

                        Ok newSubstitutions ->
                            valueAndFunctionDeclarationsApplySubstitutions
                                { declarationTypes = state.declarationTypes
                                , substitutions = newSubstitutions
                                }
                                valueAndFunctionDeclarationsCondensed

        [] ->
            case state.substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok valueAndFunctionDeclarationsSoFar

                Just ( ( variableOfSubstitutionToApply, typeNotVariableOfSubstitutionToApply ), remainingVariableToType ) ->
                    let
                        substitutionToApply : { variable : TypeVariableFromContext, type_ : TypeNotVariable TypeVariableFromContext }
                        substitutionToApply =
                            { variable = variableOfSubstitutionToApply
                            , type_ = typeNotVariableOfSubstitutionToApply
                            }
                    in
                    case
                        valueAndFunctionDeclarationsSoFar
                            |> valueAndFunctionDeclarationsSubstituteVariableByNotVariable
                                state.declarationTypes
                                substitutionToApply
                    of
                        Err error ->
                            Err error

                        Ok valueAndFunctionDeclarationsSubstituted ->
                            case
                                remainingVariableToType
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable
                                        state.declarationTypes
                                        substitutionToApply
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeAndSubstitutions ->
                                    let
                                        allPartiallyInferredDeclarationsAndUsesBeforeSubstitution :
                                            FastDict.Dict
                                                ( RangeAsComparable, String )
                                                { partiallyInferredDeclarationType : Type TypeVariableFromContext
                                                , uses :
                                                    List
                                                        { type_ : Type TypeVariableFromContext
                                                        , range : Elm.Syntax.Range.Range
                                                        }
                                                }
                                        allPartiallyInferredDeclarationsAndUsesBeforeSubstitution =
                                            valueAndFunctionDeclarationsSoFar
                                                |> FastDict.foldl
                                                    (\_ declarationValueOrFunction usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                                        usesOfPartiallyInferredDeclarationsMerge
                                                            usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                                            (declarationValueOrFunction.result
                                                                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                                    { partiallyInferredDeclarations = moduleLevelPartiallyInferredDeclarations }
                                                            )
                                                    )
                                                    FastDict.empty

                                        moduleLevelPartiallyInferredSubstitutedDeclarations :
                                            FastDict.Dict
                                                String
                                                { nameRange : Elm.Syntax.Range.Range
                                                , type_ : Type TypeVariableFromContext
                                                }
                                        moduleLevelPartiallyInferredSubstitutedDeclarations =
                                            valueAndFunctionDeclarationsSubstituted.declarations
                                                |> valueAndFunctionDeclarationsGetPartiallyInferred

                                        allPartiallyInferredDeclarationsAndUsesAfterSubstitution :
                                            FastDict.Dict
                                                ( RangeAsComparable, String )
                                                { partiallyInferredDeclarationType : Type TypeVariableFromContext
                                                , uses :
                                                    List
                                                        { type_ : Type TypeVariableFromContext
                                                        , range : Elm.Syntax.Range.Range
                                                        }
                                                }
                                        allPartiallyInferredDeclarationsAndUsesAfterSubstitution =
                                            valueAndFunctionDeclarationsSubstituted.declarations
                                                |> FastDict.foldl
                                                    (\_ declarationValueOrFunction usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                                        usesOfPartiallyInferredDeclarationsMerge
                                                            usesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                                            (declarationValueOrFunction.result
                                                                |> expressionTypedNodeUsesOfPartiallyInferredDeclarations
                                                                    { partiallyInferredDeclarations =
                                                                        moduleLevelPartiallyInferredSubstitutedDeclarations
                                                                    }
                                                            )
                                                    )
                                                    FastDict.empty

                                        maybeSubstitutionOfPartiallyInferredDeclaration :
                                            Maybe
                                                { uses :
                                                    List
                                                        { type_ : Type TypeVariableFromContext
                                                        , range : Elm.Syntax.Range.Range
                                                        }
                                                , partiallyInferredDeclarationType : Type TypeVariableFromContext
                                                }
                                        maybeSubstitutionOfPartiallyInferredDeclaration =
                                            -- TODO must be a list instead, substitution could cover multiple
                                            allPartiallyInferredDeclarationsAndUsesAfterSubstitution
                                                |> fastDictMapAndSmallestJust
                                                    (\partiallyInferredDeclarationId info ->
                                                        case
                                                            allPartiallyInferredDeclarationsAndUsesBeforeSubstitution
                                                                |> FastDict.get partiallyInferredDeclarationId
                                                        of
                                                            Nothing ->
                                                                Nothing

                                                            Just infoBeforeSubstitution ->
                                                                if
                                                                    info.partiallyInferredDeclarationType
                                                                        /= infoBeforeSubstitution.partiallyInferredDeclarationType
                                                                then
                                                                    Just
                                                                        { uses = info.uses
                                                                        , partiallyInferredDeclarationType =
                                                                            info.partiallyInferredDeclarationType
                                                                        }

                                                                else
                                                                    Nothing
                                                    )
                                    in
                                    case maybeSubstitutionOfPartiallyInferredDeclaration of
                                        Nothing ->
                                            case
                                                variableSubstitutionsMerge3
                                                    state.declarationTypes
                                                    variableSubstitutionsNone
                                                    valueAndFunctionDeclarationsSubstituted.substitutions
                                                    remainingVariableToTypeAndSubstitutions
                                            of
                                                Err error ->
                                                    Err error

                                                Ok substitutionsAfterSubstitution ->
                                                    valueAndFunctionDeclarationsApplySubstitutions
                                                        { declarationTypes = state.declarationTypes
                                                        , substitutions = substitutionsAfterSubstitution
                                                        }
                                                        valueAndFunctionDeclarationsSubstituted.declarations

                                        Just substitutionOfPartiallyInferredDeclaration ->
                                            let
                                                updatePartiallyInferredSubstitutionsOrError : Result String VariableSubstitutions
                                                updatePartiallyInferredSubstitutionsOrError =
                                                    substitutionOfPartiallyInferredDeclaration.uses
                                                        |> listFoldlWhileOkFrom variableSubstitutionsNone
                                                            (\use unificationSubstitutionsSoFar ->
                                                                let
                                                                    usePathSegment : String
                                                                    usePathSegment =
                                                                        use.range |> rangeToInfoString

                                                                    partialTypeNewInstance : Type TypeVariableFromContext
                                                                    partialTypeNewInstance =
                                                                        substitutionOfPartiallyInferredDeclaration.partiallyInferredDeclarationType
                                                                            |> typeMapVariables
                                                                                (\( variableContext, variableName ) ->
                                                                                    ( usePathSegment :: variableContext
                                                                                    , variableName
                                                                                    )
                                                                                )
                                                                in
                                                                Result.andThen
                                                                    (\unified ->
                                                                        variableSubstitutionsMerge state.declarationTypes
                                                                            unificationSubstitutionsSoFar
                                                                            unified.substitutions
                                                                    )
                                                                    (typeUnify state.declarationTypes
                                                                        partialTypeNewInstance
                                                                        use.type_
                                                                    )
                                                            )
                                            in
                                            case updatePartiallyInferredSubstitutionsOrError of
                                                Err error ->
                                                    Err error

                                                Ok updatePartiallyInferredSubstitutions ->
                                                    case
                                                        variableSubstitutionsMerge3 state.declarationTypes
                                                            valueAndFunctionDeclarationsSubstituted.substitutions
                                                            updatePartiallyInferredSubstitutions
                                                            remainingVariableToTypeAndSubstitutions
                                                    of
                                                        Err error ->
                                                            Err error

                                                        Ok substitutionsAfterSubstitution ->
                                                            valueAndFunctionDeclarationsApplySubstitutions
                                                                { declarationTypes = state.declarationTypes
                                                                , substitutions = substitutionsAfterSubstitution
                                                                }
                                                                valueAndFunctionDeclarationsSubstituted.declarations


fastSetToListHighestToLowestAndMap : (comparable -> listElement) -> FastSet.Set comparable -> List listElement
fastSetToListHighestToLowestAndMap setElementToListElement fastSet =
    fastSet
        |> FastSet.foldl
            (\setElement soFar ->
                (setElement |> setElementToListElement) :: soFar
            )
            []


valueAndFunctionDeclarationsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            { declarations :
                FastDict.Dict
                    String
                    (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            , substitutions : VariableSubstitutions
            }
valueAndFunctionDeclarationsSubstituteVariableByNotVariable declarationTypes substitutionToApply valueAndFunctionDeclarationsToApplySubstitutionTo =
    valueAndFunctionDeclarationsToApplySubstitutionTo
        |> fastDictFoldlWhileOkFrom
            substitutionsNoneDeclarationsDictEmpty
            (\declarationName declarationToSubstituteIn soFar ->
                Result.andThen
                    (\declarationSubstituted ->
                        Result.map
                            (\fullSubstitutions ->
                                { substitutions = fullSubstitutions
                                , declarations =
                                    FastDict.insert declarationName
                                        declarationSubstituted.declaration
                                        soFar.declarations
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                declarationSubstituted.substitutions
                            )
                    )
                    (declarationToSubstituteIn
                        |> declarationValueOrFunctionInfoSubstituteVariableByNotVariable
                            declarationTypes
                            substitutionToApply
                    )
                    |> Result.mapError
                        (\substitutionError ->
                            "I inferred various parts of the value/function declaration "
                                ++ declarationName
                                ++ " but there was a problem after substituting pieces of knowledge: "
                                ++ substitutionError
                        )
            )


substitutionsNoneDeclarationsDictEmpty :
    { substitutions : VariableSubstitutions
    , declarations : FastDict.Dict String declarationInfo_
    }
substitutionsNoneDeclarationsDictEmpty =
    { substitutions = variableSubstitutionsNone
    , declarations = FastDict.empty
    }


variableToTypeSubstitutionsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes variableToTypeSubstitutionToApply variableToTypeSubstitutions =
    variableToTypeSubstitutions
        |> fastDictFoldlWhileOkFrom
            variableSubstitutionsNone
            (\remainingVariable remainingReplacementTypeNotVariable soFar ->
                Result.andThen
                    (\replacementTypeSubstituted ->
                        variableSubstitutionsMerge3 declarationTypes
                            replacementTypeSubstituted.substitutions
                            { equivalentVariables = []
                            , variableToType =
                                FastDict.singleton remainingVariable
                                    replacementTypeSubstituted.type_
                            }
                            soFar
                    )
                    (remainingReplacementTypeNotVariable
                        |> typeNotVariableSubstituteVariableByNotVariable
                            declarationTypes
                            variableToTypeSubstitutionToApply
                    )
            )


variableToTypeSubstitutionsCondenseVariables :
    ModuleLevelDeclarationTypesAvailableInModule
    -> FastDict.Dict TypeVariableFromContext TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsCondenseVariables declarationTypes variableToCondensedLookup variableToType =
    variableToType
        |> fastDictFoldlWhileOkFrom
            variableSubstitutionsNone
            (\uncondensedVariable replacementType soFar ->
                case variableToCondensedLookup |> FastDict.get uncondensedVariable of
                    Nothing ->
                        Ok
                            { equivalentVariables = soFar.equivalentVariables
                            , variableToType =
                                soFar.variableToType
                                    |> FastDict.insert uncondensedVariable
                                        (replacementType
                                            |> typeNotVariableMapVariables
                                                (\variable ->
                                                    variableToCondensedLookup
                                                        |> FastDict.get variable
                                                        |> Maybe.withDefault variable
                                                )
                                        )
                            }

                    Just condensedVariable ->
                        let
                            replacementTypeUsingCondensedVariables : TypeNotVariable TypeVariableFromContext
                            replacementTypeUsingCondensedVariables =
                                replacementType
                                    |> typeNotVariableMapVariables
                                        (\variable ->
                                            variableToCondensedLookup
                                                |> FastDict.get variable
                                                |> Maybe.withDefault variable
                                        )
                        in
                        case soFar.variableToType |> FastDict.get condensedVariable of
                            Nothing ->
                                Ok
                                    { equivalentVariables = soFar.equivalentVariables
                                    , variableToType =
                                        soFar.variableToType
                                            |> FastDict.insert condensedVariable
                                                replacementTypeUsingCondensedVariables
                                    }

                            Just existingReplacementTypeForCondensedVariable ->
                                Result.andThen
                                    (\replacementTypeForCondensedVariable ->
                                        variableSubstitutionsMerge3 declarationTypes
                                            soFar
                                            replacementTypeForCondensedVariable.substitutions
                                            (variableSubstitutionsFromVariableToType
                                                condensedVariable
                                                replacementTypeForCondensedVariable.type_
                                            )
                                    )
                                    (typeNotVariableUnify declarationTypes
                                        existingReplacementTypeForCondensedVariable
                                        replacementTypeUsingCondensedVariables
                                    )
            )


declarationValueOrFunctionInfoSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    ->
        Result
            String
            { declaration : ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
declarationValueOrFunctionInfoSubstituteVariableByNotVariable declarationTypes replacement declarationValueOrFunctionSoFar =
    if replacement.type_ |> typeNotVariableContainedVariables |> FastSet.member replacement.variable then
        if replacement.type_ |> typeNotVariableIsEquivalentToTypeVariable declarationTypes then
            -- is ok when type_ is an identity type alias
            Ok
                { declaration = declarationValueOrFunctionSoFar
                , substitutions = variableSubstitutionsNone
                }

        else
            Err
                ("cannot unify the variable "
                    ++ (replacement.variable |> typeVariableFromContextToName)
                    ++ " with the type "
                    ++ (replacement.type_ |> typeNotVariablePrintRoughly)
                    ++ " because that type contains the type variable itself."
                )

    else
        resultAndThen3
            (\parametersInferred resultInferred typeInferred ->
                Result.map
                    (\fullSubstitutions ->
                        { declaration =
                            { nameRange = declarationValueOrFunctionSoFar.nameRange
                            , documentation = declarationValueOrFunctionSoFar.documentation
                            , signature = declarationValueOrFunctionSoFar.signature
                            , parameters = parametersInferred.nodes
                            , result = resultInferred.node
                            , type_ =
                                -- reconstructing the function at the end is faster
                                typeInferred.type_
                            }
                        , substitutions = fullSubstitutions
                        }
                    )
                    (variableSubstitutionsMerge3 declarationTypes
                        parametersInferred.substitutions
                        resultInferred.substitutions
                        typeInferred.substitutions
                    )
            )
            (declarationValueOrFunctionSoFar.parameters
                |> listFoldrWhileOkFrom
                    substitutionsNoneNodesEmpty
                    (\patternTypedNode soFar ->
                        Result.andThen
                            (\patternSubstituted ->
                                Result.map
                                    (\fullSubstitutions ->
                                        { substitutions = fullSubstitutions
                                        , nodes =
                                            patternSubstituted.node
                                                :: soFar.nodes
                                        }
                                    )
                                    (variableSubstitutionsMerge declarationTypes
                                        patternSubstituted.substitutions
                                        soFar.substitutions
                                    )
                            )
                            (patternTypedNode
                                |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                    replacement
                            )
                    )
            )
            (declarationValueOrFunctionSoFar.result
                |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )
            (declarationValueOrFunctionSoFar.type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )


typeNotVariableIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable variable_
    -> Bool
typeNotVariableIsEquivalentToTypeVariable declarationTypes typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            case declarationTypes |> FastDict.get typeConstruct.moduleOrigin of
                Nothing ->
                    False

                Just originModule ->
                    case originModule.typeAliases |> FastDict.get typeConstruct.name of
                        Nothing ->
                            False

                        Just typeAlias ->
                            typeAlias.type_ |> typeIsEquivalentToTypeVariable declarationTypes

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type variable_
    -> Bool
typeIsEquivalentToTypeVariable declarationTypes type_ =
    case type_ of
        TypeVariable _ ->
            True

        TypeNotVariable typeNotVariable ->
            typeNotVariable
                |> typeNotVariableIsEquivalentToTypeVariable declarationTypes


typePrintRoughly : Type TypeVariableFromContext -> String
typePrintRoughly type_ =
    case type_ of
        TypeVariable variable ->
            variable |> typeVariableFromContextToName

        TypeNotVariable typeNotVariable ->
            typeNotVariablePrintRoughly typeNotVariable


typeNotVariablePrintRoughly : TypeNotVariable TypeVariableFromContext -> String
typeNotVariablePrintRoughly typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typePrintRoughly)
                ++ ") -> ("
                ++ (typeFunction.output |> typePrintRoughly)
                ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part2 |> typePrintRoughly)
                ++ " )"

        TypeConstruct typeConstruct ->
            (typeConstruct.moduleOrigin
                |> String.join "."
            )
                ++ "."
                ++ typeConstruct.name
                ++ " "
                ++ (typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                "(" ++ (argument |> typePrintRoughly) ++ ")"
                            )
                        |> String.join ", "
                   )

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension typeRecordExtension ->
            "{ "
                ++ (typeRecordExtension.recordVariable
                        |> typeVariableFromContextToName
                   )
                ++ " | "
                ++ (typeRecordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"


declarationValueOrFunctionInfoMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> ValueOrFunctionDeclarationInfo (Type typeVariable)
    -> ValueOrFunctionDeclarationInfo (Type changedTypeVariable)
declarationValueOrFunctionInfoMapTypeVariables variableChange declarationValueOrFunctionSoFar =
    { nameRange = declarationValueOrFunctionSoFar.nameRange
    , documentation = declarationValueOrFunctionSoFar.documentation
    , signature = declarationValueOrFunctionSoFar.signature
    , parameters =
        declarationValueOrFunctionSoFar.parameters
            |> List.map
                (\argument ->
                    argument |> patternTypedNodeMapTypeVariables variableChange
                )
    , result =
        declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeMapTypeVariables variableChange
    , type_ =
        -- TODO instead reconstruct the function
        declarationValueOrFunctionSoFar.type_
            |> typeMapVariables variableChange
    }


expressionTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionTypedNodeSubstituteVariableByNotVariable declarationTypes replacement expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionFloat _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionInteger integer ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionInteger integer
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionReference reference ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionReference reference
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionOperatorFunction symbol ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionOperatorFunction symbol
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionNegation negated ->
            Result.map
                (\negatedSubstituted ->
                    { substitutions = negatedSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionNegation negatedSubstituted.node
                        , type_ = negatedSubstituted.node.type_
                        }
                    }
                )
                (negated
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionParenthesized inParensSubstituted.node
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (inParens
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccess recordAccess ->
            resultAndThen2
                (\typeSubstituted recordSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionRecordAccess
                                        { fieldName = recordAccess.fieldName
                                        , fieldNameRange = recordAccess.fieldNameRange
                                        , record = recordSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            recordSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (recordAccess.record
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccessFunction field ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionRecordAccessFunction field
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionInfixOperation expressionInfixOperation ->
            resultAndThen4
                (\typeSubstituted operatorTypeSubstituted leftSubstituted rightSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionInfixOperation
                                        { operator =
                                            { symbol = expressionInfixOperation.operator.symbol
                                            , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                                            , type_ = operatorTypeSubstituted.type_
                                            }
                                        , left = leftSubstituted.node
                                        , right = rightSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            operatorTypeSubstituted.substitutions
                            leftSubstituted.substitutions
                            rightSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTuple expressionTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 = part0Substituted.node.type_
                                            , part1 = part1Substituted.node.type_
                                            }
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (expressionTuple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTuple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTriple expressionTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionTriple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        , part2 = part2Substituted.node
                                        }
                                , type_ =
                                    TypeNotVariable
                                        (TypeTriple
                                            { part0 = part0Substituted.node.type_
                                            , part1 = part1Substituted.node.type_
                                            , part2 = part2Substituted.node.type_
                                            }
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (expressionTriple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part2
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen3
                (\conditionSubstituted onTrueSubstituted onFalseSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionIfThenElse
                                        { condition = conditionSubstituted.node
                                        , onTrue = onTrueSubstituted.node
                                        , onFalse = onFalseSubstituted.node
                                        }
                                , type_ = onTrueSubstituted.node.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            conditionSubstituted.substitutions
                            onTrueSubstituted.substitutions
                            onFalseSubstituted.substitutions
                        )
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionList expressionListElements ->
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionList
                                        elementsSubstituted.nodes
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\elementNode soFar ->
                            Result.andThen
                                (\elementSubstituted ->
                                    Result.map
                                        (\substitutionsSoFarWithElement ->
                                            { substitutions = substitutionsSoFarWithElement
                                            , nodes =
                                                elementSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            elementSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionCall expressionCall ->
            resultAndThen4
                (\typeSubstituted calledSubstituted argument0Substituted argument1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionCall
                                        { called = calledSubstituted.node
                                        , argument0 = argument0Substituted.node
                                        , argument1Up = argument1UpSubstituted.nodes
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            calledSubstituted.substitutions
                            argument0Substituted.substitutions
                            argument1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.called
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                argumentSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecord expressionRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    { substitutions = fieldsSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value =
                            ExpressionRecord fieldsSubstituted.nodes
                        , type_ =
                            TypeNotVariable
                                (TypeRecord
                                    (fieldsSubstituted.nodes
                                        |> List.foldl
                                            (\fieldSubstituted soFar ->
                                                soFar
                                                    |> FastDict.insert fieldSubstituted.name
                                                        fieldSubstituted.value.type_
                                            )
                                            FastDict.empty
                                    )
                                )
                        }
                    }
                )
                (expressionRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            resultAndThen3
                (\typeSubstituted field0Substituted field1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionRecordUpdate
                                        { recordVariable =
                                            { value = expressionRecordUpdate.recordVariable.value
                                            , range = expressionRecordUpdate.recordVariable.range
                                            , type_ = typeSubstituted.type_
                                            }
                                        , field0 = field0Substituted.node
                                        , field1Up = field1UpSubstituted.nodes
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            field0Substituted.substitutions
                            field1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (Result.map
                    (\fieldValueSubstituted ->
                        { substitutions = fieldValueSubstituted.substitutions
                        , node =
                            { range = expressionRecordUpdate.field0.range
                            , name = expressionRecordUpdate.field0.name
                            , nameRange = expressionRecordUpdate.field0.nameRange
                            , value = fieldValueSubstituted.node
                            }
                        }
                    )
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLambda expressionLambda ->
            resultAndThen3
                (\parameter0Substituted parameter1UpSubstituted resultSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLambda
                                        { parameter0 = parameter0Substituted.node
                                        , parameter1Up = parameter1UpSubstituted.nodes
                                        , result = resultSubstituted.node
                                        }
                                , type_ =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input = parameter0Substituted.node.type_
                                            , output =
                                                parameter1UpSubstituted.nodes
                                                    |> List.foldr
                                                        (\argumentTypedNode output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentTypedNode.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        resultSubstituted.node.type_
                                            }
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            parameter0Substituted.substitutions
                            parameter1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                        )
                )
                (expressionLambda.parameter0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLambda.parameter1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\parameterNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsSoFarWithParameter ->
                                            { substitutions = substitutionsSoFarWithParameter
                                            , nodes =
                                                argumentSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLambda.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionCaseOf expressionCaseOf ->
            resultAndThen3
                (\matchedSubstituted case0Substituted case1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionCaseOf
                                        { case0 = case0Substituted.node
                                        , case1Up =
                                            case1UpSubstituted.nodes
                                        , matchedExpression = matchedSubstituted.node
                                        }
                                , type_ = case0Substituted.node.result.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            matchedSubstituted.substitutions
                            case0Substituted.substitutions
                            case1UpSubstituted.substitutions
                        )
                )
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (resultAndThen2
                    (\patternSubstituted resultSubstituted ->
                        Result.map
                            (\fullSubstitutions ->
                                { substitutions = fullSubstitutions
                                , node =
                                    { pattern = patternSubstituted.node
                                    , result = resultSubstituted.node
                                    }
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                patternSubstituted.substitutions
                                resultSubstituted.substitutions
                            )
                    )
                    (expressionCaseOf.case0.pattern
                        |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                    (expressionCaseOf.case0.result
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionCaseOf.case1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\case_ soFar ->
                            resultAndThen2
                                (\patternSubstituted resultSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                { pattern = patternSubstituted.node
                                                , result = resultSubstituted.node
                                                }
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            patternSubstituted.substitutions
                                            resultSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (case_.pattern
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                                (case_.result
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLetIn expressionLetIn ->
            resultAndThen3
                (\declaration0Substituted declaration1UpSubstituted resultSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLetIn
                                        { declaration0 =
                                            declaration0Substituted.node
                                        , declaration1Up = declaration1UpSubstituted.nodes
                                        , result = resultSubstituted.node
                                        }
                                , type_ = resultSubstituted.node.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            declaration0Substituted.substitutions
                            declaration1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                        )
                )
                (expressionLetIn.declaration0
                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLetIn.declaration1Up
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\letDeclarationNode soFar ->
                            Result.andThen
                                (\declarationSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                declarationSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            declarationSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (letDeclarationNode
                                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


letDeclarationSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : LetDeclaration (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , substitutions : VariableSubstitutions
            }
letDeclarationSubstituteVariableByNotVariable declarationTypes replacement letDeclarationAndRange =
    case letDeclarationAndRange.declaration of
        LetDestructuring letDestructuring ->
            resultAndThen2
                (\patternSubstituted expressionSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetDestructuring
                                        { pattern = patternSubstituted.node
                                        , expression = expressionSubstituted.node
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            patternSubstituted.substitutions
                            expressionSubstituted.substitutions
                        )
                )
                (letDestructuring.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letDestructuring.expression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            resultAndThen3
                (\argumentsSubstituted resultSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetValueOrFunctionDeclaration
                                        { parameters = argumentsSubstituted.nodes
                                        , result = resultSubstituted.node
                                        , type_ = typeSubstituted.type_
                                        , signature = letValueOrFunction.signature
                                        , nameRange = letValueOrFunction.nameRange
                                        , name = letValueOrFunction.name
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            argumentsSubstituted.substitutions
                            resultSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (letValueOrFunction.parameters
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodes =
                                                argumentSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letValueOrFunction.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


expressionTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Expression (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Expression (Type changedTypeVariable)) (Type changedTypeVariable)
expressionTypedNodeMapTypeVariables typeVariableChange expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


expressionTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Expression type_) type_
    -> TypedNode (Expression changedType) changedType
expressionTypedNodeMapTypes typeVariableChange expressionTypedNode =
    { range = expressionTypedNode.range
    , value =
        expressionTypedNode.value
            |> expressionMapTypes typeVariableChange
    , type_ =
        expressionTypedNode.type_
            |> typeVariableChange
    }


expressionMapTypes :
    (type_ -> changedType)
    -> Expression type_
    -> Expression changedType
expressionMapTypes typeChange expression =
    -- IGNORE TCO
    case expression of
        ExpressionUnit ->
            ExpressionUnit

        ExpressionFloat floatValue ->
            ExpressionFloat floatValue

        ExpressionChar charValue ->
            ExpressionChar charValue

        ExpressionString stringValue ->
            ExpressionString stringValue

        ExpressionInteger expressionNumber ->
            ExpressionInteger expressionNumber

        ExpressionReference reference ->
            ExpressionReference reference

        ExpressionOperatorFunction expressionOperatorFunction ->
            ExpressionOperatorFunction expressionOperatorFunction

        ExpressionRecordAccessFunction fieldName ->
            ExpressionRecordAccessFunction fieldName

        ExpressionNegation inNegation ->
            ExpressionNegation
                (inNegation
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionParenthesized inParens ->
            ExpressionParenthesized
                (inParens
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionRecordAccess expressionRecordAccess ->
            ExpressionRecordAccess
                { record =
                    expressionRecordAccess.record
                        |> expressionTypedNodeMapTypes typeChange
                , fieldName = expressionRecordAccess.fieldName
                , fieldNameRange = expressionRecordAccess.fieldNameRange
                }

        ExpressionInfixOperation expressionInfixOperation ->
            ExpressionInfixOperation
                { operator =
                    { symbol = expressionInfixOperation.operator.symbol
                    , moduleOrigin = expressionInfixOperation.operator.moduleOrigin
                    , type_ =
                        expressionInfixOperation.operator.type_
                            |> typeChange
                    }
                , left =
                    expressionInfixOperation.left
                        |> expressionTypedNodeMapTypes typeChange
                , right =
                    expressionInfixOperation.right
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTuple expressionTuple ->
            ExpressionTuple
                { part0 =
                    expressionTuple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTuple.part1
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTriple expressionTriple ->
            ExpressionTriple
                { part0 =
                    expressionTriple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTriple.part1
                        |> expressionTypedNodeMapTypes typeChange
                , part2 =
                    expressionTriple.part2
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionIfThenElse expressionIfThenElse ->
            ExpressionIfThenElse
                { condition =
                    expressionIfThenElse.condition
                        |> expressionTypedNodeMapTypes typeChange
                , onTrue =
                    expressionIfThenElse.onTrue
                        |> expressionTypedNodeMapTypes typeChange
                , onFalse =
                    expressionIfThenElse.onFalse
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionList expressionListElements ->
            ExpressionList
                (expressionListElements
                    |> List.map
                        (\element ->
                            element
                                |> expressionTypedNodeMapTypes
                                    typeChange
                        )
                )

        ExpressionCall expressionCall ->
            ExpressionCall
                { called =
                    expressionCall.called
                        |> expressionTypedNodeMapTypes typeChange
                , argument0 =
                    expressionCall.argument0
                        |> expressionTypedNodeMapTypes typeChange
                , argument1Up =
                    expressionCall.argument1Up
                        |> List.map
                            (\argument ->
                                argument
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            )
                }

        ExpressionRecord expressionRecordFields ->
            ExpressionRecord
                (expressionRecordFields
                    |> List.map
                        (\field ->
                            { range = field.range
                            , name = field.name
                            , nameRange = field.nameRange
                            , value =
                                field.value
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            }
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            ExpressionRecordUpdate
                { recordVariable =
                    { range = expressionRecordUpdate.recordVariable.range
                    , value = expressionRecordUpdate.recordVariable.value
                    , type_ =
                        expressionRecordUpdate.recordVariable.type_
                            |> typeChange
                    }
                , field0 =
                    { range = expressionRecordUpdate.field0.range
                    , name = expressionRecordUpdate.field0.name
                    , nameRange = expressionRecordUpdate.field0.nameRange
                    , value =
                        expressionRecordUpdate.field0.value
                            |> expressionTypedNodeMapTypes
                                typeChange
                    }
                , field1Up =
                    expressionRecordUpdate.field1Up
                        |> List.map
                            (\field ->
                                { range = field.range
                                , name = field.name
                                , nameRange = field.nameRange
                                , value =
                                    field.value
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                }
                            )
                }

        ExpressionLambda expressionLambda ->
            ExpressionLambda
                { parameter0 =
                    expressionLambda.parameter0
                        |> patternTypedNodeMapTypes typeChange
                , parameter1Up =
                    expressionLambda.parameter1Up
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    expressionLambda.result
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionCaseOf expressionCaseOf ->
            ExpressionCaseOf
                { matchedExpression =
                    expressionCaseOf.matchedExpression
                        |> expressionTypedNodeMapTypes typeChange
                , case0 =
                    { pattern =
                        expressionCaseOf.case0.pattern
                            |> patternTypedNodeMapTypes typeChange
                    , result =
                        expressionCaseOf.case0.result
                            |> expressionTypedNodeMapTypes typeChange
                    }
                , case1Up =
                    expressionCaseOf.case1Up
                        |> List.map
                            (\case_ ->
                                { pattern =
                                    case_.pattern
                                        |> patternTypedNodeMapTypes typeChange
                                , result =
                                    case_.result
                                        |> expressionTypedNodeMapTypes typeChange
                                }
                            )
                }

        ExpressionLetIn expressionLetIn ->
            ExpressionLetIn
                { declaration0 =
                    { range = expressionLetIn.declaration0.range
                    , declaration =
                        expressionLetIn.declaration0.declaration
                            |> letDeclarationMapTypes typeChange
                    }
                , declaration1Up =
                    expressionLetIn.declaration1Up
                        |> List.map
                            (\letDeclarationAndRange ->
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    letDeclarationAndRange.declaration
                                        |> letDeclarationMapTypes typeChange
                                }
                            )
                , result =
                    expressionLetIn.result
                        |> expressionTypedNodeMapTypes typeChange
                }


letDeclarationMapTypes :
    (type_ -> changedType)
    -> LetDeclaration type_
    -> LetDeclaration changedType
letDeclarationMapTypes typeChange expressionLetDeclaration =
    case expressionLetDeclaration of
        LetDestructuring letDestructuring ->
            LetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> patternTypedNodeMapTypes typeChange
                , expression =
                    letDestructuring.expression
                        |> expressionTypedNodeMapTypes typeChange
                }

        LetValueOrFunctionDeclaration letValueOrFunction ->
            LetValueOrFunctionDeclaration
                { signature =
                    letValueOrFunction.signature
                        |> Maybe.map
                            (\signature ->
                                { nameRange = signature.nameRange
                                , range = signature.range
                                , annotationType = signature.annotationType
                                , annotationTypeRange = signature.annotationTypeRange
                                }
                            )
                , nameRange = letValueOrFunction.nameRange
                , name = letValueOrFunction.name
                , parameters =
                    letValueOrFunction.parameters
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    letValueOrFunction.result
                        |> expressionTypedNodeMapTypes typeChange
                , type_ =
                    letValueOrFunction.type_
                        |> typeChange
                }


expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        { substitutions : VariableSubstitutions
        , node :
            TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
        , introducedTypeVariables : FastSet.Set TypeVariableFromContext
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
expressionTypeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariables declarationTypes substitutionsToAddOrApply expressionTypeInferResult =
    typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable
        { declarationTypes = declarationTypes
        , nodeApplyVariableSubstitutions =
            \substitutionsToApply ->
                expressionTypeInferResult.node
                    |> expressionTypedNodeApplyVariableSubstitutions declarationTypes
                        substitutionsToApply
        }
        substitutionsToAddOrApply
        { substitutions = expressionTypeInferResult.substitutions
        , introducedTypeVariables =
            expressionTypeInferResult.introducedTypeVariables
        }


typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , nodeApplyVariableSubstitutions :
        VariableSubstitutions
        -> Result String nodeAfterApplyingSubstitutions
    }
    -> VariableSubstitutions
    ->
        { substitutions : VariableSubstitutions
        , introducedTypeVariables : FastSet.Set TypeVariableFromContext
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node : nodeAfterApplyingSubstitutions
            , introducedTypeVariables : FastSet.Set TypeVariableFromContext
            }
typeInferResultAddOrApplySubstitutionsOfIntroducedTypeVariable context substitutionsToAddOrApply expressionTypeInferResult =
    let
        ( substitutionsVariableToTypeToApply, substitutionsVariableToTypeToAdd ) =
            substitutionsToAddOrApply.variableToType
                |> FastDict.partition
                    (\variableToReplace _ ->
                        expressionTypeInferResult.introducedTypeVariables
                            |> FastSet.member variableToReplace
                    )

        ( equivalentVariableSubstitutionsToApply, equivalentVariableSubstitutionsToAdd ) =
            substitutionsToAddOrApply.equivalentVariables
                |> List.partition
                    (\equivalentVariableSet ->
                        expressionTypeInferResult.introducedTypeVariables
                            |> fastSetIsSupersetOf equivalentVariableSet
                    )

        substitutionsToApply : VariableSubstitutions
        substitutionsToApply =
            { equivalentVariables = equivalentVariableSubstitutionsToApply
            , variableToType = substitutionsVariableToTypeToApply
            }

        substitutionsToAddNotSubstituted : VariableSubstitutions
        substitutionsToAddNotSubstituted =
            { equivalentVariables = equivalentVariableSubstitutionsToAdd
            , variableToType = substitutionsVariableToTypeToAdd
            }
    in
    Result.map3
        (\nodeSubstituted variableToCondensedLookup substitutionsWithAdded ->
            { substitutions = substitutionsWithAdded
            , node = nodeSubstituted
            , introducedTypeVariables =
                expressionTypeInferResult.introducedTypeVariables
                    |> FastSet.map
                        (\variable ->
                            variableToCondensedLookup
                                |> FastDict.get variable
                                |> Maybe.withDefault variable
                        )
            }
        )
        (context.nodeApplyVariableSubstitutions substitutionsToApply)
        (createEquivalentVariablesToCondensedVariableLookup
            substitutionsToApply.equivalentVariables
        )
        (Result.andThen
            (\substitutionsToKeep ->
                substitutionsToKeep
                    |> variableSubstitutionsApplyVariableSubstitutions context.declarationTypes
                        substitutionsToApply
            )
            (variableSubstitutionsMerge context.declarationTypes
                expressionTypeInferResult.substitutions
                substitutionsToAddNotSubstituted
            )
        )


fastSetIsSupersetOf : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetIsSupersetOf sub super =
    -- not sure there's a faster alternative since FastSet does not offer restructure
    super == FastSet.union sub super


variableSubstitutionsApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    ->
        Result
            String
            VariableSubstitutions
variableSubstitutionsApplyVariableSubstitutions declarationTypes substitutionsToApply substitutionsToApplySubstitutionsTo =
    case substitutionsToApply.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutionsToApply.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            variableSubstitutionsApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (substitutionsToApplySubstitutionsTo
                                    |> variableSubstitutionsMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            case substitutionsToApply.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok substitutionsToApplySubstitutionsTo

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    if typeToSubstituteByNext |> typeNotVariableContainedVariables |> FastSet.member variableToSubstituteNext then
                        Err
                            ("self-referential type "
                                ++ (variableToSubstituteNext |> typeVariableFromContextToInfoString)
                                ++ " = "
                                ++ (typeToSubstituteByNext |> typeNotVariableToInfoString)
                            )

                    else
                        let
                            variableToTypeSubstitutionToApplyNext :
                                { variable : TypeVariableFromContext
                                , type_ : TypeNotVariable TypeVariableFromContext
                                }
                            variableToTypeSubstitutionToApplyNext =
                                { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                        in
                        case
                            substitutionsToApplySubstitutionsTo
                                |> variableSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                    variableToTypeSubstitutionToApplyNext
                        of
                            Err error ->
                                Err error

                            Ok substitutionsAfterSubstitution ->
                                case
                                    remainingVariableToTypeSubstitutions
                                        |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                            variableToTypeSubstitutionToApplyNext
                                of
                                    Err error ->
                                        Err error

                                    Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                        variableSubstitutionsApplyVariableSubstitutions declarationTypes
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                            substitutionsAfterSubstitution


variableSubstitutionsMapTypeVariables :
    (TypeVariableFromContext -> TypeVariableFromContext)
    -> VariableSubstitutions
    -> VariableSubstitutions
variableSubstitutionsMapTypeVariables typeVariableChange variableSubstitutions =
    { equivalentVariables =
        variableSubstitutions.equivalentVariables
            |> List.map
                (\equivalentVariablesSet ->
                    equivalentVariablesSet |> FastSet.map typeVariableChange
                )
    , variableToType =
        variableSubstitutions.variableToType
            |> fastDictMapToFastDict
                (\variable replacementType ->
                    { key = variable |> typeVariableChange
                    , value =
                        replacementType
                            |> typeNotVariableMapVariables typeVariableChange
                    }
                )
    }


variableSubstitutionsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsSubstituteVariableByNotVariable declarationTypes substitution variableSubstitutions =
    Result.map
        (\variableToTypeSubstituted ->
            { equivalentVariables =
                equivalentVariableSetMerge
                    variableSubstitutions.equivalentVariables
                    variableToTypeSubstituted.equivalentVariables
            , variableToType = variableToTypeSubstituted.variableToType
            }
        )
        (variableSubstitutions.variableToType
            |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                substitution
        )


expressionTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionTypedNodeApplyVariableSubstitutions declarationTypes substitutions expressionTypedNode =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (expressionTypedNode
                                    |> expressionTypedNodeMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok expressionTypedNode

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        expressionTypedNode
                            |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok expressionTypedNodeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            expressionTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                expressionTypedNodeWithVariableToTypeSubstitutionApplied.node


patternTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypedNodeApplyVariableSubstitutions declarationTypes substitutions patternTypedNode =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            patternTypedNodeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (patternTypedNode
                                    |> patternTypedNodeMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok patternTypedNode

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        patternTypedNode
                            |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok patternTypedNodeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            patternTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                patternTypedNodeWithVariableToTypeSubstitutionApplied.node


patternTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
patternTypedNodeSubstituteVariableByNotVariable declarationTypes replacement patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternInt _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternIgnored ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternIgnored
                        , type_ = substituted.type_
                        }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternVariable name ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternVariable name
                        , type_ = substituted.type_
                        }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternParenthesized inParensSubstituted.node
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (inParens
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternAs patternAs ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value =
                            PatternAs
                                { pattern = inParensSubstituted.node
                                , variable =
                                    { range = patternAs.variable.range
                                    , value = patternAs.variable.value
                                    , type_ = inParensSubstituted.node.type_
                                    }
                                }
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (patternAs.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternListCons patternListCons ->
            resultAndThen2
                (\headSubstituted tailSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListCons
                                        { head = headSubstituted.node
                                        , tail = tailSubstituted.node
                                        }
                                , type_ = typeListList headSubstituted.node.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            headSubstituted.substitutions
                            tailSubstituted.substitutions
                        )
                )
                (patternListCons.head
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListCons.tail
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTuple patternTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 = part0Substituted.node.type_
                                            , part1 = part1Substituted.node.type_
                                            }
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (patternTuple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTuple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTriple patternTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTriple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        , part2 = part2Substituted.node
                                        }
                                , type_ =
                                    TypeNotVariable
                                        (TypeTriple
                                            { part0 = part0Substituted.node.type_
                                            , part1 = part1Substituted.node.type_
                                            , part2 = part2Substituted.node.type_
                                            }
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (patternTriple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part2
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternRecord patternRecordFields ->
            resultAndThen2
                (\typeSubstituted fieldsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternRecord
                                        fieldsSubstituted.nodes
                                , type_ =
                                    TypeNotVariable
                                        (TypeRecord
                                            (fieldsSubstituted.nodes
                                                |> List.foldl
                                                    (\fieldSubstituted soFar ->
                                                        soFar
                                                            |> FastDict.insert fieldSubstituted.value
                                                                fieldSubstituted.type_
                                                    )
                                                    FastDict.empty
                                            )
                                        )
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            fieldsSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternRecordFields
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldTypeSubstituted ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { substitutions = substitutionsWithField
                                            , nodes =
                                                { value = fieldNode.value
                                                , range = fieldNode.range
                                                , type_ = fieldTypeSubstituted.type_
                                                }
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldTypeSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.type_
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        PatternListExact patternListElements ->
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListExact
                                        elementsSubstituted.nodes
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListElements
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\elementNode soFar ->
                            Result.andThen
                                (\fieldSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodes =
                                                fieldSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        PatternVariant patternVariant ->
            resultAndThen2
                (\typeSubstituted valuesSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternVariant
                                        { qualification = patternVariant.qualification
                                        , name = patternVariant.name
                                        , moduleOrigin = patternVariant.moduleOrigin
                                        , values = valuesSubstituted.nodes
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            valuesSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternVariant.values
                    |> listFoldrWhileOkFrom
                        substitutionsNoneNodesEmpty
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodes =
                                                argumentSubstituted.node
                                                    :: soFar.nodes
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )


substitutionsNoneNodesEmpty : { substitutions : VariableSubstitutions, nodes : List node_ }
substitutionsNoneNodesEmpty =
    { substitutions = variableSubstitutionsNone
    , nodes = []
    }


patternTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Pattern (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Pattern (Type changedTypeVariable)) (Type changedTypeVariable)
patternTypedNodeMapTypeVariables typeVariableChange patternTypedNode =
    patternTypedNode
        |> patternTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


patternTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Pattern type_) type_
    -> TypedNode (Pattern changedType) changedType
patternTypedNodeMapTypes typeVariableChange patternTypedNode =
    { range = patternTypedNode.range
    , value =
        patternTypedNode.value
            |> patternMapTypes typeVariableChange
    , type_ =
        patternTypedNode.type_
            |> typeVariableChange
    }


patternMapTypes :
    (type_ -> changedType)
    -> Pattern type_
    -> Pattern changedType
patternMapTypes typeChange pattern =
    -- IGNORE TCO
    case pattern of
        PatternUnit ->
            PatternUnit

        PatternChar charValue ->
            PatternChar charValue

        PatternString stringValue ->
            PatternString stringValue

        PatternInt patternInt ->
            PatternInt patternInt

        PatternIgnored ->
            PatternIgnored

        PatternVariable variable ->
            PatternVariable variable

        PatternParenthesized inParens ->
            PatternParenthesized
                (inParens
                    |> patternTypedNodeMapTypes typeChange
                )

        PatternAs patternAs ->
            let
                patternWithTypeWithVariablesChanged : TypedNode (Pattern changedType) changedType
                patternWithTypeWithVariablesChanged =
                    patternAs.pattern
                        |> patternTypedNodeMapTypes typeChange
            in
            PatternAs
                { pattern = patternWithTypeWithVariablesChanged
                , variable =
                    { range = patternAs.variable.range
                    , value = patternAs.variable.value
                    , type_ = patternWithTypeWithVariablesChanged.type_
                    }
                }

        PatternListCons patternListCons ->
            PatternListCons
                { head =
                    patternListCons.head
                        |> patternTypedNodeMapTypes typeChange
                , tail =
                    patternListCons.tail
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTuple patternTuple ->
            PatternTuple
                { part0 =
                    patternTuple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTuple.part1
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTriple patternTriple ->
            PatternTriple
                { part0 =
                    patternTriple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTriple.part1
                        |> patternTypedNodeMapTypes typeChange
                , part2 =
                    patternTriple.part2
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternRecord patternRecordFields ->
            PatternRecord
                (patternRecordFields
                    |> List.map
                        (\field ->
                            { value = field.value
                            , range = field.range
                            , type_ =
                                field.type_ |> typeChange
                            }
                        )
                )

        PatternListExact patternListElement ->
            PatternListExact
                (patternListElement
                    |> List.map
                        (\element ->
                            element
                                |> patternTypedNodeMapTypes
                                    typeChange
                        )
                )

        PatternVariant patternVariant ->
            PatternVariant
                { qualification = patternVariant.qualification
                , name = patternVariant.name
                , moduleOrigin = patternVariant.moduleOrigin
                , values =
                    patternVariant.values
                        |> List.map
                            (\argument ->
                                argument
                                    |> patternTypedNodeMapTypes
                                        typeChange
                            )
                }


equivalentVariablesCreateCondensedVariable : FastSet.Set TypeVariableFromContext -> Result String TypeVariableFromContext
equivalentVariablesCreateCondensedVariable set =
    case set |> FastSet.toList of
        [] ->
            Err "implementation bug: equivalent variables set is empty"

        [ onlyVariable ] ->
            Ok onlyVariable

        variable0 :: variable1 :: variable2Up ->
            Result.map
                (\unifiedMaybeConstraint ->
                    case unifiedMaybeConstraint of
                        Nothing ->
                            variable0

                        Just unifiedConstraint ->
                            let
                                ( variable0Context, variable0IgnoringContext ) =
                                    variable0
                            in
                            ( variable0Context
                            , variable0IgnoringContext
                                |> typeVariableNameReplaceConstraint unifiedConstraint
                            )
                )
                ((variable0 :: variable1 :: variable2Up)
                    |> listFoldlWhileOkFrom Nothing
                        (\variable soFar ->
                            maybeTypeVariableConstraintMerge
                                (variable
                                    |> typeVariableIgnoringContext
                                    |> typeVariableConstraint
                                )
                                soFar
                        )
                )


maybeTypeVariableConstraintToString : Maybe TypeVariableConstraint -> String
maybeTypeVariableConstraintToString maybeConstraint =
    case maybeConstraint of
        Nothing ->
            ""

        Just constraint ->
            constraint |> typeVariableConstraintToString


typeVariableConstraintToString : TypeVariableConstraint -> String
typeVariableConstraintToString constraint =
    case constraint of
        TypeVariableConstraintNumber ->
            "number"

        TypeVariableConstraintAppendable ->
            "appendable"

        TypeVariableConstraintComparable ->
            "comparable"

        TypeVariableConstraintCompappend ->
            "compappend"


typeVariableNameReplaceConstraint : TypeVariableConstraint -> String -> String
typeVariableNameReplaceConstraint replacementConstraint typeVariableNameWithPotentialConstraint =
    let
        typeVariableNameWithoutConstraint : String
        typeVariableNameWithoutConstraint =
            case typeVariableNameWithPotentialConstraint |> typeVariableConstraint of
                Nothing ->
                    typeVariableNameWithPotentialConstraint

                Just constraint ->
                    String.dropLeft
                        (constraint |> typeVariableConstraintToString |> String.length)
                        typeVariableNameWithPotentialConstraint
                        |> stringFirstCharToLower
    in
    (replacementConstraint |> typeVariableConstraintToString)
        ++ (typeVariableNameWithoutConstraint |> stringFirstCharToUpper)


fastDictFoldlWhileOkFrom : ok -> (key -> value -> ok -> Result err ok) -> FastDict.Dict key value -> Result err ok
fastDictFoldlWhileOkFrom initialFolded reduceToResult fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value soFarOrError ->
                case soFarOrError of
                    Err error ->
                        Err error |> FastDict.Stop

                    Ok soFar ->
                        case reduceToResult key value soFar of
                            Err error ->
                                Err error |> FastDict.Stop

                            Ok foldedWithEntry ->
                                Ok foldedWithEntry |> FastDict.Continue
            )
            (Ok initialFolded)


fastDictMapAndSmallestJust : (key -> value -> Maybe ok) -> FastDict.Dict key value -> Maybe ok
fastDictMapAndSmallestJust keyValueToMaybe fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value _ ->
                case keyValueToMaybe key value of
                    Just foldedWithEntry ->
                        Just foldedWithEntry |> FastDict.Stop

                    Nothing ->
                        fastDictContinueNothing
            )
            Nothing


fastDictContinueNothing : FastDict.Step (Maybe folded_)
fastDictContinueNothing =
    FastDict.Continue Nothing


parameterPatternsTypeInfer :
    { path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
    ->
        Result
            String
            { introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , nodes :
                List
                    (TypedNode
                        (Pattern (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                    )
            }
parameterPatternsTypeInfer context parameterPatterns =
    parameterPatterns
        |> listFoldrWhileOkFrom
            introducedExpressionVariablesEmptyNodesEmptyIndexFromEnd0
            (\pattern soFar ->
                Result.map
                    (\patternInferred ->
                        { indexFromEnd = soFar.indexFromEnd + 1
                        , nodes =
                            patternInferred
                                :: soFar.nodes
                        , introducedExpressionVariables =
                            FastDict.union soFar.introducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                    )
                    (pattern
                        |> patternTypeInfer
                            (context
                                |> patternContextToInPath
                                    ("parameterFromEnd"
                                        ++ (soFar.indexFromEnd |> String.fromInt)
                                    )
                            )
                    )
            )
        |> Result.map
            (\folded ->
                { introducedExpressionVariables = folded.introducedExpressionVariables
                , nodes = folded.nodes
                }
            )


introducedExpressionVariablesEmptyNodesEmptyIndexFromEnd0 :
    { introducedExpressionVariables : FastDict.Dict String (Type TypeVariableFromContext)
    , nodes : List node_
    , indexFromEnd : Int
    }
introducedExpressionVariablesEmptyNodesEmptyIndexFromEnd0 =
    { introducedExpressionVariables = FastDict.empty
    , nodes = []
    , indexFromEnd = 0
    }


{-| Extract all known types
from module [metadata](https://dark.elm.dmy.fr/packages/elm/project-metadata-utils/latest/),
usually from parsing the `docs.json` of a dependency.

For elm-syntax modules, use [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)

-}
moduleInterfaceToTypes :
    Elm.Docs.Module
    -> { types : ModuleTypes, errors : List String }
moduleInterfaceToTypes moduleInterface =
    let
        typeAliases :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { type_ : Type String
                    , parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    }
            }
        typeAliases =
            moduleInterface.aliases
                |> List.foldl
                    (\typeAliasDeclarationInterface soFar ->
                        case
                            typeAliasDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            typeAliasDeclarationInterface.name
                                            { type_ = type_
                                            , parameters = typeAliasDeclarationInterface.args
                                            , recordFieldOrder =
                                                case typeAliasDeclarationInterface.tipe of
                                                    Elm.Type.Record fields Nothing ->
                                                        Just (fields |> List.map (\( name, _ ) -> name))

                                                    Elm.Type.Record _ (Just _) ->
                                                        Nothing

                                                    Elm.Type.Var _ ->
                                                        Nothing

                                                    Elm.Type.Lambda _ _ ->
                                                        Nothing

                                                    Elm.Type.Tuple _ ->
                                                        Nothing

                                                    Elm.Type.Type _ _ ->
                                                        Nothing
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        choiceTypes :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (List (Type String))
                    }
            }
        choiceTypes =
            moduleInterface.unions
                |> List.foldl
                    (\declarationChoiceType soFar ->
                        case
                            declarationChoiceType.tags
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\( variantName, variantValueInterfaces ) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert variantName
                                                        variantValues
                                            )
                                            (variantValueInterfaces
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue |> interfaceToType
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            declarationChoiceType.name
                                            { parameters =
                                                declarationChoiceType.args
                                            , variants = variants
                                            }
                                }
                    )
                    typesDictEmptyErrorsEmpty

        signatures : { errors : List String, types : FastDict.Dict String (Type String) }
        signatures =
            moduleInterface.values
                |> List.foldl
                    (\valueOrFunctionDeclarationInterface soFar ->
                        case
                            valueOrFunctionDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            valueOrFunctionDeclarationInterface.name
                                            type_
                                }
                    )
                    typesDictEmptyErrorsEmpty
    in
    { errors =
        typeAliases.errors
            ++ choiceTypes.errors
            ++ signatures.errors
    , types =
        { typeAliases = typeAliases.types
        , choiceTypes = choiceTypes.types
        , signatures = signatures.types
        }
    }


typesDictEmptyErrorsEmpty : { types : FastDict.Dict String info_, errors : List error_ }
typesDictEmptyErrorsEmpty =
    { types = FastDict.empty
    , errors = []
    }


interfaceToType : Elm.Type.Type -> Result String (Type String)
interfaceToType typeInterface =
    -- IGNORE TCO
    case typeInterface of
        Elm.Type.Var name ->
            Ok (TypeVariable name)

        Elm.Type.Lambda functionInput functionOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (functionInput |> interfaceToType)
                (functionOutput |> interfaceToType)

        Elm.Type.Tuple parts ->
            case parts of
                [] ->
                    okTypeUnit

                [ inParens ] ->
                    inParens |> interfaceToType

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (tuplePart1 |> interfaceToType)
                        (tuplePart0 |> interfaceToType)

                [ triplePart0, triplePart1, triplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (triplePart0 |> interfaceToType)
                        (triplePart1 |> interfaceToType)
                        (triplePart2 |> interfaceToType)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Type.Type reference argumentInterfaces ->
            case reference |> String.split "." |> List.reverse of
                referenceName :: referenceModulePartLast :: referenceModulePartBeforeLastDown ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin =
                                        (referenceModulePartLast :: referenceModulePartBeforeLastDown)
                                            |> List.reverse
                                    , name = referenceName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentInterfaces |> listMapAndCombineOk interfaceToType)

                [ _ ] ->
                    Err "invalid reference"

                [] ->
                    Err "invalid reference"

        Elm.Type.Record fieldInterfaces Nothing ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )

        Elm.Type.Record fieldInterfaces (Just extendedRecordVariable) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { fields = fields
                            , recordVariable = extendedRecordVariable
                            }
                        )
                )
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )


okTypeUnit : Result error_ (Type variable_)
okTypeUnit =
    Ok (TypeNotVariable TypeUnit)


{-| Extract all known types
from declarations within a module.
Un-annotated value/function declarations are ignored.

For dependency modules, use [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

-}
moduleDeclarationsToTypes :
    ModuleOriginLookup
    -> List Elm.Syntax.Declaration.Declaration
    -> { types : ModuleTypes, errors : List String }
moduleDeclarationsToTypes moduleOriginLookupNotIncludingLocalDeclarations declarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            declarations
                |> List.foldl
                    (\declaration soFar ->
                        case declaration of
                            Elm.Syntax.Declaration.InfixDeclaration _ ->
                                soFar

                            Elm.Syntax.Declaration.Destructuring _ _ ->
                                soFar

                            Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( []
                                                , declarationValueOrFunction.declaration
                                                    |> Elm.Syntax.Node.value
                                                    |> .name
                                                    |> Elm.Syntax.Node.value
                                                )
                                                []
                                }

                            Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationTypeAlias.name |> Elm.Syntax.Node.value )
                                                []
                                }

                            Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationChoiceType.name |> Elm.Syntax.Node.value )
                                                []
                                    , references =
                                        declarationChoiceType.constructors
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ variant) soFarReferencesIncludingVariantsSoFar ->
                                                    soFarReferencesIncludingVariantsSoFar
                                                        |> FastDict.insert
                                                            ( [], variant.name |> Elm.Syntax.Node.value )
                                                            []
                                                )
                                                soFar.references
                                }

                            Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( [], declarationPortSignature.name |> Elm.Syntax.Node.value )
                                                []
                                }
                    )
                    moduleOriginLookupNotIncludingLocalDeclarations
    in
    declarations
        |> List.foldl
            (\declaration soFar ->
                case declaration of
                    Elm.Syntax.Declaration.InfixDeclaration _ ->
                        soFar

                    Elm.Syntax.Declaration.Destructuring _ _ ->
                        { errors =
                            "destructuring at the module level is invalid syntax"
                                :: soFar.errors
                        , types = soFar.types
                        }

                    Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                        case declarationValueOrFunction.signature of
                            Nothing ->
                                soFar

                            Just (Elm.Syntax.Node.Node _ declarationValueOrFunctionSignature) ->
                                case
                                    declarationValueOrFunctionSignature.typeAnnotation
                                        |> Elm.Syntax.Node.value
                                        |> syntaxToType moduleOriginLookup
                                of
                                    Err error ->
                                        { errors = error :: soFar.errors
                                        , types = soFar.types
                                        }

                                    Ok type_ ->
                                        { errors = soFar.errors
                                        , types =
                                            { signatures =
                                                soFar.types.signatures
                                                    |> FastDict.insert
                                                        (declarationValueOrFunctionSignature.name |> Elm.Syntax.Node.value)
                                                        type_
                                            , typeAliases = soFar.types.typeAliases
                                            , choiceTypes = soFar.types.choiceTypes
                                            }
                                        }

                    Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                        case
                            declarationTypeAlias.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases =
                                        soFar.types.typeAliases
                                            |> FastDict.insert
                                                (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationTypeAlias.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , type_ = type_
                                                , recordFieldOrder =
                                                    case declarationTypeAlias.typeAnnotation |> Elm.Syntax.Node.value of
                                                        Elm.Syntax.TypeAnnotation.Record fields ->
                                                            Just
                                                                (fields
                                                                    |> List.map
                                                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                                                            name
                                                                        )
                                                                )

                                                        Elm.Syntax.TypeAnnotation.GenericType _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Unit ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                                                            Nothing
                                                }
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }

                    Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                        case
                            declarationChoiceType.constructors
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\(Elm.Syntax.Node.Node _ variant) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        (variant.name |> Elm.Syntax.Node.value)
                                                        variantValues
                                            )
                                            (variant.arguments
                                                |> listMapAndCombineOk
                                                    (\(Elm.Syntax.Node.Node _ variantValue) ->
                                                        variantValue |> syntaxToType moduleOriginLookup
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes =
                                        soFar.types.choiceTypes
                                            |> FastDict.insert
                                                (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationChoiceType.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , variants = variants
                                                }
                                    }
                                }

                    Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                        case
                            declarationPortSignature.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures =
                                        soFar.types.signatures
                                            |> FastDict.insert
                                                (declarationPortSignature.name |> Elm.Syntax.Node.value)
                                                type_
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }
            )
            typesEmptyAndErrorsEmpty


typesEmptyAndErrorsEmpty : { types : ModuleTypes, errors : List error_ }
typesEmptyAndErrorsEmpty =
    { types = moduleTypesEmpty
    , errors = []
    }


moduleTypesEmpty : ModuleTypes
moduleTypesEmpty =
    { signatures = FastDict.empty
    , typeAliases = FastDict.empty
    , choiceTypes = FastDict.empty
    }


typeVariablesFromContextToDisambiguationLookup :
    FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookup variables =
    typeVariablesFromContextToDisambiguationLookupInto FastDict.empty variables


typeVariablesFromContextToDisambiguationLookupInto :
    FastDict.Dict TypeVariableFromContext String
    -> FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookupInto soFar variables =
    case variables |> FastSet.popMin of
        Nothing ->
            soFar

        Just ( variable, remainingVariables ) ->
            let
                ( _, name ) =
                    variable

                alreadyExists : String -> Bool
                alreadyExists toDisambiguate =
                    soFar
                        |> fastDictAny
                            (\soFarVariableAsString ->
                                soFarVariableAsString == toDisambiguate
                            )

                variableAsDisambiguatedString : String
                variableAsDisambiguatedString =
                    name |> nameDisambiguateBy alreadyExists
            in
            typeVariablesFromContextToDisambiguationLookupInto
                (soFar
                    |> FastDict.insert variable
                        variableAsDisambiguatedString
                )
                remainingVariables


typeVariableFromContextToName : TypeVariableFromContext -> String
typeVariableFromContextToName ( context, name ) =
    (name
        |> String.replace "_" ""
    )
        ++ (context
                |> List.map
                    (\part ->
                        part
                            |> String.replace "_" ""
                            |> stringFirstCharToUpper
                    )
                |> String.concat
           )


nameDisambiguateBy : (String -> Bool) -> String -> String
nameDisambiguateBy alreadyExists currentName =
    nameDisambiguateWithIndexBy 0 alreadyExists currentName


nameDisambiguateWithIndexBy : Int -> (String -> Bool) -> String -> String
nameDisambiguateWithIndexBy index alreadyExists currentName =
    let
        indexedCurrentName : String
        indexedCurrentName =
            case index of
                0 ->
                    currentName

                indexAtLeast1 ->
                    currentName ++ (indexAtLeast1 |> String.fromInt)
    in
    if alreadyExists indexedCurrentName then
        nameDisambiguateWithIndexBy (index + 1) alreadyExists currentName

    else
        indexedCurrentName


fastDictAny : (value -> Bool) -> FastDict.Dict key_ value -> Bool
fastDictAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.value
                    || state.left ()
                    || state.right ()
            )


{-| Like `FastDict.map` but also changing the key
-}
fastDictMapToFastDict :
    (key -> value -> { key : comparableMappedKey, value : mappedValue })
    -> FastDict.Dict key value
    -> FastDict.Dict comparableMappedKey mappedValue
fastDictMapToFastDict toNewEntry fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                let
                    entry : { key : comparableMappedKey, value : mappedValue }
                    entry =
                        toNewEntry key value
                in
                soFar |> FastDict.insert entry.key entry.value
            )
            FastDict.empty


listMapToFastDict :
    (a -> { key : comparableKey, value : value })
    -> List a
    -> FastDict.Dict comparableKey value
listMapToFastDict elementToKeyValue list =
    list
        |> List.foldl
            (\element soFar ->
                let
                    keyValue : { key : comparableKey, value : value }
                    keyValue =
                        element |> elementToKeyValue
                in
                soFar |> FastDict.insert keyValue.key keyValue.value
            )
            FastDict.empty


listFoldlWhileOkFromResult :
    Result err okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFromResult initialResult reduceOnOk list =
    case initialResult of
        Err error ->
            Err error

        Ok initialOkFolded ->
            listFoldlWhileOkFrom initialOkFolded reduceOnOk list


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


{-| Prefer `listFoldlWhileOkFrom` whenever you don't need to reverse the result
-}
listFoldrWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldrWhileOkFrom initialOkFolded reduceOnOk list =
    list
        |> List.foldr
            (\element soFar ->
                case soFar of
                    Err error ->
                        Err error

                    Ok soFarOk ->
                        soFarOk |> reduceOnOk element
            )
            (Ok initialOkFolded)


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


resultAndThen3 :
    (a -> b -> c -> Result error d)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
resultAndThen3 abToResult aResult bResult cResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            abToResult a b c


resultAndThen4 :
    (a -> b -> c -> d -> Result error e)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
    -> Result error e
resultAndThen4 abToResult aResult bResult cResult dResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            case dResult of
                                Err error ->
                                    Err error

                                Ok d ->
                                    abToResult a b c d


elmCoreTypesGeneratedFromDocsJson :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypesGeneratedFromDocsJson =
    FastDict.fromList
        [ ( [ "Array" ]
          , { signatures =
                FastDict.fromList
                    [ ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Array" ]
                                , name = "Array"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "initialize"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "push"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toIndexedList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Array"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Basics" ]
          , { signatures =
                FastDict.fromList
                    [ ( "abs"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "acos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "always"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "asin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "ceiling"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "clamp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "number"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "number"
                                                        , output =
                                                            TypeVariable
                                                                "number"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "compare"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Order"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "degrees"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "e"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "floor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "isInfinite"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isNaN"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "logBase"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "max"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "min"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "modBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "never"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Never"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "not"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pi"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "radians"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remainderBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "round"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sqrt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "tan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "truncate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "turns"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bool"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "True", [] ), ( "False", [] ) ]
                        }
                      )
                    , ( "Float"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Int"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Never"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Order"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "LT", [] ), ( "EQ", [] ), ( "GT", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Bitwise" ]
          , { signatures =
                FastDict.fromList
                    [ ( "and"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "complement"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "or"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftLeftBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightZfBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Char" ]
          , { signatures =
                FastDict.fromList
                    [ ( "fromCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlpha"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlphaNum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isHexDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isOctDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Char"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Debug" ]
          , { signatures =
                FastDict.fromList
                    [ ( "log"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toString"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "todo"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Dict" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Dict" ]
                                , name = "Dict"
                                , arguments =
                                    [ TypeVariable "k"
                                    , TypeVariable "v"
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "comparable"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keys"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "merge"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "result"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "comparable"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "a"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "comparable"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Dict"
                                                                                    ]
                                                                                , name =
                                                                                    "Dict"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "comparable"
                                                                                    , TypeVariable
                                                                                        "a"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Dict"
                                                                                                ]
                                                                                            , name =
                                                                                                "Dict"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "comparable"
                                                                                                , TypeVariable
                                                                                                    "b"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "k"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "update"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "values"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Dict"
                      , { parameters = [ "k", "v" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "List" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concatMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "drop"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filterMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "head"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersperse"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maximum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "minimum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "product"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "range"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sort"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Order"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "tail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "take"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unzip"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.singleton
                    "List"
                    { parameters = [ "a" ], variants = FastDict.empty }
            }
          )
        , ( [ "Maybe" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Maybe"
                      , { parameters = [ "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Just"
                                  , [ TypeVariable "a" ]
                                  )
                                , ( "Nothing", [] )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform" ]
          , { signatures =
                FastDict.fromList
                    [ ( "sendToApp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sendToSelf"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "worker"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecord
                                            (FastDict.fromList
                                                [ ( "init"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "flags"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeTuple
                                                                        { part0 =
                                                                            TypeVariable
                                                                                "model"
                                                                        , part1 =
                                                                            TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        [ "Platform"
                                                                                        , "Cmd"
                                                                                        ]
                                                                                    , name =
                                                                                        "Cmd"
                                                                                    , arguments =
                                                                                        [ TypeVariable
                                                                                            "msg"
                                                                                        ]
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "subscriptions"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "model"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeConstruct
                                                                        { moduleOrigin =
                                                                            [ "Platform"
                                                                            , "Sub"
                                                                            ]
                                                                        , name =
                                                                            "Sub"
                                                                        , arguments =
                                                                            [ TypeVariable
                                                                                "msg"
                                                                            ]
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "update"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "msg"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            TypeVariable
                                                                                "model"
                                                                        , output =
                                                                            TypeNotVariable
                                                                                (TypeTuple
                                                                                    { part0 =
                                                                                        TypeVariable
                                                                                            "model"
                                                                                    , part1 =
                                                                                        TypeNotVariable
                                                                                            (TypeConstruct
                                                                                                { moduleOrigin =
                                                                                                    [ "Platform"
                                                                                                    , "Cmd"
                                                                                                    ]
                                                                                                , name =
                                                                                                    "Cmd"
                                                                                                , arguments =
                                                                                                    [ TypeVariable
                                                                                                        "msg"
                                                                                                    ]
                                                                                                }
                                                                                            )
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Program"
                                            , arguments =
                                                [ TypeVariable
                                                    "flags"
                                                , TypeVariable
                                                    "model"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "ProcessId"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Program"
                      , { parameters = [ "flags", "model", "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Router"
                      , { parameters = [ "appMsg", "selfMsg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Task"
                      , { parameters = [ "err", "ok" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Cmd" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Cmd" ]
                                            , name = "Cmd"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Cmd" ]
                                , name = "Cmd"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Cmd"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Sub" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Sub" ]
                                            , name = "Sub"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Sub" ]
                                , name = "Sub"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Sub"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Process" ]
          , { signatures =
                FastDict.fromList
                    [ ( "kill"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Process" ]
                                            , name = "Id"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sleep"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "spawn"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "y"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Process" ]
                                                        , name = "Id"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Id"
                      , { parameters = []
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "ProcessId"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Result" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "value"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "value"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Result" ]
                                            , name = "Result"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Result"
                      , { parameters = [ "error", "value" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Ok"
                                  , [ TypeVariable "value" ]
                                  )
                                , ( "Err"
                                  , [ TypeVariable "error" ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Set" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Set" ]
                                , name = "Set"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable2"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable2"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Set"
                      , { parameters = [ "t" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "String" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "contains"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "endsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromChar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexes"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indices"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "join"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "left"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lines"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pad"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replace"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "right"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "startsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trim"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uncons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Char"
                                                                        ]
                                                                    , name =
                                                                        "Char"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "words"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "String"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Task" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attempt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "onError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "perform"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Never"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Task"
                      , { parameters = [ "x", "a" ]
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "Task"
                                    , arguments =
                                        [ TypeVariable "x"
                                        , TypeVariable "a"
                                        ]
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Tuple" ]
          , { signatures =
                FastDict.fromList
                    [ ( "first"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "mapBoth"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "a"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "x"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "y"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapFirst"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "x"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapSecond"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pair"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "second"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "b"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        ]
