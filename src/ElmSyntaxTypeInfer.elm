module ElmSyntaxTypeInfer exposing
    ( valueAndFunctionDeclarations
    , ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
    , ModuleOriginLookup, importsToModuleOriginLookup
    , TypedNode, Expression(..), LetDeclaration(..), Pattern(..), Base10Or16(..)
    , Type(..), TypeNotVariable(..)
    )

{-| Add type information to the nodes
of an [elm-syntax](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/) tree.

@docs valueAndFunctionDeclarations

## context

@docs ModuleTypes, elmCoreTypes, moduleDeclarationsToTypes, moduleInterfaceToTypes
@docs ModuleOriginLookup, importsToModuleOriginLookup


## syntax

@docs TypedNode, Expression, LetDeclaration, Pattern, Base10Or16
@docs Type, TypeNotVariable

If you are interested in exposing helpers like `expressionMapType`,
[open an issue](https://github.com/lue-bird/elm-syntax-type-infer/issues/new)

-}

import Elm.Docs
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.Import
import Elm.Syntax.ModuleName
import Elm.Syntax.Node
import Elm.Syntax.Pattern
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import Elm.Type
import FastDict
import FastSet


{-| Known types of members in a module.
Create with [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)
-}
type alias ModuleTypes =
    { signatures :
        -- value, function, port
        FastDict.Dict String (Type String)
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : Type String
            , recordFieldOrder : Maybe (List String)
            }
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List (Type String))
            }
    }


{-| [`ModuleTypes`](#ModuleTypes) exposed in `elm/core`.

Please _always_ start with [`elmCoreTypes`](#elmCoreTypes)
and add further module info with [`FastDict.union`]()
using [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)
and [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

And if for some reason you already know used dependencies at compile time,
you can re-use the [code generator used for these elm/core types](https://github.com/lue-bird/elm-syntax-type-infer/tree/main/codegen)

-}
elmCoreTypes :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypes =
    elmCoreTypesGeneratedFromDocsJson


{-| When syntax _introduces_ type variables from another "context" (another (let) declaration, another branch, another element, ...)
we need to differentiate these from variables in the current "context"

For example,

    ( 0, 1 )
    -- ( number, number )
    ( identity, List.map identity )
    -- ( a -> a, List a -> List a )

would be incorrect inferences because
the `number` in `0` and `1` or `a` in `identity` and `List.map` are not related
and can be different types.
So in practice these are

    ( 0, 1 )
    -- ( ( [ "0" ], "number" ), ( [ "1" ], "number" ) )
    ( identity, List.map identity )
    -- ( ( [ "0" ], "a" ) -> ( [ "0" ], "a" )
    -- , List ( [ "1", "argument0" ], "a" )
    --   -> List ( [ "1", "argument0" ], "a" )
    -- )

`"0"` and `"1"` referring to the tuple part location
and `"argument0"` referring to the applied argument index.

We could work with some kind of name disambiguation system
but preserving names and context is usually nicer
for the final inferred variable names.

Performance note: `ContextVariable` is a tuple to allow for internal use as a dict key.

-}
type alias TypeVariableFromContext =
    ( -- path inner to outer
      List String
    , String
    )


type TypeVariableConstraint
    = TypeVariableConstraintNumber
    | TypeVariableConstraintAppendable
    | TypeVariableConstraintComparable
    | TypeVariableConstraintCompappend


typeVariableIgnoringContext : TypeVariableFromContext -> String
typeVariableIgnoringContext ( _, name ) =
    name


typeVariableFromContextMergeConstraintWith : TypeVariableConstraint -> TypeVariableFromContext -> Result String TypeVariableFromContext
typeVariableFromContextMergeConstraintWith additionalTypeVariableConstraint ( typeVariableContext, typeVariableWithoutContext ) =
    Result.map
        (\typeVariableWithoutContextWithMergedConstraint ->
            ( typeVariableContext
            , typeVariableWithoutContextWithMergedConstraint
            )
        )
        (typeVariableWithoutContext
            |> typeVariableMergeConstraintWith additionalTypeVariableConstraint
        )


typeVariableMergeConstraintWith : TypeVariableConstraint -> String -> Result String String
typeVariableMergeConstraintWith additionalTypeVariableConstraint typeVariable =
    case typeVariable |> typeVariableConstraint of
        Nothing ->
            Ok
                ((additionalTypeVariableConstraint |> typeVariableConstraintToString)
                    ++ (typeVariable |> stringFirstCharToUpper)
                )

        Just existingTypeVariableConstraint ->
            case typeVariableConstraintMerge existingTypeVariableConstraint additionalTypeVariableConstraint of
                Err error ->
                    Err error

                Ok mergedConstraint ->
                    Ok
                        ((mergedConstraint |> typeVariableConstraintToString)
                            ++ (typeVariable
                                    |> String.dropLeft
                                        (existingTypeVariableConstraint
                                            |> typeVariableConstraintToString
                                            |> String.length
                                        )
                                    |> stringFirstCharToUpper
                               )
                        )


typeVariableConstraint : String -> Maybe TypeVariableConstraint
typeVariableConstraint variableName =
    if variableName |> String.startsWith "number" then
        Just TypeVariableConstraintNumber

    else if variableName |> String.startsWith "appendable" then
        Just TypeVariableConstraintAppendable

    else if variableName |> String.startsWith "comparable" then
        Just TypeVariableConstraintComparable

    else if variableName |> String.startsWith "compappend" then
        Just TypeVariableConstraintCompappend

    else
        Nothing


maybeTypeVariableConstraintMerge : Maybe TypeVariableConstraint -> Maybe TypeVariableConstraint -> Result String (Maybe TypeVariableConstraint)
maybeTypeVariableConstraintMerge a b =
    case a of
        Nothing ->
            Ok b

        Just aConstraint ->
            case b of
                Nothing ->
                    Ok (Just aConstraint)

                Just bConstraint ->
                    Result.map Just
                        (typeVariableConstraintMerge aConstraint bConstraint)


typeVariableConstraintMerge : TypeVariableConstraint -> TypeVariableConstraint -> Result String TypeVariableConstraint
typeVariableConstraintMerge a b =
    case a of
        TypeVariableConstraintNumber ->
            case b of
                TypeVariableConstraintNumber ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintCompappend ->
                    Err "number and compappend variables cannot be unified"

        TypeVariableConstraintAppendable ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and appendable variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintAppendable

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend

        TypeVariableConstraintComparable ->
            case b of
                TypeVariableConstraintNumber ->
                    Ok TypeVariableConstraintNumber

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintComparable

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend

        TypeVariableConstraintCompappend ->
            case b of
                TypeVariableConstraintNumber ->
                    Err "number and compappend variables cannot be unified"

                TypeVariableConstraintAppendable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintComparable ->
                    Ok TypeVariableConstraintCompappend

                TypeVariableConstraintCompappend ->
                    Ok TypeVariableConstraintCompappend


{-| Type information attached to expressions and patterns,
see [`TypedNode`](#TypedNode).

This is different from [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)
in that it doesn't contain
information unrelated to type inference like ranges, qualification levels or parens.

-}
type Type variable
    = TypeVariable variable
    | TypeNotVariable (TypeNotVariable variable)


{-| [`Type`](#Type) except the variable case
-}
type TypeNotVariable variable
    = TypeUnit
    | TypeConstruct
        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , arguments : List (Type variable)
        }
    | TypeTuple
        { part0 : Type variable
        , part1 : Type variable
        }
    | TypeTriple
        { part0 : Type variable
        , part1 : Type variable
        , part2 : Type variable
        }
    | TypeRecord (FastDict.Dict String (Type variable))
    | TypeRecordExtension
        { recordVariable : variable
        , fields : FastDict.Dict String (Type variable)
        }
    | TypeFunction
        { input : Type variable
        , output : Type variable
        }


typeMapVariables :
    (variable -> changedVariable)
    -> Type variable
    -> Type changedVariable
typeMapVariables variableMap type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable variable ->
            TypeVariable (variable |> variableMap)

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariable
                    |> typeNotVariableMapVariables variableMap
                )


typeContainedVariables :
    Type comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeContainedVariables type_ =
    case type_ of
        TypeVariable variable ->
            FastSet.singleton variable

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableContainedVariables


typeNotVariableContainedVariables :
    TypeNotVariable comparableTypeVariable
    -> FastSet.Set comparableTypeVariable
typeNotVariableContainedVariables typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            FastSet.empty

        TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> typeContainedVariables)
                (typeFunction.output |> typeContainedVariables)

        TypeTuple typeTuple ->
            FastSet.union
                (typeTuple.part0 |> typeContainedVariables)
                (typeTuple.part1 |> typeContainedVariables)

        TypeTriple typeTriple ->
            FastSet.union
                (FastSet.union
                    (typeTriple.part0 |> typeContainedVariables)
                    (typeTriple.part1 |> typeContainedVariables)
                )
                (typeTriple.part2 |> typeContainedVariables)

        TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapAndFastSetsUnify typeContainedVariables

        TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union (value |> typeContainedVariables) soFar
                    )
                    FastSet.empty

        TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastSet.union (value |> typeContainedVariables) soFar
                    )
                    (FastSet.singleton typeRecordExtension.recordVariable)


typeNotVariableMapVariables :
    (variable -> variableMapped)
    -> TypeNotVariable variable
    -> TypeNotVariable variableMapped
typeNotVariableMapVariables variableMap typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            TypeUnit

        TypeConstruct typeConstruct ->
            TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map (\arg -> arg |> typeMapVariables variableMap)
                }

        TypeTuple typeTuple ->
            TypeTuple
                { part0 = typeTuple.part0 |> typeMapVariables variableMap
                , part1 = typeTuple.part1 |> typeMapVariables variableMap
                }

        TypeTriple typeTriple ->
            TypeTriple
                { part0 = typeTriple.part0 |> typeMapVariables variableMap
                , part1 = typeTriple.part1 |> typeMapVariables variableMap
                , part2 = typeTriple.part2 |> typeMapVariables variableMap
                }

        TypeRecord typeRecordFields ->
            TypeRecord
                (typeRecordFields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> typeMapVariables variableMap
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable =
                    typeRecordExtension.recordVariable
                        |> variableMap
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> typeMapVariables variableMap
                            )
                }

        TypeFunction typeFunction ->
            TypeFunction
                { input = typeFunction.input |> typeMapVariables variableMap
                , output = typeFunction.output |> typeMapVariables variableMap
                }


{-| How to map names and symbols used in a module to their origin module.
Create with [`importsToModuleOriginLookup`](#importsToModuleOriginLookup).

Contains variants, type alias names, choice type names, port names, value/function declaration names
and whether `(|.)` and or `(|=)` are imported from `Parser.Advanced`.

Also contains locally declared names when available.

Type- and expression/pattern-level members
are separated since you can for example have a local `List` variant
while also using an (implicitly) imported `List` type.

-}
type alias ModuleOriginLookup =
    { references :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , typeConstructs :
        FastDict.Dict
            ( Elm.Syntax.ModuleName.ModuleName, String )
            Elm.Syntax.ModuleName.ModuleName
    , keepOperatorIsExposedFromParserAdvanced : Bool
    , ignoreOperatorIsExposedFromParserAdvanced : Bool
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed [`ModuleTypes`](#ModuleTypes)
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleOriginLookup :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleOriginLookup
importsToModuleOriginLookup modulesTypes imports =
    let
        importsNormal :
            List
                { moduleName : Elm.Syntax.ModuleName.ModuleName
                , alias : Maybe String
                , typeExposes : List String
                , referenceExposes : List String
                }
        importsNormal =
            implicitImports
                ++ (imports
                        |> List.map
                            (\(Elm.Syntax.Node.Node _ syntaxImport) ->
                                let
                                    importModuleName : Elm.Syntax.ModuleName.ModuleName
                                    importModuleName =
                                        syntaxImport.moduleName |> Elm.Syntax.Node.value
                                in
                                { moduleName = importModuleName
                                , alias =
                                    syntaxImport.moduleAlias
                                        |> Maybe.map
                                            (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                                                syntaxAlias |> String.join "."
                                            )
                                , typeExposes =
                                    case syntaxImport.exposingList of
                                        Nothing ->
                                            []

                                        Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                            case modulesTypes |> FastDict.get importModuleName of
                                                Nothing ->
                                                    []

                                                Just moduleTypes ->
                                                    case syntaxExposing of
                                                        Elm.Syntax.Exposing.All _ ->
                                                            (moduleTypes.typeAliases |> FastDict.keys)
                                                                ++ (moduleTypes.choiceTypes
                                                                        |> FastDict.foldl
                                                                            (\choiceTypeName _ soFar ->
                                                                                choiceTypeName :: soFar
                                                                            )
                                                                            []
                                                                   )

                                                        Elm.Syntax.Exposing.Explicit exposes ->
                                                            exposes
                                                                |> List.concatMap
                                                                    (\(Elm.Syntax.Node.Node _ expose) ->
                                                                        case expose of
                                                                            Elm.Syntax.Exposing.InfixExpose _ ->
                                                                                []

                                                                            Elm.Syntax.Exposing.FunctionExpose _ ->
                                                                                []

                                                                            Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                                                [ name ]

                                                                            Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                [ choiceTypeExpose.name ]
                                                                    )
                                , referenceExposes =
                                    case syntaxImport.exposingList of
                                        Nothing ->
                                            []

                                        Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                            case modulesTypes |> FastDict.get importModuleName of
                                                Nothing ->
                                                    []

                                                Just moduleTypes ->
                                                    case syntaxExposing of
                                                        Elm.Syntax.Exposing.All _ ->
                                                            (moduleTypes.signatures |> FastDict.keys)
                                                                ++ (moduleTypes.typeAliases
                                                                        |> FastDict.foldl
                                                                            (\typeAliasName info soFar ->
                                                                                case info.recordFieldOrder of
                                                                                    Nothing ->
                                                                                        soFar

                                                                                    Just _ ->
                                                                                        typeAliasName :: soFar
                                                                            )
                                                                            []
                                                                   )
                                                                ++ (moduleTypes.choiceTypes
                                                                        |> FastDict.foldl
                                                                            (\_ choiceTypeInfo soFar ->
                                                                                (choiceTypeInfo.variants |> FastDict.keys)
                                                                                    ++ soFar
                                                                            )
                                                                            []
                                                                   )

                                                        Elm.Syntax.Exposing.Explicit exposes ->
                                                            exposes
                                                                |> List.concatMap
                                                                    (\(Elm.Syntax.Node.Node _ expose) ->
                                                                        case expose of
                                                                            Elm.Syntax.Exposing.TypeOrAliasExpose _ ->
                                                                                []

                                                                            Elm.Syntax.Exposing.InfixExpose operator ->
                                                                                [ operator ]

                                                                            Elm.Syntax.Exposing.FunctionExpose name ->
                                                                                [ name ]

                                                                            Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                case choiceTypeExpose.open of
                                                                                    Nothing ->
                                                                                        []

                                                                                    Just _ ->
                                                                                        case moduleTypes.choiceTypes |> FastDict.get choiceTypeExpose.name of
                                                                                            Nothing ->
                                                                                                []

                                                                                            Just choiceTypeDeclared ->
                                                                                                choiceTypeDeclared.variants |> FastDict.keys
                                                                    )
                                }
                            )
                   )
                |> importsCombine

        operatorIsExposedFromParserAdvanced : String -> Bool
        operatorIsExposedFromParserAdvanced operator =
            importsNormal
                |> List.any
                    (\syntaxImport ->
                        (case syntaxImport.moduleName of
                            [ "Parser", "Advanced" ] ->
                                True

                            _ ->
                                False
                        )
                            && (syntaxImport.referenceExposes
                                    |> List.any
                                        (\syntaxExpose ->
                                            (syntaxExpose == operator)
                                                || (syntaxExpose == ("(" ++ operator ++ ")"))
                                        )
                               )
                    )
    in
    { references =
        importsNormal
            |> List.foldl
                (\syntaxImport soFar ->
                    case modulesTypes |> FastDict.get syntaxImport.moduleName of
                        Nothing ->
                            soFar

                        Just moduleTypes ->
                            let
                                exposedFromImportedModuleItself : List String
                                exposedFromImportedModuleItself =
                                    (moduleTypes.signatures |> FastDict.keys)
                                        ++ (moduleTypes.choiceTypes
                                                |> FastDict.foldl
                                                    (\_ choiceType variantNamesSoFar ->
                                                        (choiceType.variants |> FastDict.keys)
                                                            ++ variantNamesSoFar
                                                    )
                                                    []
                                           )
                            in
                            FastDict.union
                                (FastDict.union
                                    (syntaxImport.referenceExposes
                                        |> listMapToFastDict
                                            (\expose ->
                                                { key = ( [], expose )
                                                , value = syntaxImport.moduleName
                                                }
                                            )
                                    )
                                    (case syntaxImport.alias of
                                        Nothing ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( syntaxImport.moduleName, exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )

                                        Just importAlias ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( [ importAlias ], exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )
                                    )
                                )
                                soFar
                )
                FastDict.empty
    , typeConstructs =
        importsNormal
            |> List.foldl
                (\syntaxImport soFar ->
                    case modulesTypes |> FastDict.get syntaxImport.moduleName of
                        Nothing ->
                            soFar

                        Just moduleTypes ->
                            let
                                exposedFromImportedModuleItself : List String
                                exposedFromImportedModuleItself =
                                    (moduleTypes.typeAliases |> FastDict.keys)
                                        ++ (moduleTypes.choiceTypes
                                                |> FastDict.foldl
                                                    (\choiceTypeName _ variantNamesSoFar ->
                                                        choiceTypeName :: variantNamesSoFar
                                                    )
                                                    []
                                           )
                            in
                            FastDict.union
                                (FastDict.union
                                    (syntaxImport.typeExposes
                                        |> listMapToFastDict
                                            (\expose ->
                                                { key = ( [], expose )
                                                , value = syntaxImport.moduleName
                                                }
                                            )
                                    )
                                    (case syntaxImport.alias of
                                        Nothing ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( syntaxImport.moduleName, exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )

                                        Just importAlias ->
                                            exposedFromImportedModuleItself
                                                |> listMapToFastDict
                                                    (\exposeFromImportedModule ->
                                                        { key = ( [ importAlias ], exposeFromImportedModule )
                                                        , value = syntaxImport.moduleName
                                                        }
                                                    )
                                    )
                                )
                                soFar
                )
                FastDict.empty
    , keepOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|."
    , ignoreOperatorIsExposedFromParserAdvanced =
        operatorIsExposedFromParserAdvanced "|="
    }


implicitImports :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
implicitImports =
    [ { moduleName = [ "Basics" ]
      , alias = Nothing
      , typeExposes = [ "Int", "Float", "Order", "Bool", "Never" ]
      , referenceExposes =
            [ "(+)"
            , "(-)"
            , "(*)"
            , "(/)"
            , "(//)"
            , "(^)"
            , "toFloat"
            , "round"
            , "floor"
            , "ceiling"
            , "truncate"
            , "(==)"
            , "(/=)"
            , "(<)"
            , "(>)"
            , "(<=)"
            , "(>=)"
            , "max"
            , "min"
            , "compare"
            , "LT"
            , "EQ"
            , "GT"
            , "True"
            , "False"
            , "not"
            , "(&&)"
            , "(||)"
            , "xor"
            , "(++)"
            , "modBy"
            , "remainderBy"
            , "negate"
            , "abs"
            , "clamp"
            , "sqrt"
            , "logBase"
            , "e"
            , "pi"
            , "cos"
            , "sin"
            , "tan"
            , "acos"
            , "asin"
            , "atan"
            , "atan2"
            , "degrees"
            , "radians"
            , "turns"
            , "toPolar"
            , "fromPolar"
            , "isNaN"
            , "isInfinite"
            , "identity"
            , "always"
            , "(<|)"
            , "(|>)"
            , "(<<)"
            , "(>>)"
            , "never"
            ]
      }
    , { moduleName = [ "List" ], alias = Nothing, typeExposes = [ "List" ], referenceExposes = [ "(::)" ] }
    , { moduleName = [ "Maybe" ], alias = Nothing, typeExposes = [ "Maybe" ], referenceExposes = [ "Just", "Nothing" ] }
    , { moduleName = [ "Result" ], alias = Nothing, typeExposes = [ "Result" ], referenceExposes = [ "Ok", "Err" ] }
    , { moduleName = [ "String" ], alias = Nothing, typeExposes = [ "String" ], referenceExposes = [] }
    , { moduleName = [ "Char" ], alias = Nothing, typeExposes = [ "Char" ], referenceExposes = [] }
    , { moduleName = [ "Tuple" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Debug" ], alias = Nothing, typeExposes = [], referenceExposes = [] }
    , { moduleName = [ "Platform" ], alias = Nothing, typeExposes = [ "Program" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Cmd" ], alias = Just "Cmd", typeExposes = [ "Cmd" ], referenceExposes = [] }
    , { moduleName = [ "Platform", "Sub" ], alias = Just "Sub", typeExposes = [ "Sub" ], referenceExposes = [] }
    ]


importsCombine :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
    ->
        List
            { moduleName : Elm.Syntax.ModuleName.ModuleName
            , alias : Maybe String
            , typeExposes : List String
            , referenceExposes : List String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importsMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importsMerge :
    { moduleName : Elm.Syntax.ModuleName.ModuleName
    , alias : Maybe String
    , typeExposes : List String
    , referenceExposes : List String
    }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
    ->
        { moduleName : Elm.Syntax.ModuleName.ModuleName
        , alias : Maybe String
        , typeExposes : List String
        , referenceExposes : List String
        }
importsMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , typeExposes =
        exposingCombine earlier.typeExposes later.typeExposes
    , referenceExposes =
        exposingCombine earlier.referenceExposes later.referenceExposes
    }


exposingCombine : List String -> List String -> List String
exposingCombine a b =
    a ++ b |> exposeListToNormal


exposeListToNormal :
    List String
    -> List String
exposeListToNormal syntaxExposeList =
    syntaxExposeList
        |> List.sort
        |> exposesCombine


exposesCombine : List String -> List String
exposesCombine syntaxExposes =
    exposesCombineFrom [] syntaxExposes


exposesCombineFrom : List String -> List String -> List String
exposesCombineFrom soFar syntaxExposes =
    case syntaxExposes of
        [] ->
            soFar

        [ onlyExpose ] ->
            onlyExpose :: soFar

        expose0 :: expose1 :: expose2Up ->
            case Basics.compare expose0 expose1 of
                EQ ->
                    exposesCombineFrom soFar (expose0 :: expose2Up)

                LT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)

                GT ->
                    exposesCombineFrom (expose0 :: soFar) (expose1 :: expose2Up)


syntaxToType :
    ModuleOriginLookup
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Result String (Type String)
syntaxToType moduleOriginLookup syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Ok (TypeNotVariable TypeUnit)

        Elm.Syntax.TypeAnnotation.GenericType variableName ->
            Ok (TypeVariable variableName)

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( qualification, unqualifiedName )) argumentNodes ->
            case moduleOriginLookup.typeConstructs |> FastDict.get ( qualification, unqualifiedName ) of
                Nothing ->
                    Err
                        (case qualification of
                            [] ->
                                "could not find imported/local declaration for "
                                    ++ unqualifiedName

                            qualificationPart0 :: qualificationPart1Up ->
                                "could not find imported declaration for "
                                    ++ qualifiedToString
                                        { qualification = qualificationPart0 :: qualificationPart1Up
                                        , name = unqualifiedName
                                        }
                        )

                Just originModule ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = originModule
                                    , name = unqualifiedName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentNodes
                            |> listMapAndCombineOk
                                (\(Elm.Syntax.Node.Node _ argument) ->
                                    argument |> syntaxToType moduleOriginLookup
                                )
                        )

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [] ->
                    Err "empty tuple"

                [ Elm.Syntax.Node.Node _ inParens ] ->
                    inParens |> syntaxToType moduleOriginLookup

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)

                [ Elm.Syntax.Node.Node _ syntaxPart0, Elm.Syntax.Node.Node _ syntaxPart1, Elm.Syntax.Node.Node _ syntaxPart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (syntaxPart0 |> syntaxToType moduleOriginLookup)
                        (syntaxPart1 |> syntaxToType moduleOriginLookup)
                        (syntaxPart2 |> syntaxToType moduleOriginLookup)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.TypeAnnotation.Record recordFields ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (recordFields
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariableName) (Elm.Syntax.Node.Node _ recordExtensionFields) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable = recordVariableName
                            , fields = fields
                            }
                        )
                )
                (recordExtensionFields
                    |> listFoldlWhileOkFrom
                        FastDict.empty
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, Elm.Syntax.Node.Node _ fieldValue )) soFar ->
                            Result.map
                                (\fieldValueType ->
                                    soFar |> FastDict.insert fieldName fieldValueType
                                )
                                (fieldValue |> syntaxToType moduleOriginLookup)
                        )
                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation (Elm.Syntax.Node.Node _ syntaxInput) (Elm.Syntax.Node.Node _ syntaxOutput) ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (syntaxInput |> syntaxToType moduleOriginLookup)
                (syntaxOutput |> syntaxToType moduleOriginLookup)


qualifiedToString :
    { qualification : Elm.Syntax.ModuleName.ModuleName, name : String }
    -> String
qualifiedToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationUntilDot :: qualificationAfterDot ->
            ((qualificationUntilDot :: qualificationAfterDot)
                |> String.join "."
            )
                ++ "."
                ++ reference.name


typeSubstituteVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : Type TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariable declarationTypes replacement type_ =
    case replacement.type_ of
        TypeVariable argumentVariable ->
            Ok
                { type_ =
                    type_
                        |> typeMapVariables
                            (\variable ->
                                if variable == replacement.variable then
                                    argumentVariable

                                else
                                    variable
                            )
                , substitutions = variableSubstitutionsNone
                }

        TypeNotVariable argumentNotVariable ->
            type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    { variable = replacement.variable
                    , type_ = argumentNotVariable
                    }


typeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> Type TypeVariableFromContext
    ->
        Result
            String
            (Type
                TypeVariableFromContext
            )
typeApplyVariableSubstitutions declarationTypes substitutions originalType =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            typeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (originalType
                                    |> typeMapVariables
                                        (\originalVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalVariable
                                                |> Maybe.withDefault originalVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok originalType

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        originalType
                            |> typeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok typeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            typeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            typeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                typeWithVariableToTypeSubstitutionApplied.type_


typeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeSubstituteVariableByNotVariable declarationTypes replacement type_ =
    -- IGNORE TCO
    case type_ of
        TypeVariable typeVariable ->
            if typeVariable == replacement.variable then
                case replacement.variable |> typeVariableIgnoringContext |> typeVariableConstraint of
                    Nothing ->
                        Ok
                            { type_ = TypeNotVariable replacement.type_
                            , substitutions = variableSubstitutionsNone
                            }

                    Just constraint ->
                        case constraint of
                            TypeVariableConstraintNumber ->
                                if replacement.type_ |> typeNotVariableIsNumber then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err
                                        ("cannot unify number type variable with types other than Int/Float, found: "
                                            ++ (replacement.type_ |> typeNotVariableToInfoString)
                                        )

                            TypeVariableConstraintAppendable ->
                                if replacement.type_ |> typeNotVariableIsAppendable then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify appendable type variable with types other than String/List _"

                            TypeVariableConstraintComparable ->
                                if replacement.type_ |> typeNotVariableIsComparable (\var -> var |> typeVariableIgnoringContext |> typeVariableConstraint) then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify comparable type variable with types other than Int/Float/String/Time.Posix/List of comparable/tuple of comparables/triple of comparable"

                            TypeVariableConstraintCompappend ->
                                if replacement.type_ |> typeNotVariableIsCompappend (\var -> var |> typeVariableIgnoringContext |> typeVariableConstraint) then
                                    Ok
                                        { type_ = TypeNotVariable replacement.type_
                                        , substitutions = variableSubstitutionsNone
                                        }

                                else
                                    Err "cannot unify compappend type variable with types other than String/List of comparable"

            else
                Ok
                    { type_ = TypeVariable typeVariable
                    , substitutions = variableSubstitutionsNone
                    }

        TypeNotVariable typeNotVariable ->
            Result.map
                (\typeAndSubstitutions ->
                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                    , substitutions = typeAndSubstitutions.substitutions
                    }
                )
                (typeNotVariable
                    |> typeNotVariableSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


typeToInfoString : Type TypeVariableFromContext -> String
typeToInfoString type_ =
    case type_ of
        TypeVariable typeVariable ->
            typeVariable |> typeVariableFromContextToInfoString

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableToInfoString


typeVariableFromContextToInfoString : TypeVariableFromContext -> String
typeVariableFromContextToInfoString ( context, variable ) =
    variable ++ "_" ++ (context |> String.join "_")


typeNotVariableToInfoString : TypeNotVariable TypeVariableFromContext -> String
typeNotVariableToInfoString typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typeToInfoString)
                ++ " -> "
                ++ (typeFunction.output |> typeToInfoString)
                ++ ")"

        TypeConstruct typeConstruct ->
            let
                typeReferenceAsString : String
                typeReferenceAsString =
                    qualifiedToString
                        { qualification = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
            in
            case typeConstruct.arguments of
                [] ->
                    typeReferenceAsString

                argument0 :: argument1Up ->
                    "("
                        ++ typeReferenceAsString
                        ++ (argument0
                                :: argument1Up
                                |> List.map (\argument -> " " ++ (argument |> typeToInfoString))
                                |> String.concat
                           )
                        ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typeToInfoString)
                ++ ", "
                ++ (parts.part1 |> typeToInfoString)
                ++ ", "
                ++ (parts.part2 |> typeToInfoString)
                ++ " )"

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension recordExtension ->
            "{ "
                ++ (recordExtension.recordVariable |> typeVariableFromContextToInfoString)
                ++ (recordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( name, value ) ->
                                name ++ " : " ++ (value |> typeToInfoString)
                            )
                        |> String.join ", "
                   )
                ++ " }"


typeNotVariableSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableSubstituteVariableByNotVariable declarationTypes replacement typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            Ok
                { type_ = TypeUnit
                , substitutions = variableSubstitutionsNone
                }

        TypeConstruct typeChoiceConstruct ->
            Result.map
                (\argumentsSubstituted ->
                    { type_ =
                        TypeConstruct
                            { moduleOrigin = typeChoiceConstruct.moduleOrigin
                            , name = typeChoiceConstruct.name
                            , arguments =
                                argumentsSubstituted.argumentsReverse
                                    |> List.reverse
                            }
                    , substitutions = argumentsSubstituted.substitutions
                    }
                )
                (typeChoiceConstruct.arguments
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , argumentsReverse = []
                        }
                        (\argument soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithArgument ->
                                            { argumentsReverse =
                                                argumentSubstituted.type_
                                                    :: soFar.argumentsReverse
                                            , substitutions = substitutionsWithArgument
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argument
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeTuple typeTuple ->
            resultAndThen2
                (\part0Substituted part1Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTuple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (typeTuple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTuple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeTriple typeTriple ->
            resultAndThen3
                (\part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\substitutionsPart01 ->
                            { type_ =
                                TypeTriple
                                    { part0 = part0Substituted.type_
                                    , part1 = part1Substituted.type_
                                    , part2 = part2Substituted.type_
                                    }
                            , substitutions = substitutionsPart01
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (typeTriple.part0
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part1
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeTriple.part2
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        TypeRecord typeRecordFields ->
            Result.map
                (\fieldsSubstituted ->
                    { substitutions = fieldsSubstituted.substitutions
                    , type_ = TypeRecord fieldsSubstituted.types
                    }
                )
                (typeRecordFields
                    |> fastDictFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , types = FastDict.empty
                        }
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            valueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            Result.andThen
                (\fieldsSubstituted ->
                    if typeRecordExtension.recordVariable /= replacement.variable then
                        Ok
                            { substitutions = fieldsSubstituted.substitutions
                            , type_ =
                                TypeRecordExtension
                                    { recordVariable = typeRecordExtension.recordVariable
                                    , fields = fieldsSubstituted.types
                                    }
                            }

                    else
                        case replacement.type_ of
                            TypeRecord replacementRecordFields ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ = TypeRecord fieldsMerged.types
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types = soFar.types |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    valueUnified.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordFields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            TypeRecordExtension replacementRecordExtension ->
                                Result.map
                                    (\fieldsMerged ->
                                        { substitutions = fieldsMerged.substitutions
                                        , type_ =
                                            TypeRecordExtension
                                                { recordVariable = replacementRecordExtension.recordVariable
                                                , fields = fieldsMerged.types
                                                }
                                        }
                                    )
                                    (FastDict.merge
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        (\name valueSubstituted valueReplacement soFarOrError ->
                                            Result.andThen
                                                (\soFar ->
                                                    Result.andThen
                                                        (\valueUnified ->
                                                            Result.map
                                                                (\fullSubstitutions ->
                                                                    { substitutions = fullSubstitutions
                                                                    , types = soFar.types |> FastDict.insert name valueUnified.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge declarationTypes
                                                                    valueUnified.substitutions
                                                                    soFar.substitutions
                                                                )
                                                        )
                                                        (typeUnify declarationTypes
                                                            valueSubstituted
                                                            valueReplacement
                                                        )
                                                )
                                                soFarOrError
                                        )
                                        (\name value soFarOrError ->
                                            Result.map
                                                (\soFar ->
                                                    { substitutions = soFar.substitutions
                                                    , types = soFar.types |> FastDict.insert name value
                                                    }
                                                )
                                                soFarOrError
                                        )
                                        fieldsSubstituted.types
                                        replacementRecordExtension.fields
                                        (Ok
                                            { substitutions = fieldsSubstituted.substitutions
                                            , types = FastDict.empty
                                            }
                                        )
                                    )

                            TypeUnit ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeConstruct _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeTuple _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeTriple _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"

                            TypeFunction _ ->
                                Err "cannot unify record extension type variable with types other than record/record extension"
                )
                (typeRecordExtension.fields
                    |> fastDictFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , types = FastDict.empty
                        }
                        (\fieldName fieldValue soFar ->
                            Result.andThen
                                (\valueSubstituted ->
                                    Result.map
                                        (\substitutionsWithValue ->
                                            { substitutions = substitutionsWithValue
                                            , types =
                                                soFar.types
                                                    |> FastDict.insert fieldName valueSubstituted.type_
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            soFar.substitutions
                                            valueSubstituted.substitutions
                                        )
                                )
                                (fieldValue
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        TypeFunction typeFunction ->
            resultAndThen2
                (\inputSubstituted outputSubstituted ->
                    Result.map
                        (\substitutionsInputOutput ->
                            { type_ =
                                TypeFunction
                                    { input = inputSubstituted.type_
                                    , output = outputSubstituted.type_
                                    }
                            , substitutions = substitutionsInputOutput
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            inputSubstituted.substitutions
                            outputSubstituted.substitutions
                        )
                )
                (typeFunction.input
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (typeFunction.output
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


typeNotVariableIsNumber : TypeNotVariable variable_ -> Bool
typeNotVariableIsNumber type_ =
    case type_ of
        TypeConstruct typeConstruct ->
            case typeConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case typeConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                _ ->
                    False

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeNotVariableIsAppendable : TypeNotVariable variable_ -> Bool
typeNotVariableIsAppendable type_ =
    case type_ of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            True

                        _ ->
                            False

                _ ->
                    False

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeNotVariableIsComparable :
    (variable -> Maybe TypeVariableConstraint)
    -> TypeNotVariable variable
    -> Bool
typeNotVariableIsComparable typeVariableToConstraint typeNotVariable =
    -- IGNORE TCO
    case typeNotVariable of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "String" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "Basics" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "Int" ->
                            True

                        "Float" ->
                            True

                        _ ->
                            False

                [ "Time" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "Posix" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            variableReplacementTypeChoiceConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument |> typeIsComparable typeVariableToConstraint
                                    )

                        _ ->
                            False

                _ ->
                    False

        TypeTuple typeTuple ->
            (typeTuple.part0 |> typeIsComparable typeVariableToConstraint)
                && (typeTuple.part1 |> typeIsComparable typeVariableToConstraint)

        TypeTriple typeTriple ->
            (typeTriple.part0 |> typeIsComparable typeVariableToConstraint)
                && (typeTriple.part1 |> typeIsComparable typeVariableToConstraint)
                && (typeTriple.part2 |> typeIsComparable typeVariableToConstraint)

        TypeUnit ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsComparable :
    (variable -> Maybe TypeVariableConstraint)
    -> Type variable
    -> Bool
typeIsComparable typeVariableToConstraint type_ =
    case type_ of
        TypeVariable typeVariable ->
            case typeVariable |> typeVariableToConstraint of
                Nothing ->
                    False

                Just TypeVariableConstraintAppendable ->
                    True

                Just TypeVariableConstraintCompappend ->
                    True

                Just TypeVariableConstraintComparable ->
                    True

                Just TypeVariableConstraintNumber ->
                    True

        TypeNotVariable typeNotVariable ->
            typeNotVariable |> typeNotVariableIsComparable typeVariableToConstraint


typeNotVariableIsCompappend :
    (variable -> Maybe TypeVariableConstraint)
    -> TypeNotVariable variable
    -> Bool
typeNotVariableIsCompappend typeVariableToConstraint type_ =
    -- IGNORE TCO
    case type_ of
        TypeConstruct variableReplacementTypeChoiceConstruct ->
            case variableReplacementTypeChoiceConstruct.moduleOrigin of
                [ "Basics" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "String" ->
                            True

                        _ ->
                            False

                [ "List" ] ->
                    case variableReplacementTypeChoiceConstruct.name of
                        "List" ->
                            variableReplacementTypeChoiceConstruct.arguments
                                |> List.all
                                    (\argument ->
                                        argument |> typeIsComparable typeVariableToConstraint
                                    )

                        _ ->
                            False

                _ ->
                    False

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


{-| All you need to turn a generic type with variables
into a concrete type with all the info we've inferred already.

While variable types in context get passed down,
variable substitutions get passed all the way to the top and only get processed there.

-}
type alias VariableSubstitutions =
    { equivalentVariables :
        List (FastSet.Set TypeVariableFromContext)
    , variableToType :
        FastDict.Dict
            TypeVariableFromContext
            (TypeNotVariable TypeVariableFromContext)
    }


variableSubstitutionsNone : VariableSubstitutions
variableSubstitutionsNone =
    { equivalentVariables = []
    , variableToType = FastDict.empty
    }


variableSubstitutionsMerge :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge declarationTypes a b =
    -- IGNORE TCO
    FastDict.merge
        (\variable aType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable aType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        (\variable aType bType soFarOrError ->
            Result.andThen
                (\soFar ->
                    Result.andThen
                        (\abTypesUnified ->
                            Result.map
                                (\substitutionsWithAB ->
                                    case abTypesUnified.type_ of
                                        TypeVariable abUnifiedVariable ->
                                            { equivalentVariables =
                                                substitutionsWithAB.equivalentVariables
                                                    |> equivalentVariablesMergeWithSetOf2
                                                        variable
                                                        abUnifiedVariable
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                            }

                                        TypeNotVariable abUnifiedNotVariable ->
                                            { equivalentVariables = substitutionsWithAB.equivalentVariables
                                            , variableToType =
                                                substitutionsWithAB.variableToType
                                                    |> FastDict.insert variable abUnifiedNotVariable
                                            }
                                )
                                (variableSubstitutionsMerge declarationTypes
                                    soFar
                                    abTypesUnified.substitutions
                                )
                        )
                        (typeNotVariableUnify declarationTypes aType bType)
                )
                soFarOrError
        )
        (\variable bType soFarOrError ->
            Result.map
                (\soFar ->
                    { variableToType =
                        soFar.variableToType
                            |> FastDict.insert variable bType
                    , equivalentVariables =
                        soFar.equivalentVariables
                    }
                )
                soFarOrError
        )
        a.variableToType
        b.variableToType
        (Ok
            { variableToType = FastDict.empty
            , equivalentVariables =
                equivalentVariableSetMerge
                    a.equivalentVariables
                    b.equivalentVariables
            }
        )


variableSubstitutionsMerge3 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge3 declarationTypes a b c =
    variableSubstitutionsMerge
        declarationTypes
        a
        b
        |> Result.andThen
            (\abSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abSubstitutions
                    c
            )


variableSubstitutionsMerge4 :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> VariableSubstitutions
    -> Result String VariableSubstitutions
variableSubstitutionsMerge4 declarationTypes a b c d =
    variableSubstitutionsMerge3
        declarationTypes
        a
        b
        c
        |> Result.andThen
            (\abcSubstitutions ->
                variableSubstitutionsMerge
                    declarationTypes
                    abcSubstitutions
                    d
            )


equivalentVariablesMergeWithSetOf2 :
    comparable
    -> comparable
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariablesMergeWithSetOf2 aEquivalentVariable bEquivalentVariable equivalentVariables =
    equivalentVariablesMergeWithSetOf2Into [] aEquivalentVariable bEquivalentVariable equivalentVariables


equivalentVariablesMergeWithSetOf2Into :
    List (FastSet.Set comparable)
    -> comparable
    -> comparable
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariablesMergeWithSetOf2Into soFar aEquivalentVariable bEquivalentVariable equivalentVariables =
    case equivalentVariables of
        [] ->
            (FastSet.singleton aEquivalentVariable
                |> FastSet.insert bEquivalentVariable
            )
                :: soFar

        equivalentVariablesSet0 :: equivalentVariablesSet1Up ->
            if
                (equivalentVariablesSet0 |> FastSet.member aEquivalentVariable)
                    || (equivalentVariablesSet0 |> FastSet.member bEquivalentVariable)
            then
                (equivalentVariablesSet0
                    |> FastSet.insert aEquivalentVariable
                    |> FastSet.insert bEquivalentVariable
                )
                    :: soFar
                    ++ equivalentVariablesSet1Up

            else
                equivalentVariablesMergeWithSetOf2Into
                    (equivalentVariablesSet0 :: soFar)
                    aEquivalentVariable
                    bEquivalentVariable
                    equivalentVariablesSet1Up


equivalentVariableSetMerge :
    List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
    -> List (FastSet.Set comparable)
equivalentVariableSetMerge a b =
    let
        mergedIntoA :
            { sets : List (FastSet.Set comparable)
            , bRemaining : List (FastSet.Set comparable)
            }
        mergedIntoA =
            a
                |> List.foldl
                    (\aEquivalentVariableSet soFar ->
                        case
                            soFar.bRemaining
                                |> listMapAndFirstJustAndRemainingAnyOrder
                                    (\bEquivalentVariableSet ->
                                        if fastSetShareElements aEquivalentVariableSet bEquivalentVariableSet then
                                            Just bEquivalentVariableSet

                                        else
                                            Nothing
                                    )
                        of
                            Nothing ->
                                { sets = aEquivalentVariableSet :: soFar.sets
                                , bRemaining = soFar.bRemaining
                                }

                            Just bEquivalentVariableSetAndRemaining ->
                                { sets =
                                    FastSet.union aEquivalentVariableSet bEquivalentVariableSetAndRemaining.value
                                        :: soFar.sets
                                , bRemaining = bEquivalentVariableSetAndRemaining.remaining
                                }
                    )
                    { sets = [], bRemaining = b }
    in
    mergedIntoA.sets
        ++ mergedIntoA.bRemaining


fastSetShareElements : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetShareElements a b =
    FastSet.intersect a b /= FastSet.empty


listMapAndFirstJustAndRemainingAnyOrder :
    (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAnyOrder elementToMaybe list =
    listMapAndFirstJustAndRemainingAndOrderWithBefore [] elementToMaybe list


listMapAndFirstJustAndRemainingAndOrderWithBefore :
    List a
    -> (a -> Maybe value)
    -> List a
    ->
        Maybe
            { value : value
            , remaining : List a
            }
listMapAndFirstJustAndRemainingAndOrderWithBefore elementsBeforeReverse elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybe of
                Just headValue ->
                    Just
                        { value = headValue
                        , remaining =
                            (elementsBeforeReverse |> List.reverse)
                                ++ tail
                        }

                Nothing ->
                    listMapAndFirstJustAndRemainingAndOrderWithBefore
                        (head :: elementsBeforeReverse)
                        elementToMaybe
                        tail


listFilledMapAndTypesUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> (a -> Type TypeVariableFromContext)
    -> ( a, List a )
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
listFilledMapAndTypesUnify declarationTypes elementToType ( head, tail ) =
    tail
        |> listFoldlWhileOkFrom
            { type_ = head |> elementToType
            , substitutions = variableSubstitutionsNone
            }
            (\element soFar ->
                Result.andThen
                    (\soFarTypeUnifiedWithElement ->
                        Result.map
                            (\substitutionsSoFarWithElement ->
                                { type_ = soFarTypeUnifiedWithElement.type_
                                , substitutions = substitutionsSoFarWithElement
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                soFarTypeUnifiedWithElement.substitutions
                            )
                    )
                    (typeUnify declarationTypes
                        soFar.type_
                        (element |> elementToType)
                    )
            )


typeUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type TypeVariableFromContext
    -> Type TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeUnify declarationTypes a b =
    case a of
        TypeNotVariable aTypeNotVariable ->
            case b of
                TypeVariable bVariableName ->
                    Ok
                        { type_ = TypeNotVariable aTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton bVariableName
                                    aTypeNotVariable
                            , equivalentVariables = []
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    typeNotVariableUnify declarationTypes
                        aTypeNotVariable
                        bTypeNotVariable

        TypeVariable aVariable ->
            case b of
                TypeVariable bVariable ->
                    Ok
                        { type_ = TypeVariable aVariable
                        , substitutions =
                            { variableToType = FastDict.empty
                            , equivalentVariables =
                                [ FastSet.singleton aVariable
                                    |> FastSet.insert bVariable
                                ]
                            }
                        }

                TypeNotVariable bTypeNotVariable ->
                    Ok
                        { type_ = TypeNotVariable bTypeNotVariable
                        , substitutions =
                            { variableToType =
                                FastDict.singleton aVariable
                                    bTypeNotVariable
                            , equivalentVariables = []
                            }
                        }


typeNotVariableUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Result
            String
            { type_ : Type TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeNotVariableUnify declarationTypes a b =
    let
        maybeTypeConstructsWithSameName :
            Maybe
                { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                , name : String
                , aArguments : List (Type TypeVariableFromContext)
                , bArguments : List (Type TypeVariableFromContext)
                }
        maybeTypeConstructsWithSameName =
            case a of
                TypeConstruct aTypeConstruct ->
                    case b of
                        TypeConstruct bTypeConstruct ->
                            if
                                (aTypeConstruct.moduleOrigin
                                    == bTypeConstruct.moduleOrigin
                                )
                                    && (aTypeConstruct.name
                                            == bTypeConstruct.name
                                       )
                            then
                                Just
                                    { moduleOrigin = aTypeConstruct.moduleOrigin
                                    , name = aTypeConstruct.name
                                    , aArguments = aTypeConstruct.arguments
                                    , bArguments = bTypeConstruct.arguments
                                    }

                            else
                                Nothing

                        TypeUnit ->
                            Nothing

                        TypeTuple _ ->
                            Nothing

                        TypeTriple _ ->
                            Nothing

                        TypeRecord _ ->
                            Nothing

                        TypeRecordExtension _ ->
                            Nothing

                        TypeFunction _ ->
                            Nothing

                TypeUnit ->
                    Nothing

                TypeTuple _ ->
                    Nothing

                TypeTriple _ ->
                    Nothing

                TypeRecord _ ->
                    Nothing

                TypeRecordExtension _ ->
                    Nothing

                TypeFunction _ ->
                    Nothing

        maybeUnifiedWithTypeConstruct :
            Maybe
                (Result
                    String
                    { type_ : Type TypeVariableFromContext
                    , substitutions : VariableSubstitutions
                    }
                )
        maybeUnifiedWithTypeConstruct =
            case maybeTypeConstructsWithSameName of
                Just matchingTypeConstructs ->
                    Result.map
                        (\argumentsABUnified ->
                            { type_ =
                                TypeNotVariable
                                    (TypeConstruct
                                        { moduleOrigin = matchingTypeConstructs.moduleOrigin
                                        , name = matchingTypeConstructs.name
                                        , arguments =
                                            argumentsABUnified.argumentsReverse
                                                |> List.reverse
                                        }
                                    )
                            , substitutions = argumentsABUnified.substitutions
                            }
                        )
                        (List.map2
                            (\aArgument bArgument -> { a = aArgument, b = bArgument })
                            matchingTypeConstructs.aArguments
                            matchingTypeConstructs.bArguments
                            |> listFoldlWhileOkFrom
                                { argumentsReverse = []
                                , substitutions = variableSubstitutionsNone
                                }
                                (\ab soFar ->
                                    Result.andThen
                                        (\argumentTypeUnifiedAndSubstitutions ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { argumentsReverse =
                                                        argumentTypeUnifiedAndSubstitutions.type_
                                                            :: soFar.argumentsReverse
                                                    , substitutions =
                                                        substitutionsWithArgument
                                                    }
                                                )
                                                (variableSubstitutionsMerge
                                                    declarationTypes
                                                    argumentTypeUnifiedAndSubstitutions.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes ab.a ab.b)
                                )
                        )
                        |> Just

                Nothing ->
                    case typeUnifyWithTryToExpandTypeConstruct declarationTypes a b of
                        Just result ->
                            Just result

                        Nothing ->
                            typeUnifyWithTryToExpandTypeConstruct declarationTypes b a
    in
    case maybeUnifiedWithTypeConstruct of
        Just result ->
            result

        Nothing ->
            case a of
                TypeUnit ->
                    case b of
                        TypeUnit ->
                            Ok
                                { type_ = TypeNotVariable TypeUnit
                                , substitutions = variableSubstitutionsNone
                                }

                        TypeConstruct _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeTuple _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeTriple _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeRecord _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeRecordExtension _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                        TypeFunction _ ->
                            Err "unit (`()`) cannot be unified with types other than unit"

                TypeConstruct aTypeConstruct ->
                    let
                        aDescription : String
                        aDescription =
                            "choice type "
                                ++ qualifiedToString
                                    { qualification = aTypeConstruct.moduleOrigin
                                    , name = aTypeConstruct.name
                                    }
                    in
                    case b of
                        TypeUnit ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeConstruct _ ->
                            Err
                                (aDescription
                                    ++ " cannot be unified be with a choice type with a different name"
                                )

                        TypeTuple _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeTriple _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeRecord _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeRecordExtension _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                        TypeFunction _ ->
                            Err (aDescription ++ " cannot be unified with types other than choice type/type alias")

                TypeTuple aTuple ->
                    case b of
                        TypeTuple bTuple ->
                            resultAndThen2
                                (\part0ABUnified part1ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTuple.part0 bTuple.part0)
                                (typeUnify declarationTypes aTuple.part1 bTuple.part1)

                        TypeUnit ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeConstruct _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeTriple _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeRecord _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeRecordExtension _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                        TypeFunction _ ->
                            Err "tuple (`( ..., ... )`) cannot be unified with types other than tuple"

                TypeTriple aTriple ->
                    case b of
                        TypeTriple bTriple ->
                            resultAndThen3
                                (\part0ABUnified part1ABUnified part2ABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeTriple
                                                        { part0 = part0ABUnified.type_
                                                        , part1 = part1ABUnified.type_
                                                        , part2 = part2ABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            part0ABUnified.substitutions
                                            part1ABUnified.substitutions
                                            part2ABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aTriple.part0 bTriple.part0)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)
                                (typeUnify declarationTypes aTriple.part1 bTriple.part1)

                        TypeUnit ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeConstruct _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeTuple _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeRecord _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeRecordExtension _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                        TypeFunction _ ->
                            Err "triple (`( ..., ..., ... )`) cannot be unified with types other than triple"

                TypeRecord aRecord ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordUnify declarationTypes aRecord bRecord)

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    bRecordExtension
                                    aRecord
                                )

                        TypeUnit ->
                            Err "record cannot be unified with types other than record or record extension"

                        TypeConstruct _ ->
                            Err "record cannot be unified with types other than record or record extension"

                        TypeTuple _ ->
                            Err "record cannot be unified with types other than record or record extension"

                        TypeTriple _ ->
                            Err "record cannot be unified with types other than record or record extension"

                        TypeFunction _ ->
                            Err "record cannot be unified with types other than record or record extension"

                TypeRecordExtension aRecordExtension ->
                    case b of
                        TypeRecord bRecord ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecord declarationTypes
                                    aRecordExtension
                                    bRecord
                                )

                        TypeRecordExtension bRecordExtension ->
                            Result.map
                                (\typeAndSubstitutions ->
                                    { type_ = TypeNotVariable typeAndSubstitutions.type_
                                    , substitutions = typeAndSubstitutions.substitutions
                                    }
                                )
                                (typeRecordExtensionUnifyWithRecordExtension declarationTypes
                                    aRecordExtension
                                    bRecordExtension
                                )

                        TypeUnit ->
                            Err "record extension cannot be unified with types other than record or record extension"

                        TypeConstruct _ ->
                            Err "record extension cannot be unified with types other than record or record extension"

                        TypeTuple _ ->
                            Err "record extension cannot be unified with types other than record or record extension"

                        TypeTriple _ ->
                            Err "record extension cannot be unified with types other than record or record extension"

                        TypeFunction _ ->
                            Err "record extension cannot be unified with types other than record or record extension"

                TypeFunction aFunction ->
                    case b of
                        TypeFunction bFunction ->
                            resultAndThen2
                                (\inputABUnified outputABUnified ->
                                    Result.map
                                        (\substitutionsABMerged ->
                                            { type_ =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input = inputABUnified.type_
                                                        , output = outputABUnified.type_
                                                        }
                                                    )
                                            , substitutions = substitutionsABMerged
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            inputABUnified.substitutions
                                            outputABUnified.substitutions
                                        )
                                )
                                (typeUnify declarationTypes aFunction.input bFunction.input)
                                (typeUnify declarationTypes aFunction.output bFunction.output)

                        TypeUnit ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"

                        TypeConstruct _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"

                        TypeTuple _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"

                        TypeTriple _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"

                        TypeRecord _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"

                        TypeRecordExtension _ ->
                            Err "function (`... -> ...`) cannot be unified with types other than function"


typeUnifyWithTryToExpandTypeConstruct :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable TypeVariableFromContext
    -> TypeNotVariable TypeVariableFromContext
    ->
        Maybe
            (Result
                String
                { substitutions : VariableSubstitutions
                , type_ : Type TypeVariableFromContext
                }
            )
typeUnifyWithTryToExpandTypeConstruct declarationTypes toExpand b =
    case toExpand of
        TypeConstruct typeConstructToExpand ->
            case declarationTypes |> FastDict.get typeConstructToExpand.moduleOrigin of
                Nothing ->
                    Just
                        (Err
                            ("could not find declaration types in the origin module of the type construct "
                                ++ qualifiedToString
                                    { qualification = typeConstructToExpand.moduleOrigin
                                    , name = typeConstructToExpand.name
                                    }
                            )
                        )

                Just aOriginModuleTypes ->
                    case aOriginModuleTypes.typeAliases |> FastDict.get typeConstructToExpand.name of
                        Nothing ->
                            Nothing

                        Just originAliasDeclaration ->
                            Result.andThen
                                (\typeConstructExpandedWithArguments ->
                                    Result.andThen
                                        (\typeUnified ->
                                            Result.map
                                                (\fullSubstitutions ->
                                                    { substitutions = fullSubstitutions
                                                    , type_ = typeUnified.type_
                                                    }
                                                )
                                                (variableSubstitutionsMerge declarationTypes
                                                    typeConstructExpandedWithArguments.substitutions
                                                    typeUnified.substitutions
                                                )
                                        )
                                        (typeUnify declarationTypes
                                            typeConstructExpandedWithArguments.type_
                                            (TypeNotVariable b)
                                        )
                                )
                                (List.map2
                                    (\parameterName argument ->
                                        { variable = ( [], parameterName ), type_ = argument }
                                    )
                                    originAliasDeclaration.parameters
                                    typeConstructToExpand.arguments
                                    |> listFoldlWhileOkFrom
                                        { type_ =
                                            originAliasDeclaration.type_
                                                |> typeMapVariables (\aliasVariable -> ( [], aliasVariable ))
                                        , substitutions = variableSubstitutionsNone
                                        }
                                        (\substitution soFar ->
                                            Result.andThen
                                                (\typeSubstituted ->
                                                    Result.map
                                                        (\substitutionsAfterSubstitution ->
                                                            { type_ = typeSubstituted.type_
                                                            , substitutions = substitutionsAfterSubstitution
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge declarationTypes
                                                            typeSubstituted.substitutions
                                                            soFar.substitutions
                                                        )
                                                )
                                                (soFar.type_
                                                    |> typeSubstituteVariable declarationTypes
                                                        { variable = substitution.variable
                                                        , type_ = substitution.type_
                                                        }
                                                )
                                        )
                                )
                                |> Just

        TypeUnit ->
            Nothing

        TypeTuple _ ->
            Nothing

        TypeTriple _ ->
            Nothing

        TypeRecord _ ->
            Nothing

        TypeRecordExtension _ ->
            Nothing

        TypeFunction _ ->
            Nothing


typeRecordUnify :
    ModuleLevelDeclarationTypesAvailableInModule
    -> FastDict.Dict String (Type TypeVariableFromContext)
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordUnify declarationTypes aFields bFields =
    Result.map
        (\fieldsUnified ->
            { type_ = TypeRecord fieldsUnified.fieldsUnified
            , substitutions = fieldsUnified.substitutions
            }
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name _ _ ->
                Err
                    ("record with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            aFields
            bFields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


typeRecordExtensionUnifyWithRecord :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    -> FastDict.Dict String (Type TypeVariableFromContext)
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecord declarationTypes recordExtension recordFields =
    Result.andThen
        (\fieldsUnified ->
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecord fieldsUnified.fieldsUnified
                    }
                )
                (variableSubstitutionsMerge declarationTypes
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            recordExtension.recordVariable
                            (TypeRecord fieldsUnified.fieldsUnified)
                    }
                )
        )
        (FastDict.merge
            (\name _ _ ->
                Err
                    ("record extension with the field "
                        ++ name
                        ++ " cannot be unified with a record that does not have this field"
                    )
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            recordExtension.fields
            recordFields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


typeRecordExtensionUnifyWithRecordExtension :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        { recordVariable : TypeVariableFromContext
        , fields : FastDict.Dict String (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { type_ : TypeNotVariable TypeVariableFromContext
            , substitutions : VariableSubstitutions
            }
typeRecordExtensionUnifyWithRecordExtension declarationTypes aRecordExtension bRecordExtension =
    Result.andThen
        (\fieldsUnified ->
            let
                newBaseVariable : TypeVariableFromContext
                newBaseVariable =
                    let
                        ( aRecordVariableContext, aRecordVariableWithoutContext ) =
                            aRecordExtension.recordVariable
                    in
                    ( "base" :: aRecordVariableContext
                    , aRecordVariableWithoutContext
                    )
            in
            Result.map
                (\fullSubstitutions ->
                    { substitutions = fullSubstitutions
                    , type_ =
                        TypeRecordExtension
                            { recordVariable = newBaseVariable
                            , fields = fieldsUnified.fieldsUnified
                            }
                    }
                )
                (variableSubstitutionsMerge declarationTypes
                    fieldsUnified.substitutions
                    { equivalentVariables = []
                    , variableToType =
                        FastDict.singleton
                            aRecordExtension.recordVariable
                            (TypeRecordExtension
                                { recordVariable = newBaseVariable
                                , fields =
                                    FastDict.diff
                                        bRecordExtension.fields
                                        aRecordExtension.fields
                                }
                            )
                            |> FastDict.insert
                                bRecordExtension.recordVariable
                                (TypeRecordExtension
                                    { recordVariable = newBaseVariable
                                    , fields =
                                        FastDict.diff
                                            aRecordExtension.fields
                                            bRecordExtension.fields
                                    }
                                )
                    }
                )
        )
        (FastDict.merge
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            (\name aValue bValue soFarOrError ->
                resultAndThen2
                    (\abValueUnified soFar ->
                        Result.map
                            (\substitutionsWithField ->
                                { substitutions = substitutionsWithField
                                , fieldsUnified =
                                    soFar.fieldsUnified
                                        |> FastDict.insert name abValueUnified.type_
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                abValueUnified.substitutions
                                soFar.substitutions
                            )
                    )
                    (typeUnify declarationTypes aValue bValue)
                    soFarOrError
            )
            (\name value soFarOrError ->
                Result.map
                    (\soFar ->
                        { substitutions = soFar.substitutions
                        , fieldsUnified =
                            soFar.fieldsUnified
                                |> FastDict.insert name value
                        }
                    )
                    soFarOrError
            )
            aRecordExtension.fields
            bRecordExtension.fields
            (Ok
                { fieldsUnified = FastDict.empty
                , substitutions = variableSubstitutionsNone
                }
            )
        )


{-| A part in the syntax tree with an attached

  - [range](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Range#Range) in the source
  - global [`Type`](#Type): concretely inferred,
    influenced by other branches and value/function (let) declaration type annotations

Since type is a parameter, you can fill it with any representation
like [`Elm.Syntax.TypeAnnotation.TypeAnnotation`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-TypeAnnotation#TypeAnnotation)

-}
type alias TypedNode value type_ =
    { range : Elm.Syntax.Range.Range
    , value : value
    , type_ : type_
    }


{-| Like [`Elm.Syntax.Expression.Expression`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Expression)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Expression type_
    = ExpressionUnit
    | ExpressionInteger
        { base : Base10Or16
        , value : Int
        }
    | ExpressionFloat Float
    | ExpressionString String
    | ExpressionChar Char
    | ExpressionReference
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    | ExpressionOperatorFunction String
    | ExpressionRecordAccessFunction String
    | ExpressionNegation (TypedNode (Expression type_) type_)
    | ExpressionParenthesized (TypedNode (Expression type_) type_)
    | ExpressionTuple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        }
    | ExpressionTriple
        { part0 : TypedNode (Expression type_) type_
        , part1 : TypedNode (Expression type_) type_
        , part2 : TypedNode (Expression type_) type_
        }
    | ExpressionRecordAccess
        { record : TypedNode (Expression type_) type_
        , fieldNameRange : Elm.Syntax.Range.Range
        , fieldName : String
        }
    | ExpressionInfixOperation
        { symbol : String
        , left : TypedNode (Expression type_) type_
        , right : TypedNode (Expression type_) type_
        }
    | ExpressionIfThenElse
        { condition : TypedNode (Expression type_) type_
        , onTrue : TypedNode (Expression type_) type_
        , onFalse : TypedNode (Expression type_) type_
        }
    | ExpressionList (List (TypedNode (Expression type_) type_))
    | ExpressionCall
        { called : TypedNode (Expression type_) type_
        , argument0 : TypedNode (Expression type_) type_
        , argument1Up : List (TypedNode (Expression type_) type_)
        }
    | ExpressionRecord
        (List
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        )
    | ExpressionRecordUpdate
        { recordVariable :
            TypedNode
                { moduleOrigin :
                    -- `[]` for current module
                    Elm.Syntax.ModuleName.ModuleName
                , name : String
                }
                type_
        , field0 :
            { range : Elm.Syntax.Range.Range
            , name : String
            , nameRange : Elm.Syntax.Range.Range
            , value : TypedNode (Expression type_) type_
            }
        , field1Up :
            List
                { range : Elm.Syntax.Range.Range
                , name : String
                , nameRange : Elm.Syntax.Range.Range
                , value : TypedNode (Expression type_) type_
                }
        }
    | ExpressionLambda
        { parameter0 : TypedNode (Pattern type_) type_
        , parameter1Up : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionLetIn
        { declaration0 :
            { range : Elm.Syntax.Range.Range
            , declaration : LetDeclaration type_
            }
        , declaration1Up :
            List
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration type_
                }
        , result : TypedNode (Expression type_) type_
        }
    | ExpressionCaseOf
        { matchedExpression : TypedNode (Expression type_) type_
        , case0 :
            { pattern : TypedNode (Pattern type_) type_
            , result : TypedNode (Expression type_) type_
            }
        , case1Up :
            List
                { pattern : TypedNode (Pattern type_) type_
                , result : TypedNode (Expression type_) type_
                }
        }


{-| Like [`Elm.Syntax.Expression.LetDeclaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#LetDeclaration)
but its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type LetDeclaration type_
    = LetDestructuring
        { pattern : TypedNode (Pattern type_) type_
        , expression : TypedNode (Expression type_) type_
        }
    | LetValueOrFunctionDeclaration
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (TypedNode (Pattern type_) type_)
        , result : TypedNode (Expression type_) type_
        , type_ : type_
        }


{-| Like [`Elm.Syntax.Pattern.Pattern`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern#Pattern)
but all its sub-nodes are [`TypedNode`](#TypedNode)s
-}
type Pattern type_
    = PatternIgnored
    | PatternVariable String
    | PatternParenthesized (TypedNode (Pattern type_) type_)
    | PatternAs
        { pattern : TypedNode (Pattern type_) type_
        , variable : TypedNode String type_
        }
    | PatternUnit
    | PatternChar Char
    | PatternString String
    | PatternInt { base : Base10Or16, value : Int }
    | PatternTuple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        }
    | PatternTriple
        { part0 : TypedNode (Pattern type_) type_
        , part1 : TypedNode (Pattern type_) type_
        , part2 : TypedNode (Pattern type_) type_
        }
    | PatternRecord (List (TypedNode String type_))
    | PatternListCons
        { head : TypedNode (Pattern type_) type_
        , tail : TypedNode (Pattern type_) type_
        }
    | PatternListExact (List (TypedNode (Pattern type_) type_))
    | PatternVariant
        { moduleOrigin :
            -- `[]` for current module
            Elm.Syntax.ModuleName.ModuleName
        , qualification :
            -- `[]` for no qualification
            Elm.Syntax.ModuleName.ModuleName
        , name : String
        , values : List (TypedNode (Pattern type_) type_)
        }


{-| Either decimal or hexadecimal.
Used by [`PatternInt`](#Pattern) and [`ExpressionInteger`](#Expression)
-}
type Base10Or16
    = Base10
    | Base16


typeBasicsFloat : Type variable_
typeBasicsFloat =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Float"
            , arguments = []
            }
        )


typeBasicsBool : Type variable_
typeBasicsBool =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Bool"
            , arguments = []
            }
        )


typeBasicsInt : Type variable_
typeBasicsInt =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Basics" ]
            , name = "Int"
            , arguments = []
            }
        )


typeStringString : Type variable_
typeStringString =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "String" ]
            , name = "String"
            , arguments = []
            }
        )


typeCharChar : Type variable_
typeCharChar =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Char" ]
            , name = "Char"
            , arguments = []
            }
        )


typeListList : Type variable -> Type variable
typeListList a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "List" ]
            , name = "List"
            , arguments = [ a ]
            }
        )


typeParserParser : Type variable -> Type variable
typeParserParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Parser" ]
            , name = "Parser"
            , arguments = [ a ]
            }
        )


typeParserAdvancedParser : Type variable -> Type variable -> Type variable -> Type variable
typeParserAdvancedParser context problem value =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Parser", "Advanced" ]
            , name = "Parser"
            , arguments = [ context, problem, value ]
            }
        )


typeUrlParserParser : Type variable -> Type variable -> Type variable
typeUrlParserParser a b =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Url", "Parser" ]
            , name = "Parser"
            , arguments = [ a, b ]
            }
        )


typeUrlParserQueryParser : Type variable -> Type variable
typeUrlParserQueryParser a =
    TypeNotVariable
        (TypeConstruct
            { moduleOrigin = [ "Url", "Parser", "Query" ]
            , name = "Parser"
            , arguments = [ a ]
            }
        )


patternTypedNodeIntroducedVariables : TypedNode (Pattern type_) type_ -> FastDict.Dict String type_
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            FastDict.empty

        PatternIgnored ->
            FastDict.empty

        PatternInt _ ->
            FastDict.empty

        PatternString _ ->
            FastDict.empty

        PatternChar _ ->
            FastDict.empty

        PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        PatternRecord fieldVariables ->
            fieldVariables
                |> listMapToFastDict
                    (\fieldVariable ->
                        { key = fieldVariable.value, value = fieldVariable.type_ }
                    )

        PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern |> patternTypedNodeIntroducedVariables)

        PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        PatternListCons listCons ->
            FastDict.union
                (listCons.head |> patternTypedNodeIntroducedVariables)
                (listCons.tail |> patternTypedNodeIntroducedVariables)

        PatternTuple parts ->
            FastDict.union
                (parts.part0 |> patternTypedNodeIntroducedVariables)
                (parts.part1 |> patternTypedNodeIntroducedVariables)

        PatternTriple parts ->
            (parts.part0 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part1 |> patternTypedNodeIntroducedVariables)
                |> FastDict.union (parts.part2 |> patternTypedNodeIntroducedVariables)

        PatternListExact elements ->
            elements
                |> listMapAndFastDictsUnify patternTypedNodeIntroducedVariables

        PatternVariant variant ->
            variant.values
                |> listMapAndFastDictsUnify patternTypedNodeIntroducedVariables


patternContextToInPath :
    String
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
    ->
        { path : List String
        , moduleOriginLookup : ModuleOriginLookup
        , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        }
patternContextToInPath innermostPathPart context =
    { path = innermostPathPart :: context.path
    , moduleOriginLookup = context.moduleOriginLookup
    , declarationTypes = context.declarationTypes
    }


patternTypeInfer :
    { path : List String
    , moduleOriginLookup : ModuleOriginLookup
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypeInfer context (Elm.Syntax.Node.Node fullRange pattern) =
    -- IGNORE TCO
    case pattern of
        Elm.Syntax.Pattern.FloatPattern _ ->
            Err "float patterns are invalid syntax"

        Elm.Syntax.Pattern.AllPattern ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "ignored" )
            in
            Ok
                { range = fullRange
                , value = PatternIgnored
                , type_ = type_
                }

        Elm.Syntax.Pattern.UnitPattern ->
            Ok
                { range = fullRange
                , value = PatternUnit
                , type_ = TypeNotVariable TypeUnit
                }

        Elm.Syntax.Pattern.CharPattern charValue ->
            Ok
                { range = fullRange
                , value = PatternChar charValue
                , type_ = typeCharChar
                }

        Elm.Syntax.Pattern.IntPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base10, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.HexPattern intValue ->
            Ok
                { range = fullRange
                , value = PatternInt { base = Base16, value = intValue }
                , type_ = typeBasicsInt
                }

        Elm.Syntax.Pattern.StringPattern stringValue ->
            Ok
                { range = fullRange
                , value = PatternString stringValue
                , type_ = typeStringString
                }

        Elm.Syntax.Pattern.VarPattern variableName ->
            Ok
                { range = fullRange
                , value = PatternVariable variableName
                , type_ = TypeVariable ( context.path, variableName )
                }

        Elm.Syntax.Pattern.ParenthesizedPattern parenthesizedInParens ->
            Result.map
                (\inParens ->
                    { range = fullRange
                    , value = PatternParenthesized inParens
                    , type_ = inParens.type_
                    }
                )
                (parenthesizedInParens
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.AsPattern innerPatternNode (Elm.Syntax.Node.Node variableNameRange variableName) ->
            Result.map
                (\inner ->
                    { range = fullRange
                    , value =
                        PatternAs
                            { pattern = inner
                            , variable =
                                { value = variableName
                                , range = variableNameRange
                                , type_ = inner.type_
                                }
                            }
                    , type_ = inner.type_
                    }
                )
                (innerPatternNode
                    |> patternTypeInfer context
                )

        Elm.Syntax.Pattern.TuplePattern parts ->
            case parts of
                [] ->
                    -- should be handled by UnitPattern
                    Ok
                        { range = fullRange
                        , value = PatternUnit
                        , type_ = TypeNotVariable TypeUnit
                        }

                [ parenthesizedInParens ] ->
                    -- should be handled by ParenthesizedPattern
                    Result.map
                        (\inParens ->
                            { range = fullRange
                            , value = PatternParenthesized inParens
                            , type_ = inParens.type_
                            }
                        )
                        (parenthesizedInParens
                            |> patternTypeInfer context
                        )

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            { range = fullRange
                            , value =
                                PatternTuple
                                    { part0 = part0
                                    , part1 = part1
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTuple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)

                [ tuplePart0, tuplePart1, tuplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            { range = fullRange
                            , value =
                                PatternTriple
                                    { part0 = part0
                                    , part1 = part1
                                    , part2 = part2
                                    }
                            , type_ =
                                TypeNotVariable
                                    (TypeTriple
                                        { part0 = part0.type_
                                        , part1 = part1.type_
                                        , part2 = part2.type_
                                        }
                                    )
                            }
                        )
                        (tuplePart0 |> patternTypeInfer context)
                        (tuplePart1 |> patternTypeInfer context)
                        (tuplePart2 |> patternTypeInfer context)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Syntax.Pattern.RecordPattern recordFields ->
            let
                fieldTypedNodes : List (TypedNode String (Type TypeVariableFromContext))
                fieldTypedNodes =
                    recordFields
                        |> List.map
                            (\(Elm.Syntax.Node.Node fieldRange fieldName) ->
                                { range = fieldRange
                                , value = fieldName
                                , type_ =
                                    TypeVariable ( "field" :: context.path, fieldName )
                                }
                            )
            in
            Ok
                { range = fullRange
                , value = PatternRecord fieldTypedNodes
                , type_ =
                    TypeNotVariable
                        (TypeRecordExtension
                            { recordVariable =
                                ( context.path, "record" )
                            , fields =
                                fieldTypedNodes
                                    |> listMapToFastDict
                                        (\fieldVariable ->
                                            { key = fieldVariable.value
                                            , value = fieldVariable.type_
                                            }
                                        )
                            }
                        )
                }

        Elm.Syntax.Pattern.UnConsPattern headNode tailNode ->
            resultAndThen2
                (\headInferred tailInferred ->
                    Result.andThen
                        (\fullListTypeUnified ->
                            Result.map2
                                (\headAfterUnification tailAfterUnification ->
                                    { range = fullRange
                                    , value =
                                        PatternListCons
                                            { head = headAfterUnification
                                            , tail = tailAfterUnification
                                            }
                                    , type_ = fullListTypeUnified.type_
                                    }
                                )
                                (headInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                                (tailInferred
                                    |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                        fullListTypeUnified.substitutions
                                )
                        )
                        (typeUnify
                            context.declarationTypes
                            (typeListList headInferred.type_)
                            tailInferred.type_
                        )
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "head")
                    headNode
                )
                (patternTypeInfer
                    (context |> patternContextToInPath "tail")
                    tailNode
                )

        Elm.Syntax.Pattern.ListPattern elementNodes ->
            case elementNodes of
                [] ->
                    Ok
                        { range = fullRange
                        , value = PatternListExact []
                        , type_ =
                            typeListList
                                (TypeVariable ( context.path, "element" ))
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailInferred ->
                            Result.andThen
                                (\unifiedElementType ->
                                    Result.map2
                                        (\headInferredAfterUnification tailInferredAfterUnification ->
                                            { range = fullRange
                                            , value =
                                                PatternListExact
                                                    (headInferredAfterUnification :: tailInferredAfterUnification)
                                            , type_ =
                                                typeListList unifiedElementType.type_
                                            }
                                        )
                                        (headInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                unifiedElementType.substitutions
                                        )
                                        (tailInferred.elementNodesReverse
                                            |> listFoldlWhileOkFrom []
                                                (\tailElementInferred tailAfterUnificationSoFar ->
                                                    Result.map
                                                        (\tailElementAfterUnification ->
                                                            tailElementAfterUnification
                                                                :: tailAfterUnificationSoFar
                                                        )
                                                        (tailElementInferred
                                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                                unifiedElementType.substitutions
                                                        )
                                                )
                                        )
                                )
                                (( headInferred, tailInferred.elementNodesReverse )
                                    |> listFilledMapAndTypesUnify context.declarationTypes
                                        .type_
                                )
                        )
                        (head
                            |> patternTypeInfer
                                (context
                                    |> patternContextToInPath "0"
                                )
                        )
                        (tail
                            |> listFoldlWhileOkFrom
                                { elementNodesReverse = []
                                , index = 1
                                }
                                (\elementNode soFar ->
                                    Result.map
                                        (\elementInferred ->
                                            { index = soFar.index + 1
                                            , elementNodesReverse =
                                                elementInferred
                                                    :: soFar.elementNodesReverse
                                            }
                                        )
                                        (patternTypeInfer
                                            (context
                                                |> patternContextToInPath
                                                    (soFar.index |> String.fromInt)
                                            )
                                            elementNode
                                        )
                                )
                        )

        Elm.Syntax.Pattern.NamedPattern qualified values ->
            case context.moduleOriginLookup.references |> FastDict.get ( qualified.moduleName, qualified.name ) of
                Nothing ->
                    Err
                        ("no module origin found for the pattern variant "
                            ++ qualifiedToString
                                { qualification = qualified.moduleName
                                , name = qualified.name
                                }
                        )

                Just moduleOrigin ->
                    case context.declarationTypes |> FastDict.get moduleOrigin of
                        Nothing ->
                            Err
                                ("no declaration types found at the module origin of the variant reference "
                                    ++ qualifiedToString
                                        { qualification = moduleOrigin
                                        , name = qualified.name
                                        }
                                )

                        Just moduleOriginDeclarationTypes ->
                            case
                                moduleOriginDeclarationTypes.choiceTypes
                                    |> fastDictMapAndSmallestJust
                                        (\choiceTypeName choiceTypeInfo ->
                                            choiceTypeInfo.variants
                                                |> FastDict.get qualified.name
                                                |> Maybe.map
                                                    (\variantParameters ->
                                                        { variantParameters = variantParameters
                                                        , choiceTypeName = choiceTypeName
                                                        , choiceTypeParameters = choiceTypeInfo.parameters
                                                        }
                                                    )
                                        )
                            of
                                Nothing ->
                                    Err
                                        ("no choice type found at the module origin with the variant reference "
                                            ++ qualifiedToString
                                                { qualification = moduleOrigin
                                                , name = qualified.name
                                                }
                                        )

                                Just variant ->
                                    patternVariantTypeInfer context
                                        { fullRange = fullRange
                                        , qualification = qualified.moduleName
                                        , moduleOrigin = moduleOrigin
                                        , name = qualified.name
                                        , variantValueTypes = variant.variantParameters
                                        , choiceTypeName = variant.choiceTypeName
                                        , choiceTypeParameters = variant.choiceTypeParameters
                                        , values = values
                                        }


patternVariantTypeInfer :
    { moduleOriginLookup : ModuleOriginLookup
    , path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , moduleOrigin : Elm.Syntax.ModuleName.ModuleName
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        , choiceTypeName : String
        , choiceTypeParameters : List String
        , variantValueTypes : List (Type String)
        , values : List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
        }
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternVariantTypeInfer context patternVariant =
    Result.map
        (\valuesAndResultTypeUnified ->
            { range = patternVariant.fullRange
            , value =
                PatternVariant
                    { moduleOrigin = patternVariant.moduleOrigin
                    , qualification = patternVariant.qualification
                    , name = patternVariant.name
                    , values =
                        valuesAndResultTypeUnified.nodesReverse
                            |> List.reverse
                    }
            , type_ = valuesAndResultTypeUnified.resultType
            }
        )
        (List.map2
            (\typeInVariant argumentPattern ->
                { typeInVariant =
                    typeInVariant
                        |> typeMapVariables
                            (\variableName -> ( context.path, variableName ))
                , pattern = argumentPattern
                }
            )
            patternVariant.variantValueTypes
            patternVariant.values
            |> listFoldlWhileOkFrom
                { nodesReverse = []
                , resultType =
                    TypeNotVariable
                        (TypeConstruct
                            { moduleOrigin = patternVariant.moduleOrigin
                            , name = patternVariant.choiceTypeName
                            , arguments =
                                patternVariant.choiceTypeParameters
                                    |> List.map
                                        (\parameter ->
                                            TypeVariable ( context.path, parameter )
                                        )
                            }
                        )
                }
                (\argument soFar ->
                    Result.andThen
                        (\valueInferred ->
                            Result.andThen
                                (\valueTypeUnified ->
                                    Result.map2
                                        (\resultTypeAfterUnification valueInferredAfterUnification ->
                                            { resultType = resultTypeAfterUnification
                                            , nodesReverse =
                                                valueInferredAfterUnification
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (soFar.resultType
                                            |> typeApplyVariableSubstitutions context.declarationTypes
                                                valueTypeUnified.substitutions
                                        )
                                        (valueInferred
                                            |> patternTypedNodeApplyVariableSubstitutions context.declarationTypes
                                                valueTypeUnified.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    valueInferred.type_
                                    argument.typeInVariant
                                )
                        )
                        (argument.pattern
                            |> patternTypeInfer context
                        )
                )
        )


expressionTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            }
expressionTypeInfer context (Elm.Syntax.Node.Node fullRange expression) =
    -- IGNORE TCO
    case expression of
        Elm.Syntax.Expression.UnitExpr ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionUnit
                    , type_ = TypeNotVariable TypeUnit
                    }
                }

        Elm.Syntax.Expression.Integer intValue ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base10, value = intValue }
                    , type_ = type_
                    }
                }

        Elm.Syntax.Expression.Hex intValue ->
            let
                type_ : Type TypeVariableFromContext
                type_ =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionInteger { base = Base16, value = intValue }
                    , type_ = type_
                    }
                }

        Elm.Syntax.Expression.Floatable floatValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionFloat floatValue
                    , type_ = typeBasicsFloat
                    }
                }

        Elm.Syntax.Expression.Literal stringValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionString stringValue
                    , type_ = typeStringString
                    }
                }

        Elm.Syntax.Expression.CharLiteral charValue ->
            Ok
                { substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                , node =
                    { range = fullRange
                    , value = ExpressionChar charValue
                    , type_ = typeCharChar
                    }
                }

        Elm.Syntax.Expression.PrefixOperator operator ->
            Result.map
                (\type_ ->
                    { node =
                        { range = fullRange
                        , value = ExpressionOperatorFunction operator
                        , type_ = type_
                        }
                    , substitutions = variableSubstitutionsNone
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                    }
                )
                (operatorFunctionType
                    { path = context.path
                    , moduleOriginLookup = context.moduleOriginLookup
                    }
                    operator
                )

        Elm.Syntax.Expression.FunctionOrValue qualification name ->
            Result.map
                (\inferred ->
                    { substitutions = variableSubstitutionsNone
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , node =
                        { type_ = inferred.node.type_
                        , range = inferred.node.range
                        , value = ExpressionReference inferred.node.value
                        }
                    }
                )
                (expressionReferenceTypeInfer context
                    { fullRange = fullRange
                    , qualification = qualification
                    , name = name
                    }
                )

        Elm.Syntax.Expression.RecordAccessFunction dotFieldName ->
            let
                fieldName : String
                fieldName =
                    dotFieldName |> String.replace "." ""

                fieldValueType : Type TypeVariableFromContext
                fieldValueType =
                    TypeVariable ( "field" :: context.path, fieldName )
            in
            Ok
                { node =
                    { range = fullRange
                    , value =
                        ExpressionRecordAccessFunction fieldName
                    , type_ =
                        TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable =
                                                ( context.path, "record" )
                                            , fields =
                                                FastDict.singleton fieldName
                                                    fieldValueType
                                            }
                                        )
                                , output = fieldValueType
                                }
                            )
                    }
                , substitutions = variableSubstitutionsNone
                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                }

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            Result.map
                (\inParensInferred ->
                    { node =
                        { range = fullRange
                        , value = ExpressionParenthesized inParensInferred.node
                        , type_ = inParensInferred.node.type_
                        }
                    , substitutions = inParensInferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        inParensInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    }
                )
                (inParens
                    |> expressionTypeInfer context
                )

        Elm.Syntax.Expression.Negation toNegate ->
            Result.andThen
                (\toNegateInferred ->
                    { node =
                        { range = fullRange
                        , value =
                            ExpressionNegation toNegateInferred.node
                        , type_ = toNegateInferred.node.type_
                        }
                    , substitutions = toNegateInferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        toNegateInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    }
                        |> expressionTypeInferResultAddOrApplySubstitutions
                            { declarationTypes = context.declarationTypes
                            , locallyIntroducedExpressionVariables =
                                context.locallyIntroducedExpressionVariables
                            }
                            (variableSubstitutionsFromVariableToType
                                ( context.path, "number" )
                                toNegateInferred.node.type_
                            )
                )
                (toNegate
                    |> expressionTypeInfer
                        (context
                            |> expressionContextToInPath "negated"
                        )
                )

        Elm.Syntax.Expression.RecordAccess recordNode fieldNameNode ->
            Result.andThen
                (\accessedRecordInferred ->
                    let
                        fieldName : String
                        fieldName =
                            fieldNameNode |> Elm.Syntax.Node.value

                        fieldValueType : Type TypeVariableFromContext
                        fieldValueType =
                            TypeVariable ( context.path, fieldName )
                    in
                    Result.andThen
                        (\recordWithAccessedField ->
                            { node =
                                { range = fullRange
                                , value =
                                    ExpressionRecordAccess
                                        { record = accessedRecordInferred.node
                                        , fieldName = fieldName
                                        , fieldNameRange =
                                            fieldNameNode |> Elm.Syntax.Node.range
                                        }
                                , type_ = fieldValueType
                                }
                            , substitutions = accessedRecordInferred.substitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                accessedRecordInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            }
                                |> expressionTypeInferResultAddOrApplySubstitutions
                                    { declarationTypes = context.declarationTypes
                                    , locallyIntroducedExpressionVariables =
                                        context.locallyIntroducedExpressionVariables
                                    }
                                    recordWithAccessedField.substitutions
                        )
                        (typeUnify context.declarationTypes
                            accessedRecordInferred.node.type_
                            (TypeNotVariable
                                (TypeRecordExtension
                                    { recordVariable =
                                        ( context.path, "record" )
                                    , fields =
                                        FastDict.singleton fieldName
                                            fieldValueType
                                    }
                                )
                            )
                        )
                )
                (recordNode
                    |> expressionTypeInfer
                        (context
                            |> expressionContextToInPath "record"
                        )
                )

        Elm.Syntax.Expression.OperatorApplication operator _ left right ->
            expressionInfixOperationTypeInfer context
                { fullRange = fullRange
                , operator = operator
                , left = left
                , right = right
                }

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            resultAndThen3
                (\conditionInferred onTrueInferred onFalseInferred ->
                    resultAndThen2
                        (\conditionTypeInferredUnifiedWithBool resultTypesUnified ->
                            resultAndThen2
                                (\fullSubstitutions unificationSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            conditionInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            onTrueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            onFalseInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionIfThenElse
                                                { condition = conditionInferred.node
                                                , onTrue = onTrueInferred.node
                                                , onFalse = onFalseInferred.node
                                                }
                                        , type_ = onTrueInferred.node.type_
                                        }
                                    }
                                        |> expressionTypeInferResultAddOrApplySubstitutions
                                            { declarationTypes = context.declarationTypes
                                            , locallyIntroducedExpressionVariables =
                                                context.locallyIntroducedExpressionVariables
                                            }
                                            unificationSubstitutions
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    conditionInferred.substitutions
                                    onTrueInferred.substitutions
                                    onFalseInferred.substitutions
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    conditionTypeInferredUnifiedWithBool.substitutions
                                    resultTypesUnified.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            conditionInferred.node.type_
                            typeBasicsBool
                        )
                        (typeUnify context.declarationTypes
                            onTrueInferred.node.type_
                            onFalseInferred.node.type_
                        )
                )
                (condition
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "condition")
                )
                (onTrue
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onTrue")
                )
                (onFalse
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "onFalse")
                )

        Elm.Syntax.Expression.TupledExpression tupleParts ->
            case tupleParts of
                [] ->
                    -- should be handled by UnitExpr
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                        , node =
                            { range = fullRange
                            , value = ExpressionUnit
                            , type_ = TypeNotVariable TypeUnit
                            }
                        }

                [ inParens ] ->
                    -- should be handled by ParenthesizedExpression
                    Result.map
                        (\inParensInferred ->
                            { node =
                                { range = fullRange
                                , value = ExpressionParenthesized inParensInferred.node
                                , type_ = inParensInferred.node.type_
                                }
                            , substitutions = inParensInferred.substitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                inParensInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            }
                        )
                        (inParens
                            |> expressionTypeInfer context
                        )

                [ part0, part1 ] ->
                    resultAndThen2
                        (\part0Inferred part1Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                            part0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part1Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTuple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTuple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    }
                                                )
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )

                [ part0, part1, part2 ] ->
                    resultAndThen3
                        (\part0Inferred part1Inferred part2Inferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            part0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part1Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            part2Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionTriple
                                                { part0 = part0Inferred.node
                                                , part1 = part1Inferred.node
                                                , part2 = part2Inferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeTriple
                                                    { part0 = part0Inferred.node.type_
                                                    , part1 = part1Inferred.node.type_
                                                    , part2 = part2Inferred.node.type_
                                                    }
                                                )
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3 context.declarationTypes
                                    part0Inferred.substitutions
                                    part1Inferred.substitutions
                                    part2Inferred.substitutions
                                )
                        )
                        (part0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "0")
                        )
                        (part1
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "1")
                        )
                        (part2
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "2")
                        )

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts. Should not exist in a valid parse result"

        Elm.Syntax.Expression.ListExpr elements ->
            case elements of
                [] ->
                    let
                        type_ : Type ( List String, String )
                        type_ =
                            typeListList
                                (TypeVariable ( context.path, "element" ))
                    in
                    Ok
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        , node =
                            { range = fullRange
                            , value = ExpressionList []
                            , type_ = type_
                            }
                        }

                head :: tail ->
                    resultAndThen2
                        (\headInferred tailElementsInferred ->
                            Result.andThen
                                (\elementTypeUnified ->
                                    Result.andThen
                                        (\substitutionsAcrossElements ->
                                            { substitutions = substitutionsAcrossElements
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                    headInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    tailElementsInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionList
                                                        (headInferred.node
                                                            :: (tailElementsInferred.nodesReverse
                                                                    |> List.reverse
                                                               )
                                                        )
                                                , type_ = typeListList headInferred.node.type_
                                                }
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutions
                                                    { declarationTypes = context.declarationTypes
                                                    , locallyIntroducedExpressionVariables =
                                                        context.locallyIntroducedExpressionVariables
                                                    }
                                                    elementTypeUnified.substitutions
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            headInferred.substitutions
                                            tailElementsInferred.substitutions
                                        )
                                )
                                (listFilledMapAndTypesUnify context.declarationTypes
                                    .type_
                                    ( headInferred.node, tailElementsInferred.nodesReverse )
                                )
                        )
                        (expressionTypeInfer
                            (context |> expressionContextToInPath "0")
                            head
                        )
                        (tail
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                , index = 1
                                }
                                (\elementNode soFar ->
                                    Result.andThen
                                        (\elementInferred ->
                                            Result.map
                                                (\substitutionsWithElement ->
                                                    { index = soFar.index + 1
                                                    , nodesReverse =
                                                        elementInferred.node
                                                            :: soFar.nodesReverse
                                                    , substitutions = substitutionsWithElement
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            elementInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    elementInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (expressionTypeInfer
                                            (context
                                                |> expressionContextToInPath
                                                    (soFar.index |> String.fromInt)
                                            )
                                            elementNode
                                        )
                                )
                        )

        Elm.Syntax.Expression.Application application ->
            case application of
                [] ->
                    Err "empty application is invalid syntax"

                [ subExpression ] ->
                    -- never produced by elm-syntax
                    subExpression |> expressionTypeInfer context

                called :: argument0 :: argument1Up ->
                    resultAndThen3
                        (\calledInferred argument0Inferred argument1UpInferred ->
                            let
                                resultType : Type TypeVariableFromContext
                                resultType =
                                    TypeVariable ( context.path, "callResult" )
                            in
                            Result.andThen
                                (\callTypeUnified ->
                                    Result.andThen
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    calledInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    argument0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    argument1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCall
                                                        { called = calledInferred.node
                                                        , argument0 = argument0Inferred.node
                                                        , argument1Up =
                                                            argument1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = resultType
                                                }
                                            }
                                                |> expressionTypeInferResultAddOrApplySubstitutions
                                                    { declarationTypes = context.declarationTypes
                                                    , locallyIntroducedExpressionVariables =
                                                        context.locallyIntroducedExpressionVariables
                                                    }
                                                    callTypeUnified.substitutions
                                        )
                                        (variableSubstitutionsMerge3 context.declarationTypes
                                            calledInferred.substitutions
                                            argument0Inferred.substitutions
                                            argument1UpInferred.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = argument0Inferred.node.type_
                                            , output =
                                                argument1UpInferred.nodesReverse
                                                    |> List.foldl
                                                        (\argumentInferred output ->
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input = argumentInferred.type_
                                                                    , output = output
                                                                    }
                                                                )
                                                        )
                                                        resultType
                                            }
                                        )
                                    )
                                    calledInferred.node.type_
                                )
                        )
                        (called
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "called")
                        )
                        (argument0
                            |> expressionTypeInfer
                                (context |> expressionContextToInPath "argument0")
                        )
                        (argument1Up
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                , index = 1
                                }
                                (\argumentNode soFar ->
                                    Result.andThen
                                        (\argumentInferred ->
                                            Result.map
                                                (\substitutionsWithArgument ->
                                                    { index = soFar.index + 1
                                                    , substitutions = substitutionsWithArgument
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            argumentInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        argumentInferred.node
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    argumentInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (argumentNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("argument" ++ (soFar.index |> String.fromInt))
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.RecordExpr fields ->
            Result.map
                (\fieldsInferred ->
                    { substitutions = fieldsInferred.substitutions
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        fieldsInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , node =
                        { range = fullRange
                        , value =
                            ExpressionRecord
                                (fieldsInferred.fieldTypedNodesReverse
                                    |> List.reverse
                                )
                        , type_ =
                            TypeNotVariable
                                (TypeRecord
                                    (fieldsInferred.fieldTypedNodesReverse
                                        |> List.foldl
                                            (\field soFar ->
                                                soFar
                                                    |> FastDict.insert field.name
                                                        field.value.type_
                                            )
                                            FastDict.empty
                                    )
                                )
                        }
                    }
                )
                (fields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                        , fieldTypedNodesReverse = []
                        }
                        (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node fieldNameRange fieldName, fieldValueNode )) soFar ->
                            Result.andThen
                                (\fieldValueInferred ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { fieldTypedNodesReverse =
                                                { range = fieldRange
                                                , name = fieldName
                                                , nameRange = fieldNameRange
                                                , value = fieldValueInferred.node
                                                }
                                                    :: soFar.fieldTypedNodesReverse
                                            , substitutions = substitutionsWithField
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                    fieldValueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            }
                                        )
                                        (variableSubstitutionsMerge context.declarationTypes
                                            fieldValueInferred.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldValueNode
                                    |> expressionTypeInfer
                                        (context |> expressionContextToInPath fieldName)
                                )
                        )
                )

        Elm.Syntax.Expression.RecordUpdateExpression (Elm.Syntax.Node.Node recordVariableRange recordVariable) fields ->
            case fields of
                [] ->
                    Err "record update without fields is invalid syntax"

                (Elm.Syntax.Node.Node field0Range ( Elm.Syntax.Node.Node field0NameRange field0Name, field0ValueNode )) :: field1Up ->
                    resultAndThen3
                        (\recordVariableInferred field0Inferred field1UpInferred ->
                            Result.andThen
                                (\typeUnified ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    recordVariableInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    field0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    field1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionRecordUpdate
                                                        { recordVariable =
                                                            { range = recordVariableInferred.node.range
                                                            , value =
                                                                { moduleOrigin =
                                                                    recordVariableInferred.node.value.moduleOrigin
                                                                , name = recordVariableInferred.node.value.name
                                                                }
                                                            , type_ = typeUnified.type_
                                                            }
                                                        , field0 = field0Inferred.node
                                                        , field1Up =
                                                            field1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = typeUnified.type_
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge3 context.declarationTypes
                                            typeUnified.substitutions
                                            field0Inferred.substitutions
                                            field1UpInferred.substitutions
                                        )
                                )
                                (typeUnify context.declarationTypes
                                    recordVariableInferred.node.type_
                                    (TypeNotVariable
                                        (TypeRecordExtension
                                            { recordVariable = ( context.path, "record" )
                                            , fields =
                                                field1UpInferred.nodesReverse
                                                    |> List.foldl
                                                        (\fieldInferred soFar ->
                                                            soFar
                                                                |> FastDict.insert fieldInferred.name
                                                                    fieldInferred.value.type_
                                                        )
                                                        (FastDict.singleton
                                                            field0Inferred.node.name
                                                            field0Inferred.node.value.type_
                                                        )
                                            }
                                        )
                                    )
                                )
                        )
                        ({ fullRange = recordVariableRange
                         , qualification = []
                         , name = recordVariable
                         }
                            |> expressionReferenceTypeInfer
                                (context |> expressionContextToInPath "record")
                        )
                        (Result.map
                            (\valueInferred ->
                                { substitutions = valueInferred.substitutions
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                    valueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                , node =
                                    { range = field0Range
                                    , name = field0Name
                                    , nameRange = field0NameRange
                                    , value = valueInferred.node
                                    }
                                }
                            )
                            (field0ValueNode
                                |> expressionTypeInfer
                                    (context
                                        |> expressionContextToInPath
                                            ("field" ++ stringFirstCharToUpper field0Name)
                                    )
                            )
                        )
                        (field1Up
                            |> listFoldlWhileOkFrom
                                { substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                }
                                (\(Elm.Syntax.Node.Node fieldRange ( Elm.Syntax.Node.Node nameRange name, valueNode )) soFar ->
                                    Result.andThen
                                        (\fieldValueInferred ->
                                            Result.map
                                                (\substitutionsWithField ->
                                                    { substitutions = substitutionsWithField
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            fieldValueInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        { range = fieldRange
                                                        , name = name
                                                        , nameRange = nameRange
                                                        , value = fieldValueInferred.node
                                                        }
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge context.declarationTypes
                                                    soFar.substitutions
                                                    fieldValueInferred.substitutions
                                                )
                                        )
                                        (valueNode
                                            |> expressionTypeInfer
                                                (context
                                                    |> expressionContextToInPath
                                                        ("field" ++ stringFirstCharToUpper name)
                                                )
                                        )
                                )
                        )

        Elm.Syntax.Expression.LambdaExpression lambda ->
            case lambda.args of
                [] ->
                    Err "lambda without parameter patterns is invalid syntax"

                parameter0 :: parameter1Up ->
                    resultAndThen2
                        (\parameter0Inferred parameter1UpInferred ->
                            Result.map
                                (\resultInferred ->
                                    { substitutions = resultInferred.substitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionLambda
                                                { parameter0 = parameter0Inferred
                                                , parameter1Up =
                                                    parameter1UpInferred.nodesReverse
                                                        |> List.reverse
                                                , result = resultInferred.node
                                                }
                                        , type_ =
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = parameter0Inferred.type_
                                                    , output =
                                                        parameter1UpInferred.nodesReverse
                                                            |> List.foldl
                                                                (\argumentTypedNode output ->
                                                                    TypeNotVariable
                                                                        (TypeFunction
                                                                            { input = argumentTypedNode.type_
                                                                            , output = output
                                                                            }
                                                                        )
                                                                )
                                                                resultInferred.node.type_
                                                    }
                                                )
                                        }
                                    }
                                )
                                (lambda.expression
                                    |> expressionTypeInfer
                                        { containingDeclarationName = context.containingDeclarationName
                                        , path = "lambdaResult" :: context.path
                                        , declarationTypes = context.declarationTypes
                                        , moduleOriginLookup = context.moduleOriginLookup
                                        , partiallyInferredDeclarationTypes =
                                            context.partiallyInferredDeclarationTypes
                                        , locallyIntroducedExpressionVariables =
                                            FastDict.union
                                                context.locallyIntroducedExpressionVariables
                                                (List.foldl
                                                    (\parameter soFar ->
                                                        FastDict.union soFar
                                                            (parameter |> patternTypedNodeIntroducedVariables)
                                                    )
                                                    (parameter0Inferred |> patternTypedNodeIntroducedVariables)
                                                    parameter1UpInferred.nodesReverse
                                                )
                                        }
                                )
                        )
                        (parameter0
                            |> patternTypeInfer
                                { path = "parameter0" :: context.path
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = context.declarationTypes
                                }
                        )
                        (parameter1Up
                            |> listFoldlWhileOkFrom
                                { nodesReverse = []
                                , index = 1
                                }
                                (\pattern soFar ->
                                    Result.map
                                        (\patternInferred ->
                                            { index = soFar.index + 1
                                            , nodesReverse =
                                                patternInferred
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (pattern
                                            |> patternTypeInfer
                                                { path =
                                                    ("parameter" ++ (soFar.index |> String.fromInt))
                                                        :: context.path
                                                , declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                }
                                        )
                                )
                            |> Result.map
                                (\folded ->
                                    { nodesReverse = folded.nodesReverse
                                    }
                                )
                        )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            case caseOf.cases of
                [] ->
                    Err "case-of without case branches is invalid syntax"

                ( case0Pattern, case0Result ) :: case1Up ->
                    resultAndThen3
                        (\matchedInferred case0Inferred case1UpInferred ->
                            Result.andThen
                                (\unifiedTypes ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                                    matchedInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    case0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    case1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            , node =
                                                { range = fullRange
                                                , value =
                                                    ExpressionCaseOf
                                                        { matchedExpression = matchedInferred.node
                                                        , case0 = case0Inferred.node
                                                        , case1Up =
                                                            case1UpInferred.nodesReverse
                                                                |> List.reverse
                                                        }
                                                , type_ = unifiedTypes.resultType
                                                }
                                            }
                                        )
                                        (variableSubstitutionsMerge4 context.declarationTypes
                                            matchedInferred.substitutions
                                            case0Inferred.substitutions
                                            case1UpInferred.substitutions
                                            unifiedTypes.substitutions
                                        )
                                )
                                (Result.andThen
                                    (\matchedExpressionCase0PatternUnifiedType ->
                                        case1UpInferred.nodesReverse
                                            |> listFoldlWhileOkFrom
                                                { resultType = case0Inferred.node.result.type_
                                                , matchedType = matchedExpressionCase0PatternUnifiedType.type_
                                                , substitutions = matchedExpressionCase0PatternUnifiedType.substitutions
                                                }
                                                (\caseInferred soFar ->
                                                    resultAndThen2
                                                        (\matchedTypeUnifiedWithCasePattern resultTypeUnifiedWithCaseResult ->
                                                            Result.map
                                                                (\substitutionsWithCase ->
                                                                    { substitutions = substitutionsWithCase
                                                                    , matchedType = matchedTypeUnifiedWithCasePattern.type_
                                                                    , resultType = resultTypeUnifiedWithCaseResult.type_
                                                                    }
                                                                )
                                                                (variableSubstitutionsMerge3 context.declarationTypes
                                                                    soFar.substitutions
                                                                    matchedTypeUnifiedWithCasePattern.substitutions
                                                                    resultTypeUnifiedWithCaseResult.substitutions
                                                                )
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            soFar.matchedType
                                                            caseInferred.pattern.type_
                                                        )
                                                        (typeUnify context.declarationTypes
                                                            soFar.resultType
                                                            caseInferred.result.type_
                                                        )
                                                )
                                    )
                                    (typeUnify context.declarationTypes
                                        matchedInferred.node.type_
                                        case0Inferred.node.pattern.type_
                                    )
                                )
                        )
                        (caseOf.expression
                            |> expressionTypeInfer (context |> expressionContextToInPath "matched")
                        )
                        (Result.andThen
                            (\patternInferred ->
                                Result.map
                                    (\resultInferred ->
                                        { substitutions = resultInferred.substitutions
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        , node =
                                            { pattern = patternInferred
                                            , result = resultInferred.node
                                            }
                                        }
                                    )
                                    (case0Result
                                        |> expressionTypeInfer
                                            { declarationTypes = context.declarationTypes
                                            , moduleOriginLookup = context.moduleOriginLookup
                                            , partiallyInferredDeclarationTypes =
                                                context.partiallyInferredDeclarationTypes
                                            , containingDeclarationName = context.containingDeclarationName
                                            , path = "result" :: "case0" :: context.path
                                            , locallyIntroducedExpressionVariables =
                                                FastDict.union context.locallyIntroducedExpressionVariables
                                                    (patternInferred |> patternTypedNodeIntroducedVariables)
                                            }
                                    )
                            )
                            (case0Pattern
                                |> patternTypeInfer
                                    { declarationTypes = context.declarationTypes
                                    , moduleOriginLookup = context.moduleOriginLookup
                                    , path = "pattern" :: "case0" :: context.path
                                    }
                            )
                        )
                        (case1Up
                            |> listFoldlWhileOkFrom
                                { index = 1
                                , substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                }
                                (\( casePattern, caseResult ) soFar ->
                                    let
                                        casePath : List String
                                        casePath =
                                            ("case" ++ (soFar.index |> String.fromInt))
                                                :: context.path
                                    in
                                    Result.andThen
                                        (\patternInferred ->
                                            Result.andThen
                                                (\resultInferred ->
                                                    Result.map
                                                        (\fullSubstitutions ->
                                                            { index = soFar.index + 1
                                                            , substitutions = fullSubstitutions
                                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                                    resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            , nodesReverse =
                                                                { pattern = patternInferred
                                                                , result = resultInferred.node
                                                                }
                                                                    :: soFar.nodesReverse
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge context.declarationTypes
                                                            resultInferred.substitutions
                                                            soFar.substitutions
                                                        )
                                                )
                                                (caseResult
                                                    |> expressionTypeInfer
                                                        { declarationTypes = context.declarationTypes
                                                        , partiallyInferredDeclarationTypes =
                                                            context.partiallyInferredDeclarationTypes
                                                        , moduleOriginLookup = context.moduleOriginLookup
                                                        , containingDeclarationName = context.containingDeclarationName
                                                        , path = "result" :: casePath
                                                        , locallyIntroducedExpressionVariables =
                                                            FastDict.union
                                                                (patternInferred |> patternTypedNodeIntroducedVariables)
                                                                context.locallyIntroducedExpressionVariables
                                                        }
                                                )
                                        )
                                        (casePattern
                                            |> patternTypeInfer
                                                { declarationTypes = context.declarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , path = "pattern" :: casePath
                                                }
                                        )
                                )
                        )

        Elm.Syntax.Expression.LetExpression letIn ->
            case letIn.declarations of
                [] ->
                    Err "let-in without declarations is invalid syntax"

                letDeclaration0Node :: letDeclaration1Up ->
                    let
                        acrossLetIn :
                            { introducedExpressionVariables :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            , annotatedDeclarationTypes :
                                FastDict.Dict String (Type String)
                            , partiallyInferredDeclarationTypes :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            }
                        acrossLetIn =
                            (letDeclaration0Node :: letDeclaration1Up)
                                |> List.foldl
                                    (\(Elm.Syntax.Node.Node _ letDeclaration) soFar ->
                                        let
                                            contextPath : List String
                                            contextPath =
                                                ("letDeclaration"
                                                    ++ (soFar.index |> String.fromInt)
                                                )
                                                    :: context.path
                                        in
                                        case letDeclaration of
                                            Elm.Syntax.Expression.LetDestructuring patternNode _ ->
                                                case
                                                    patternNode
                                                        |> patternTypeInfer
                                                            { path = "pattern" :: contextPath
                                                            , declarationTypes = context.declarationTypes
                                                            , moduleOriginLookup = context.moduleOriginLookup
                                                            }
                                                of
                                                    Err _ ->
                                                        { index = soFar.index + 1
                                                        , annotatedDeclarationTypes =
                                                            soFar.annotatedDeclarationTypes
                                                        , partiallyInferredDeclarationTypes =
                                                            soFar.partiallyInferredDeclarationTypes
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        }

                                                    Ok patternInferred ->
                                                        { index = soFar.index + 1
                                                        , annotatedDeclarationTypes =
                                                            soFar.annotatedDeclarationTypes
                                                        , partiallyInferredDeclarationTypes =
                                                            soFar.partiallyInferredDeclarationTypes
                                                        , introducedExpressionVariables =
                                                            FastDict.union soFar.introducedExpressionVariables
                                                                (patternInferred |> patternTypedNodeIntroducedVariables)
                                                        }

                                            Elm.Syntax.Expression.LetFunction letValueOrFunctionDeclaration ->
                                                let
                                                    name : String
                                                    name =
                                                        letValueOrFunctionDeclaration.declaration
                                                            |> Elm.Syntax.Node.value
                                                            |> .name
                                                            |> Elm.Syntax.Node.value
                                                in
                                                case
                                                    letValueOrFunctionDeclaration.signature
                                                        |> Maybe.andThen
                                                            (\(Elm.Syntax.Node.Node _ signature) ->
                                                                signature.typeAnnotation
                                                                    |> Elm.Syntax.Node.value
                                                                    |> syntaxToType context.moduleOriginLookup
                                                                    |> Result.toMaybe
                                                            )
                                                of
                                                    Just type_ ->
                                                        { index = soFar.index + 1
                                                        , partiallyInferredDeclarationTypes =
                                                            soFar.partiallyInferredDeclarationTypes
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        , annotatedDeclarationTypes =
                                                            soFar.annotatedDeclarationTypes
                                                                |> FastDict.insert name type_
                                                        }

                                                    Nothing ->
                                                        { index = soFar.index + 1
                                                        , introducedExpressionVariables =
                                                            soFar.introducedExpressionVariables
                                                        , annotatedDeclarationTypes =
                                                            soFar.annotatedDeclarationTypes
                                                        , partiallyInferredDeclarationTypes =
                                                            soFar.partiallyInferredDeclarationTypes
                                                                |> FastDict.insert name
                                                                    (TypeVariable
                                                                        ( contextPath, "type" )
                                                                    )
                                                        }
                                    )
                                    { index = 0
                                    , annotatedDeclarationTypes = FastDict.empty
                                    , partiallyInferredDeclarationTypes = FastDict.empty
                                    , introducedExpressionVariables = FastDict.empty
                                    }
                                |> (\result ->
                                        { introducedExpressionVariables = result.introducedExpressionVariables
                                        , partiallyInferredDeclarationTypes = result.partiallyInferredDeclarationTypes
                                        , annotatedDeclarationTypes = result.annotatedDeclarationTypes
                                        }
                                   )

                        acrossLetInIncludingContextSoFar :
                            { locallyIntroducedExpressionVariables :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            , declarationTypes :
                                ModuleLevelDeclarationTypesAvailableInModule
                            , partiallyInferredDeclarationTypes :
                                FastDict.Dict String (Type TypeVariableFromContext)
                            }
                        acrossLetInIncludingContextSoFar =
                            { locallyIntroducedExpressionVariables =
                                FastDict.union
                                    context.locallyIntroducedExpressionVariables
                                    acrossLetIn.introducedExpressionVariables
                            , partiallyInferredDeclarationTypes =
                                FastDict.union
                                    context.partiallyInferredDeclarationTypes
                                    acrossLetIn.partiallyInferredDeclarationTypes
                            , declarationTypes =
                                context.declarationTypes
                                    |> FastDict.update []
                                        (\localDeclarationTypesOrNothing ->
                                            Just
                                                (case localDeclarationTypesOrNothing of
                                                    Nothing ->
                                                        { signatures = acrossLetIn.annotatedDeclarationTypes
                                                        , typeAliases = FastDict.empty
                                                        , choiceTypes = FastDict.empty
                                                        }

                                                    Just localDeclarationTypes ->
                                                        { signatures =
                                                            FastDict.union
                                                                localDeclarationTypes.signatures
                                                                acrossLetIn.annotatedDeclarationTypes
                                                        , typeAliases = localDeclarationTypes.typeAliases
                                                        , choiceTypes = localDeclarationTypes.choiceTypes
                                                        }
                                                )
                                        )
                            }
                    in
                    resultAndThen3
                        (\declaration0Inferred declaration1UpInferred resultInferred ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3
                                            declaration0Inferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            declaration1UpInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                            resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = fullRange
                                        , value =
                                            ExpressionLetIn
                                                { declaration0 = declaration0Inferred.node
                                                , declaration1Up =
                                                    declaration1UpInferred.nodesReverse
                                                        |> List.reverse
                                                , result = resultInferred.node
                                                }
                                        , type_ = resultInferred.node.type_
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge3 acrossLetInIncludingContextSoFar.declarationTypes
                                    declaration0Inferred.substitutions
                                    declaration1UpInferred.substitutions
                                    resultInferred.substitutions
                                )
                        )
                        (letDeclaration0Node
                            |> letDeclarationTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letDeclaration0" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                , partiallyInferredDeclarationTypes =
                                    acrossLetInIncludingContextSoFar.partiallyInferredDeclarationTypes
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = acrossLetInIncludingContextSoFar.declarationTypes
                                }
                        )
                        (letDeclaration1Up
                            |> listFoldlWhileOkFrom
                                { index = 1
                                , substitutions = variableSubstitutionsNone
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , nodesReverse = []
                                }
                                (\letDeclarationNode soFar ->
                                    Result.andThen
                                        (\letDeclarationInferred ->
                                            Result.map
                                                (\substitutionsWithLetDeclaration ->
                                                    { index = soFar.index + 1
                                                    , substitutions = substitutionsWithLetDeclaration
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                                            letDeclarationInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , nodesReverse =
                                                        letDeclarationInferred.node
                                                            :: soFar.nodesReverse
                                                    }
                                                )
                                                (variableSubstitutionsMerge acrossLetInIncludingContextSoFar.declarationTypes
                                                    letDeclarationInferred.substitutions
                                                    soFar.substitutions
                                                )
                                        )
                                        (letDeclarationNode
                                            |> letDeclarationTypeInfer
                                                { containingDeclarationName = context.containingDeclarationName
                                                , path =
                                                    ("letDeclaration"
                                                        ++ (soFar.index |> String.fromInt)
                                                    )
                                                        :: context.path
                                                , locallyIntroducedExpressionVariables =
                                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                                , partiallyInferredDeclarationTypes =
                                                    acrossLetInIncludingContextSoFar.partiallyInferredDeclarationTypes
                                                , moduleOriginLookup = context.moduleOriginLookup
                                                , declarationTypes = acrossLetInIncludingContextSoFar.declarationTypes
                                                }
                                        )
                                )
                        )
                        (letIn.expression
                            |> expressionTypeInfer
                                { containingDeclarationName = context.containingDeclarationName
                                , path = "letInResult" :: context.path
                                , locallyIntroducedExpressionVariables =
                                    acrossLetInIncludingContextSoFar.locallyIntroducedExpressionVariables
                                , moduleOriginLookup = context.moduleOriginLookup
                                , declarationTypes = acrossLetInIncludingContextSoFar.declarationTypes
                                , partiallyInferredDeclarationTypes =
                                    acrossLetInIncludingContextSoFar.partiallyInferredDeclarationTypes
                                }
                        )

        Elm.Syntax.Expression.Operator _ ->
            Err "Elm.Syntax.Expression.Operator should not exist in a valid parse result"

        Elm.Syntax.Expression.GLSLExpression _ ->
            Err "glsl shader expressions not supported"


expressionReferenceTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , containingDeclarationName : String
    , path : List String
    , moduleOriginLookup : ModuleOriginLookup
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , qualification : Elm.Syntax.ModuleName.ModuleName
        , name : String
        }
    ->
        Result
            String
            { node :
                TypedNode
                    { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                    , qualification : Elm.Syntax.ModuleName.ModuleName
                    , name : String
                    }
                    (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            }
expressionReferenceTypeInfer context expressionReference =
    let
        useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration :
            Maybe
                { node :
                    TypedNode
                        { moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                        , qualification : Elm.Syntax.ModuleName.ModuleName
                        , name : String
                        }
                        (Type TypeVariableFromContext)
                , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                    FastDict.Dict
                        TypeVariableFromContext
                        (FastSet.Set TypeVariableFromContext)
                }
        useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration =
            case context.locallyIntroducedExpressionVariables |> FastDict.get expressionReference.name of
                Just locallyIntroducedExpressionVariable ->
                    Just
                        { usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                        , node =
                            { range = expressionReference.fullRange
                            , value =
                                { qualification = []
                                , moduleOrigin = []
                                , name = expressionReference.name
                                }
                            , type_ = locallyIntroducedExpressionVariable
                            }
                        }

                Nothing ->
                    case context.partiallyInferredDeclarationTypes |> FastDict.get expressionReference.name of
                        Nothing ->
                            Nothing

                        Just partiallyInferredType ->
                            let
                                partiallyInferredTypeVariableNameToInContext : TypeVariableFromContext -> TypeVariableFromContext
                                partiallyInferredTypeVariableNameToInContext ( partiallyInferredTypeVariableContext, partiallyInferredTypeVariableName ) =
                                    ( partiallyInferredTypeVariableContext
                                        ++ context.path
                                    , partiallyInferredTypeVariableName
                                    )

                                type_ : Type TypeVariableFromContext
                                type_ =
                                    partiallyInferredType
                                        |> typeMapVariables partiallyInferredTypeVariableNameToInContext
                            in
                            Just
                                { usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                    partiallyInferredType
                                        |> typeContainedVariables
                                        |> FastSet.foldl
                                            (\partiallyInferredTypeVariable soFar ->
                                                soFar
                                                    |> FastDict.insert
                                                        partiallyInferredTypeVariable
                                                        (FastSet.singleton
                                                            (partiallyInferredTypeVariable
                                                                |> partiallyInferredTypeVariableNameToInContext
                                                            )
                                                        )
                                            )
                                            FastDict.empty
                                , node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = []
                                        , moduleOrigin = []
                                        , name = expressionReference.name
                                        }
                                    , type_ = type_
                                    }
                                }
    in
    case useOfLocallyIntroducedExpressionVariablesOrPartiallyInferredDeclaration of
        Just inferred ->
            Ok inferred

        Nothing ->
            let
                moduleOrigin : Elm.Syntax.ModuleName.ModuleName
                moduleOrigin =
                    context.moduleOriginLookup.references
                        |> FastDict.get ( expressionReference.qualification, expressionReference.name )
                        |> Maybe.withDefault []
            in
            case context.declarationTypes |> FastDict.get moduleOrigin of
                Nothing ->
                    Err
                        ("No declaration types found for the reference "
                            ++ qualifiedToString
                                { qualification = expressionReference.qualification
                                , name = expressionReference.name
                                }
                            ++ ". I looked for some in the module "
                            ++ (moduleOrigin |> moduleNameToString)
                        )

                Just originModuleDeclarationTypes ->
                    case originModuleDeclarationTypes.signatures |> FastDict.get expressionReference.name of
                        Just signatureType ->
                            Ok
                                { usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                , node =
                                    { range = expressionReference.fullRange
                                    , value =
                                        { qualification = expressionReference.qualification
                                        , moduleOrigin = moduleOrigin
                                        , name = expressionReference.name
                                        }
                                    , type_ =
                                        signatureType
                                            |> typeMapVariables
                                                (\variableName -> ( context.path, variableName ))
                                    }
                                }

                        Nothing ->
                            case
                                originModuleDeclarationTypes.choiceTypes
                                    |> fastDictMapAndSmallestJust
                                        (\choiceTypeName choiceTypeInfo ->
                                            choiceTypeInfo.variants
                                                |> FastDict.get expressionReference.name
                                                |> Maybe.map
                                                    (\variantValues ->
                                                        { variantValues = variantValues
                                                        , choiceTypeName = choiceTypeName
                                                        , choiceTypeParameters = choiceTypeInfo.parameters
                                                        }
                                                    )
                                        )
                            of
                                Just variant ->
                                    let
                                        resultType : Type String
                                        resultType =
                                            TypeNotVariable
                                                (TypeConstruct
                                                    { moduleOrigin = moduleOrigin
                                                    , name = variant.choiceTypeName
                                                    , arguments =
                                                        variant.choiceTypeParameters
                                                            |> List.map TypeVariable
                                                    }
                                                )

                                        fullType : Type TypeVariableFromContext
                                        fullType =
                                            variant.variantValues
                                                |> List.foldr
                                                    (\argument output ->
                                                        TypeNotVariable
                                                            (TypeFunction
                                                                { input = argument
                                                                , output = output
                                                                }
                                                            )
                                                    )
                                                    resultType
                                                |> typeMapVariables
                                                    (\variableName -> ( context.path, variableName ))
                                    in
                                    Ok
                                        { usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                        , node =
                                            { range = expressionReference.fullRange
                                            , value =
                                                { qualification = expressionReference.qualification
                                                , moduleOrigin = moduleOrigin
                                                , name = expressionReference.name
                                                }
                                            , type_ = fullType
                                            }
                                        }

                                Nothing ->
                                    case originModuleDeclarationTypes.typeAliases |> FastDict.get expressionReference.name of
                                        Just originTypeAliasDeclaration ->
                                            case ( originTypeAliasDeclaration.recordFieldOrder, originTypeAliasDeclaration.type_ ) of
                                                ( Just fieldOrder, TypeNotVariable (TypeRecord fields) ) ->
                                                    Ok
                                                        { usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
                                                        , node =
                                                            { range = expressionReference.fullRange
                                                            , value =
                                                                { qualification = expressionReference.qualification
                                                                , moduleOrigin = moduleOrigin
                                                                , name = expressionReference.name
                                                                }
                                                            , type_ =
                                                                fieldOrder
                                                                    |> List.foldr
                                                                        (\fieldName outputTypeSoFar ->
                                                                            case fields |> FastDict.get fieldName of
                                                                                Nothing ->
                                                                                    outputTypeSoFar

                                                                                Just fieldValueType ->
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                fieldValueType
                                                                                                    |> typeMapVariables
                                                                                                        (\name ->
                                                                                                            ( context.path, name )
                                                                                                        )
                                                                                            , output = outputTypeSoFar
                                                                                            }
                                                                                        )
                                                                        )
                                                                        (TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin = moduleOrigin
                                                                                , name = expressionReference.name
                                                                                , arguments =
                                                                                    originTypeAliasDeclaration.parameters
                                                                                        |> List.map
                                                                                            (\parameterName ->
                                                                                                TypeVariable ( context.path, parameterName )
                                                                                            )
                                                                                }
                                                                            )
                                                                        )
                                                            }
                                                        }

                                                _ ->
                                                    Err
                                                        ("no value/function/port/variant/record type alias constructor was found in the origin module of the reference "
                                                            ++ qualifiedToString
                                                                { qualification = moduleOrigin
                                                                , name = expressionReference.name
                                                                }
                                                        )

                                        Nothing ->
                                            Err
                                                ("No value/function/port/variant/record type alias constructor found in the origin module of the reference "
                                                    ++ qualifiedToString
                                                        { qualification = moduleOrigin, name = expressionReference.name }
                                                )


usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert :
    TypeVariableFromContext
    -> TypeVariableFromContext
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert partialVariable use usesOfTypeVariablesFromPartiallyInferredDeclarations =
    usesOfTypeVariablesFromPartiallyInferredDeclarations
        |> FastDict.update partialVariable
            (\maybeUsesSoFar ->
                Just
                    (case maybeUsesSoFar of
                        Nothing ->
                            FastSet.singleton use

                        Just usesSoFar ->
                            usesSoFar |> FastSet.insert use
                    )
            )


usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3 :
    FastDict.Dict
        TypeVariableFromContext
        (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge3 a b c =
    usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
        (usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
            a
            b
        )
        c


usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge :
    FastDict.Dict
        TypeVariableFromContext
        (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    ->
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge a b =
    FastDict.merge
        (\variable uses soFar ->
            soFar |> FastDict.insert variable uses
        )
        (\variable usesA usesB soFar ->
            soFar
                |> FastDict.insert variable
                    (FastSet.union usesA usesB)
        )
        (\variable uses soFar ->
            soFar |> FastDict.insert variable uses
        )
        a
        b
        FastDict.empty


letDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.LetDeclaration
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            }
letDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letDeclaration) =
    case letDeclaration of
        Elm.Syntax.Expression.LetDestructuring letDestructuringPattern letDestructuringExpression ->
            resultAndThen2
                (\patternInferred expressionInferred ->
                    Result.andThen
                        (\patternExpressionUnifiedType ->
                            Result.map
                                (\fullSubstitutions ->
                                    { substitutions = fullSubstitutions
                                    , introducedExpressionVariables =
                                        patternInferred |> patternTypedNodeIntroducedVariables
                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                        expressionInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    , node =
                                        { range = letDeclarationRange
                                        , declaration =
                                            LetDestructuring
                                                { pattern = patternInferred
                                                , expression = expressionInferred.node
                                                }
                                        }
                                    }
                                )
                                (variableSubstitutionsMerge context.declarationTypes
                                    expressionInferred.substitutions
                                    patternExpressionUnifiedType.substitutions
                                )
                        )
                        (typeUnify context.declarationTypes
                            patternInferred.type_
                            expressionInferred.node.type_
                        )
                )
                (letDestructuringPattern
                    |> patternTypeInfer
                        { path = "pattern" :: context.path
                        , declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        }
                )
                (letDestructuringExpression
                    |> expressionTypeInfer
                        (context |> expressionContextToInPath "expression")
                )

        Elm.Syntax.Expression.LetFunction letValueOrFunction ->
            letFunctionOrValueDeclarationTypeInfer context
                (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction)
                |> Result.map
                    (\letFunctionOrValueDeclarationInferred ->
                        { substitutions = letFunctionOrValueDeclarationInferred.substitutions
                        , introducedExpressionVariables = FastDict.empty
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            letFunctionOrValueDeclarationInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                        , node = letFunctionOrValueDeclarationInferred.node
                        }
                    )


letFunctionOrValueDeclarationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Function
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            }
letFunctionOrValueDeclarationTypeInfer context (Elm.Syntax.Node.Node letDeclarationRange letValueOrFunction) =
    let
        implementation : Elm.Syntax.Expression.FunctionImplementation
        implementation =
            letValueOrFunction.declaration |> Elm.Syntax.Node.value
    in
    Result.andThen
        (\argumentsInferred ->
            let
                letDeclarationTypeVariable : TypeVariableFromContext
                letDeclarationTypeVariable =
                    ( context.path, "type" )

                name : String
                name =
                    implementation.name |> Elm.Syntax.Node.value
            in
            Result.andThen
                (\resultInferred ->
                    let
                        letDeclarationPartiallyInferredType : Type TypeVariableFromContext
                        letDeclarationPartiallyInferredType =
                            argumentsInferred.nodesReverse
                                |> List.foldl
                                    (\parameterTypedNode outputSoFar ->
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = parameterTypedNode.type_
                                                , output = outputSoFar
                                                }
                                            )
                                    )
                                    resultInferred.node.type_
                    in
                    Result.andThen
                        (\fullSubstitutionsIgnoringAnnotation ->
                            case letValueOrFunction.signature of
                                Nothing ->
                                    Ok
                                        { substitutions = fullSubstitutionsIgnoringAnnotation
                                        , node =
                                            { range = letDeclarationRange
                                            , declaration =
                                                LetValueOrFunctionDeclaration
                                                    { signature =
                                                        Nothing
                                                    , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                    , name = name
                                                    , parameters =
                                                        argumentsInferred.nodesReverse
                                                            |> List.reverse
                                                    , result = resultInferred.node
                                                    , type_ = letDeclarationPartiallyInferredType
                                                    }
                                            }
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        }

                                Just (Elm.Syntax.Node.Node signatureRange letValueOrFunctionSignature) ->
                                    Result.andThen
                                        (\annotationAsType ->
                                            Result.andThen
                                                (\typeUnifiedWithAnnotation ->
                                                    Result.map
                                                        (\fullSubstitutions ->
                                                            { substitutions = fullSubstitutions
                                                            , node =
                                                                { range = letDeclarationRange
                                                                , declaration =
                                                                    LetValueOrFunctionDeclaration
                                                                        { signature =
                                                                            Just
                                                                                { range = signatureRange
                                                                                , nameRange =
                                                                                    letValueOrFunctionSignature.name |> Elm.Syntax.Node.range
                                                                                , annotationType =
                                                                                    letValueOrFunctionSignature.typeAnnotation
                                                                                        |> Elm.Syntax.Node.value
                                                                                , annotationTypeRange =
                                                                                    letValueOrFunctionSignature.typeAnnotation
                                                                                        |> Elm.Syntax.Node.range
                                                                                }
                                                                        , nameRange = implementation.name |> Elm.Syntax.Node.range
                                                                        , name = name
                                                                        , parameters =
                                                                            argumentsInferred.nodesReverse
                                                                                |> List.reverse
                                                                        , result = resultInferred.node
                                                                        , type_ = typeUnifiedWithAnnotation.type_
                                                                        }
                                                                }
                                                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                                resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                            }
                                                        )
                                                        (variableSubstitutionsMerge context.declarationTypes
                                                            fullSubstitutionsIgnoringAnnotation
                                                            typeUnifiedWithAnnotation.substitutions
                                                        )
                                                )
                                                (typeUnify context.declarationTypes
                                                    letDeclarationPartiallyInferredType
                                                    (annotationAsType
                                                        |> typeMapVariables
                                                            (\variable ->
                                                                ( [ context.containingDeclarationName ], variable )
                                                            )
                                                    )
                                                )
                                        )
                                        (letValueOrFunctionSignature.typeAnnotation
                                            |> Elm.Syntax.Node.value
                                            |> syntaxToType context.moduleOriginLookup
                                        )
                        )
                        (variableSubstitutionsMerge context.declarationTypes
                            resultInferred.substitutions
                            (variableSubstitutionsFromVariableToType
                                letDeclarationTypeVariable
                                letDeclarationPartiallyInferredType
                            )
                        )
                )
                (implementation.expression
                    |> expressionTypeInfer
                        { containingDeclarationName = context.containingDeclarationName
                        , path = "letDeclarationResult" :: context.path
                        , declarationTypes = context.declarationTypes
                        , moduleOriginLookup = context.moduleOriginLookup
                        , partiallyInferredDeclarationTypes =
                            context.partiallyInferredDeclarationTypes
                                |> -- elm declarations do not allow "polymorphic recursion"
                                   -- https://github.com/elm/compiler/issues/2275
                                   -- so instead of putting it in partiallyInferredDeclarationTypes
                                   -- we treat it as an introduced variable (sharing the same type variables)
                                   FastDict.remove name
                        , locallyIntroducedExpressionVariables =
                            FastDict.union
                                argumentsInferred.introducedExpressionVariables
                                context.locallyIntroducedExpressionVariables
                                |> FastDict.insert name
                                    (TypeVariable letDeclarationTypeVariable)
                        }
                )
        )
        (implementation.arguments
            |> parameterPatternsTypeInfer
                { path = context.path
                , declarationTypes = context.declarationTypes
                , moduleOriginLookup = context.moduleOriginLookup
                }
        )


moduleNameToString : Elm.Syntax.ModuleName.ModuleName -> String
moduleNameToString moduleName =
    moduleName |> String.join "."


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toLower headChar) tailString


expressionInfixOperationTypeInfer :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    , partiallyInferredDeclarationTypes :
        FastDict.Dict String (Type TypeVariableFromContext)
    , moduleOriginLookup : ModuleOriginLookup
    , containingDeclarationName : String
    , path : List String
    }
    ->
        { fullRange : Elm.Syntax.Range.Range
        , operator : String
        , left : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        , right : Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionInfixOperationTypeInfer context infixOperation =
    resultAndThen3
        (\operatorAsFunctionType leftInferred rightInferred ->
            let
                resultType : Type TypeVariableFromContext
                resultType =
                    TypeVariable ( context.path, "operationResult" )
            in
            Result.andThen
                (\unifiedType ->
                    Result.andThen
                        (\leftRightSubstitutions ->
                            { substitutions = leftRightSubstitutions
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                usesOfTypeVariablesFromPartiallyInferredDeclarationsMerge
                                    leftInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    rightInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                            , node =
                                { range = infixOperation.fullRange
                                , value =
                                    ExpressionInfixOperation
                                        { symbol = infixOperation.operator
                                        , left = leftInferred.node
                                        , right = rightInferred.node
                                        }
                                , type_ = resultType
                                }
                            }
                                |> expressionTypeInferResultAddOrApplySubstitutions
                                    { declarationTypes = context.declarationTypes
                                    , locallyIntroducedExpressionVariables =
                                        context.locallyIntroducedExpressionVariables
                                    }
                                    unifiedType.substitutions
                        )
                        (variableSubstitutionsMerge context.declarationTypes
                            leftInferred.substitutions
                            rightInferred.substitutions
                        )
                )
                (typeUnify context.declarationTypes
                    operatorAsFunctionType
                    (TypeNotVariable
                        (TypeFunction
                            { input = leftInferred.node.type_
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = rightInferred.node.type_
                                        , output = resultType
                                        }
                                    )
                            }
                        )
                    )
                )
        )
        (operatorFunctionType
            { path = context.path
            , moduleOriginLookup = context.moduleOriginLookup
            }
            infixOperation.operator
        )
        (infixOperation.left
            |> expressionTypeInfer
                (context
                    |> expressionContextToInPath "left"
                )
        )
        (infixOperation.right
            |> expressionTypeInfer
                (context
                    |> expressionContextToInPath "right"
                )
        )


operatorFunctionType :
    { path : List String, moduleOriginLookup : ModuleOriginLookup }
    -> String
    -> Result String (Type TypeVariableFromContext)
operatorFunctionType context operator =
    case operator of
        "|>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = a
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                    , output = b
                                    }
                                )
                        }
                    )
                )

        "<|" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        }
                    )
                )

        ">>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = a
                                    , output = b
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = b
                                                , output = c
                                                }
                                            )
                                    , output =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = c
                                                }
                                            )
                                    }
                                )
                        }
                    )
                )

        "<<" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            TypeNotVariable
                                (TypeFunction
                                    { input = b
                                    , output = c
                                    }
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = b
                                                }
                                            )
                                    , output =
                                        TypeNotVariable
                                            (TypeFunction
                                                { input = a
                                                , output = c
                                                }
                                            )
                                    }
                                )
                        }
                    )
                )

        "++" ->
            let
                appendable : Type TypeVariableFromContext
                appendable =
                    TypeVariable ( context.path, "appendable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = appendable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = appendable
                                    , output = appendable
                                    }
                                )
                        }
                    )
                )

        "==" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.path, "equatable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = equatable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = equatable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "/=" ->
            let
                equatable : Type TypeVariableFromContext
                equatable =
                    TypeVariable ( context.path, "equatable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = equatable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = equatable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "::" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "element" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = a
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeListList a
                                    , output = typeListList a
                                    }
                                )
                        }
                    )
                )

        "*" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "+" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "-" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "/" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsFloat
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsFloat
                                    , output = typeBasicsFloat
                                    }
                                )
                        }
                    )
                )

        "^" ->
            let
                number : Type TypeVariableFromContext
                number =
                    TypeVariable ( context.path, "number" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = number
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = number
                                    , output = number
                                    }
                                )
                        }
                    )
                )

        "<=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        ">=" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        ">" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "<" ->
            let
                comparable : Type TypeVariableFromContext
                comparable =
                    TypeVariable ( context.path, "comparable" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = comparable
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = comparable
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "//" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsInt
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsInt
                                    , output = typeBasicsInt
                                    }
                                )
                        }
                    )
                )

        "&&" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsBool
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsBool
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "||" ->
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeBasicsBool
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeBasicsBool
                                    , output = typeBasicsBool
                                    }
                                )
                        }
                    )
                )

        "|." ->
            Ok
                (if context.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( context.path, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( context.path, "problem" )

                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( context.path, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input = typeParserAdvancedParser varContext problem keep
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserAdvancedParser varContext problem ignore
                                        , output = typeParserAdvancedParser varContext problem keep
                                        }
                                    )
                            }
                        )

                 else
                    let
                        keep : Type TypeVariableFromContext
                        keep =
                            TypeVariable ( context.path, "keep" )

                        ignore : Type TypeVariableFromContext
                        ignore =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input = typeParserParser keep
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserParser ignore
                                        , output = typeParserParser keep
                                        }
                                    )
                            }
                        )
                )

        "|=" ->
            Ok
                (if context.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced then
                    let
                        varContext : Type TypeVariableFromContext
                        varContext =
                            TypeVariable ( context.path, "context" )

                        problem : Type TypeVariableFromContext
                        problem =
                            TypeVariable ( context.path, "problem" )

                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( context.path, "keep" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                typeParserAdvancedParser
                                    varContext
                                    problem
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = a
                                            , output = b
                                            }
                                        )
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserAdvancedParser varContext problem a
                                        , output = typeParserAdvancedParser varContext problem b
                                        }
                                    )
                            }
                        )

                 else
                    let
                        a : Type TypeVariableFromContext
                        a =
                            TypeVariable ( context.path, "keep" )

                        b : Type TypeVariableFromContext
                        b =
                            TypeVariable ( context.path, "ignore" )
                    in
                    TypeNotVariable
                        (TypeFunction
                            { input =
                                typeParserParser
                                    (TypeNotVariable
                                        (TypeFunction
                                            { input = a
                                            , output = b
                                            }
                                        )
                                    )
                            , output =
                                TypeNotVariable
                                    (TypeFunction
                                        { input = typeParserParser a
                                        , output = typeParserParser b
                                        }
                                    )
                            }
                        )
                )

        "</>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                c : Type TypeVariableFromContext
                c =
                    TypeVariable ( context.path, "c" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input = typeUrlParserParser a b
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeUrlParserParser b c
                                    , output = typeUrlParserParser a c
                                    }
                                )
                        }
                    )
                )

        "<?>" ->
            let
                a : Type TypeVariableFromContext
                a =
                    TypeVariable ( context.path, "a" )

                b : Type TypeVariableFromContext
                b =
                    TypeVariable ( context.path, "b" )

                query : Type TypeVariableFromContext
                query =
                    TypeVariable ( context.path, "query" )
            in
            Ok
                (TypeNotVariable
                    (TypeFunction
                        { input =
                            typeUrlParserParser
                                a
                                (TypeNotVariable
                                    (TypeFunction
                                        { input = query
                                        , output = b
                                        }
                                    )
                                )
                        , output =
                            TypeNotVariable
                                (TypeFunction
                                    { input = typeUrlParserQueryParser query
                                    , output = typeUrlParserParser a b
                                    }
                                )
                        }
                    )
                )

        unknownOperator ->
            Err ("unknown operator (" ++ unknownOperator ++ ")")


expressionContextToInPath :
    String
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , partiallyInferredDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
    ->
        { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        , locallyIntroducedExpressionVariables :
            FastDict.Dict String (Type TypeVariableFromContext)
        , partiallyInferredDeclarationTypes :
            FastDict.Dict String (Type TypeVariableFromContext)
        , containingDeclarationName : String
        , path : List String
        , moduleOriginLookup : ModuleOriginLookup
        }
expressionContextToInPath innermostPathDescription context =
    { containingDeclarationName = context.containingDeclarationName
    , path = innermostPathDescription :: context.path
    , declarationTypes = context.declarationTypes
    , locallyIntroducedExpressionVariables =
        context.locallyIntroducedExpressionVariables
    , partiallyInferredDeclarationTypes =
        context.partiallyInferredDeclarationTypes
    , moduleOriginLookup = context.moduleOriginLookup
    }


{-| Infer types of
value/[`Elm.Syntax.Expression.Function`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression#Function) declarations
in a module.

    import Elm.Syntax.Node
    import Elm.Syntax.Expression
    import ElmSyntaxTypeInfer


    [ { declaration =
            Elm.Syntax.Node.empty
                { name = Elm.Syntax.Node.empty "hello"
                , expression =
                    Elm.Syntax.Node.empty
                        (Elm.Syntax.Expression.Literal "world")
                , arguments = []
                }
      , signature = Nothing
      , documentation = Nothing
      }
    ]
        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
            { importedTypes = ElmSyntaxTypeInfer.elmCoreTypes
            , moduleOriginLookup = exampleModuleOriginLookup
            , otherModuleDeclaredTypes =
                []
                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                        exampleModuleOriginLookup
                    |> .types
            }
    -->
    Ok
        (FastDict.singleton "hello"
            { type_ =
                ElmSyntaxTypeInfer.TypeNotVariable
                    (ElmSyntaxTypeInfer.TypeConstruct
                        { moduleOrigin = [ "String" ], name = "String", arguments = [] }
                    )
            ...
            }
        )


    exampleModuleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
    exampleModuleOriginLookup =
        []
            |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                ElmSyntaxTypeInfer.elmCoreTypes
    
See [`ModuleTypes`](#ModuleTypes) and [`ModuleOriginLookup`](#ModuleOriginLookup)

-}
valueAndFunctionDeclarations :
    { importedTypes :
        FastDict.Dict
            Elm.Syntax.ModuleName.ModuleName
            ModuleTypes
    , moduleOriginLookup : ModuleOriginLookup
    , otherModuleDeclaredTypes : ModuleTypes
    }
    -> List Elm.Syntax.Expression.Function
    ->
        Result
            String
            (FastDict.Dict
                String
                { nameRange : Elm.Syntax.Range.Range
                , documentation :
                    Maybe
                        { content : String
                        , range : Elm.Syntax.Range.Range
                        }
                , signature :
                    Maybe
                        { range : Elm.Syntax.Range.Range
                        , nameRange : Elm.Syntax.Range.Range
                        , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                        , annotationTypeRange : Elm.Syntax.Range.Range
                        }
                , parameters :
                    List (TypedNode (Pattern (Type String)) (Type String))
                , result : TypedNode (Expression (Type String)) (Type String)
                , type_ : Type String
                }
            )
valueAndFunctionDeclarations typesAndOriginLookup syntaxValueAndFunctionDeclarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            { keepOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.keepOperatorIsExposedFromParserAdvanced
            , ignoreOperatorIsExposedFromParserAdvanced =
                typesAndOriginLookup.moduleOriginLookup.ignoreOperatorIsExposedFromParserAdvanced
            , typeConstructs =
                typesAndOriginLookup.moduleOriginLookup.typeConstructs
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> fastDictMapToFastDict
                                (\typeAliasName _ ->
                                    { key = ( [], typeAliasName ), value = [] }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                            |> FastDict.foldl
                                (\choiceTypeName _ soFar ->
                                    soFar
                                        |> FastDict.insert ( [], choiceTypeName ) []
                                )
                                FastDict.empty
                        )
            , references =
                typesAndOriginLookup.moduleOriginLookup.references
                    |> FastDict.union
                        (syntaxValueAndFunctionDeclarations
                            |> listMapToFastDict
                                (\valueOrFunctionDeclaration ->
                                    { key =
                                        ( []
                                        , valueOrFunctionDeclaration.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .name
                                            |> Elm.Syntax.Node.value
                                        )
                                    , value = []
                                    }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                            |> fastDictMapToFastDict
                                (\signatureName _ ->
                                    { key = ( [], signatureName ), value = [] }
                                )
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                            |> FastDict.foldl
                                (\typeAliasName info soFar ->
                                    case info.recordFieldOrder of
                                        Nothing ->
                                            soFar

                                        Just _ ->
                                            soFar |> FastDict.insert ( [], typeAliasName ) []
                                )
                                FastDict.empty
                        )
                    |> FastDict.union
                        (typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                            |> FastDict.foldl
                                (\_ info soFar ->
                                    soFar
                                        |> FastDict.union
                                            (info.variants
                                                |> fastDictMapToFastDict
                                                    (\variantName _ ->
                                                        { key = ( [], variantName ), value = [] }
                                                    )
                                            )
                                )
                                FastDict.empty
                        )
            }

        acrossValueAndFunctionDeclarationsToInfer :
            { partiallyInferredDeclarationTypes :
                FastDict.Dict String (Type TypeVariableFromContext)
            , annotated : FastDict.Dict String (Type String)
            }
        acrossValueAndFunctionDeclarationsToInfer =
            syntaxValueAndFunctionDeclarations
                |> List.foldl
                    (\syntaxValueOrFunctionDeclaration soFar ->
                        let
                            name : String
                            name =
                                syntaxValueOrFunctionDeclaration.declaration
                                    |> Elm.Syntax.Node.value
                                    |> .name
                                    |> Elm.Syntax.Node.value
                        in
                        case
                            syntaxValueOrFunctionDeclaration.signature
                                |> Maybe.andThen
                                    (\(Elm.Syntax.Node.Node _ signature) ->
                                        signature.typeAnnotation
                                            |> Elm.Syntax.Node.value
                                            |> syntaxToType moduleOriginLookup
                                            |> Result.toMaybe
                                    )
                        of
                            Just type_ ->
                                { partiallyInferredDeclarationTypes =
                                    soFar.partiallyInferredDeclarationTypes
                                , annotated =
                                    soFar.annotated
                                        |> FastDict.insert name type_
                                }

                            Nothing ->
                                { annotated = soFar.annotated
                                , partiallyInferredDeclarationTypes =
                                    soFar.partiallyInferredDeclarationTypes
                                        |> FastDict.insert name
                                            (TypeVariable ( [ name ], "type" ))
                                }
                    )
                    { partiallyInferredDeclarationTypes = FastDict.empty
                    , annotated = FastDict.empty
                    }

        declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
        declarationTypes =
            typesAndOriginLookup.importedTypes
                |> FastDict.map
                    (\moduleName moduleDeclarationTypes ->
                        moduleDeclarationTypes
                            |> moduleTypesSetLocalTypesToOrigin moduleName
                    )
                |> FastDict.insert []
                    { signatures =
                        FastDict.union
                            typesAndOriginLookup.otherModuleDeclaredTypes.signatures
                            acrossValueAndFunctionDeclarationsToInfer.annotated
                    , typeAliases = typesAndOriginLookup.otherModuleDeclaredTypes.typeAliases
                    , choiceTypes = typesAndOriginLookup.otherModuleDeclaredTypes.choiceTypes
                    }
    in
    syntaxValueAndFunctionDeclarations
        |> listFoldlWhileOkFrom
            { substitutions = variableSubstitutionsNone
            , usesOfTypeVariablesFromPartiallyInferredDeclarations = FastDict.empty
            , declarationsTyped = FastDict.empty
            }
            (\valueOrFunctionDeclarationToInfer soFar ->
                let
                    implementation : Elm.Syntax.Expression.FunctionImplementation
                    implementation =
                        valueOrFunctionDeclarationToInfer.declaration
                            |> Elm.Syntax.Node.value

                    name : String
                    name =
                        implementation.name |> Elm.Syntax.Node.value
                in
                Result.andThen
                    (\parametersInferred ->
                        let
                            resultTypeVariable : TypeVariableFromContext
                            resultTypeVariable =
                                ( [ name ], "declarationResult" )

                            inferredFullType : Type TypeVariableFromContext
                            inferredFullType =
                                parametersInferred.nodesReverse
                                    |> List.foldl
                                        (\argumentTypedNode typeSoFar ->
                                            TypeNotVariable
                                                (TypeFunction
                                                    { input = argumentTypedNode.type_
                                                    , output = typeSoFar
                                                    }
                                                )
                                        )
                                        (TypeVariable resultTypeVariable)

                            fullType : Type TypeVariableFromContext
                            fullType =
                                case acrossValueAndFunctionDeclarationsToInfer.annotated |> FastDict.get name of
                                    Just annotationType ->
                                        annotationType
                                            |> typeMapVariables
                                                (\variable ->
                                                    ( [ name ], variable )
                                                )

                                    Nothing ->
                                        inferredFullType
                        in
                        Result.andThen
                            (\resultInferred ->
                                Result.map
                                    (\soFarAndArgumentAndResultAndTypeUnifySubstitutions ->
                                        { usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            FastDict.union
                                                soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                resultInferred.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        , substitutions =
                                            soFarAndArgumentAndResultAndTypeUnifySubstitutions
                                        , declarationsTyped =
                                            FastDict.insert name
                                                { nameRange = implementation.name |> Elm.Syntax.Node.range
                                                , documentation =
                                                    case valueOrFunctionDeclarationToInfer.documentation of
                                                        Nothing ->
                                                            Nothing

                                                        Just (Elm.Syntax.Node.Node documentationRange documentationContent) ->
                                                            Just
                                                                { range = documentationRange
                                                                , content = documentationContent
                                                                }
                                                , signature =
                                                    case valueOrFunctionDeclarationToInfer.signature of
                                                        Nothing ->
                                                            Nothing

                                                        Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                                            Just
                                                                { range = signatureRange
                                                                , nameRange = signature.name |> Elm.Syntax.Node.range
                                                                , annotationType = signature.typeAnnotation |> Elm.Syntax.Node.value
                                                                , annotationTypeRange = signature.typeAnnotation |> Elm.Syntax.Node.range
                                                                }
                                                , result = resultInferred.node
                                                , type_ = fullType
                                                , parameters =
                                                    parametersInferred.nodesReverse |> List.reverse
                                                }
                                                soFar.declarationsTyped
                                        }
                                    )
                                    (case valueOrFunctionDeclarationToInfer.signature of
                                        Just _ ->
                                            Result.andThen
                                                (\inferredUnifiedWithAnnotated ->
                                                    variableSubstitutionsMerge3 declarationTypes
                                                        soFar.substitutions
                                                        resultInferred.substitutions
                                                        inferredUnifiedWithAnnotated.substitutions
                                                )
                                                (typeUnify declarationTypes
                                                    fullType
                                                    inferredFullType
                                                )

                                        Nothing ->
                                            let
                                                fullTypeVariable : TypeVariableFromContext
                                                fullTypeVariable =
                                                    ( [ name ], "type" )
                                            in
                                            variableSubstitutionsMerge4 declarationTypes
                                                soFar.substitutions
                                                resultInferred.substitutions
                                                (variableSubstitutionsFromVariableToType
                                                    resultTypeVariable
                                                    resultInferred.node.type_
                                                )
                                                (variableSubstitutionsFromVariableToType
                                                    fullTypeVariable
                                                    fullType
                                                )
                                    )
                            )
                            (implementation.expression
                                |> expressionTypeInfer
                                    { declarationTypes = declarationTypes
                                    , locallyIntroducedExpressionVariables =
                                        case valueOrFunctionDeclarationToInfer.signature of
                                            Just _ ->
                                                parametersInferred.introducedExpressionVariables

                                            Nothing ->
                                                -- elm declarations do not allow "polymorphic recursion"
                                                -- https://github.com/elm/compiler/issues/2275
                                                -- so instead of putting it in partiallyInferredDeclarationTypes
                                                -- we treat it as an introduced variable (sharing the same type variables)
                                                parametersInferred.introducedExpressionVariables
                                                    |> FastDict.insert name fullType
                                    , partiallyInferredDeclarationTypes =
                                        acrossValueAndFunctionDeclarationsToInfer.partiallyInferredDeclarationTypes
                                    , containingDeclarationName = name
                                    , path = [ "declarationResult", name ]
                                    , moduleOriginLookup = moduleOriginLookup
                                    }
                            )
                    )
                    (implementation.arguments
                        |> parameterPatternsTypeInfer
                            { declarationTypes = declarationTypes
                            , path = [ name ]
                            , moduleOriginLookup = moduleOriginLookup
                            }
                    )
                    |> Result.mapError
                        (\inferError ->
                            "inferring the value/function declaration "
                                ++ name
                                ++ ", I found a problem: "
                                ++ inferError
                        )
            )
        |> Result.andThen
            (\intermediate ->
                intermediate.declarationsTyped
                    |> valueOrFunctionDeclarationsApplySubstitutions
                        { declarationTypes = declarationTypes
                        , substitutions = intermediate.substitutions
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            intermediate.usesOfTypeVariablesFromPartiallyInferredDeclarations
                        }
            )
        |> Result.map
            (\fullySubstitutedDeclarationsTypedWithContext ->
                fullySubstitutedDeclarationsTypedWithContext
                    |> FastDict.map
                        (\_ declaration ->
                            declaration |> declarationValueOrFunctionInfoDisambiguateTypeVariables
                        )
            )


moduleTypesSetLocalTypesToOrigin : Elm.Syntax.ModuleName.ModuleName -> ModuleTypes -> ModuleTypes
moduleTypesSetLocalTypesToOrigin moduleOrigin moduleTypes =
    { signatures =
        moduleTypes.signatures
            |> FastDict.map
                (\_ type_ ->
                    type_ |> typeSetLocalToOrigin moduleOrigin
                )
    , typeAliases =
        moduleTypes.typeAliases
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , recordFieldOrder = typeAlias.recordFieldOrder
                    , type_ =
                        typeAlias.type_
                            |> typeSetLocalToOrigin moduleOrigin
                    }
                )
    , choiceTypes =
        moduleTypes.choiceTypes
            |> FastDict.map
                (\_ typeAlias ->
                    { parameters = typeAlias.parameters
                    , variants =
                        typeAlias.variants
                            |> FastDict.map
                                (\_ values ->
                                    values
                                        |> List.map
                                            (\type_ ->
                                                type_ |> typeSetLocalToOrigin moduleOrigin
                                            )
                                )
                    }
                )
    }


typeSetLocalToOrigin : Elm.Syntax.ModuleName.ModuleName -> Type variable -> Type variable
typeSetLocalToOrigin moduleOrigin type_ =
    case type_ of
        TypeVariable variable ->
            TypeVariable variable

        TypeNotVariable typeNotVariable ->
            TypeNotVariable
                (typeNotVariableSetLocalToOrigin moduleOrigin typeNotVariable)


typeNotVariableSetLocalToOrigin :
    Elm.Syntax.ModuleName.ModuleName
    -> TypeNotVariable variable
    -> TypeNotVariable variable
typeNotVariableSetLocalToOrigin moduleOrigin type_ =
    case type_ of
        TypeConstruct typeConstruct ->
            TypeConstruct
                { name = typeConstruct.name
                , moduleOrigin =
                    case typeConstruct.moduleOrigin of
                        [] ->
                            moduleOrigin

                        moduleOriginPart0 :: moduleOriginPart1Up ->
                            moduleOriginPart0 :: moduleOriginPart1Up
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }

        TypeUnit ->
            TypeUnit

        TypeFunction parts ->
            TypeFunction
                { input =
                    parts.input
                        |> typeSetLocalToOrigin moduleOrigin
                , output =
                    parts.output
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTuple parts ->
            TypeTuple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeTriple parts ->
            TypeTriple
                { part0 =
                    parts.part0
                        |> typeSetLocalToOrigin moduleOrigin
                , part1 =
                    parts.part1
                        |> typeSetLocalToOrigin moduleOrigin
                , part2 =
                    parts.part2
                        |> typeSetLocalToOrigin moduleOrigin
                }

        TypeRecord fields ->
            TypeRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue
                                |> typeSetLocalToOrigin moduleOrigin
                        )
                )

        TypeRecordExtension typeRecordExtension ->
            TypeRecordExtension
                { recordVariable = typeRecordExtension.recordVariable
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> typeSetLocalToOrigin moduleOrigin
                            )
                }


variableSubstitutionsFromVariableToType :
    TypeVariableFromContext
    -> Type TypeVariableFromContext
    -> VariableSubstitutions
variableSubstitutionsFromVariableToType variableToReplace replacementType =
    case replacementType of
        TypeNotVariable replacementTypeNotVariable ->
            { variableToType =
                FastDict.singleton variableToReplace
                    replacementTypeNotVariable
            , equivalentVariables = []
            }

        TypeVariable replacementVariable ->
            { variableToType = FastDict.empty
            , equivalentVariables =
                [ FastSet.singleton variableToReplace
                    |> FastSet.insert replacementVariable
                ]
            }


type alias ValueOrFunctionDeclarationInfo type_ =
    { nameRange : Elm.Syntax.Range.Range
    , documentation :
        Maybe
            { content : String
            , range : Elm.Syntax.Range.Range
            }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters :
        List (TypedNode (Pattern type_) type_)
    , result : TypedNode (Expression type_) type_
    , type_ : type_
    }


type alias ModuleLevelDeclarationTypesAvailableInModule =
    FastDict.Dict
        -- `[]` means declared in the same module
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes


declarationValueOrFunctionInfoDisambiguateTypeVariables :
    ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    -> ValueOrFunctionDeclarationInfo (Type String)
declarationValueOrFunctionInfoDisambiguateTypeVariables declarationValueOrFunctionInfo =
    let
        globalTypeVariableDisambiguationLookup : FastDict.Dict TypeVariableFromContext String
        globalTypeVariableDisambiguationLookup =
            typeVariablesFromContextToDisambiguationLookup
                (declarationValueOrFunctionInfo
                    |> declarationValueOrFunctionInfoContainedGlobalTypeVariables
                    |> FastSet.map
                        (\( context, name ) ->
                            ( context |> List.reverse |> List.drop 1
                            , name
                            )
                        )
                )
    in
    declarationValueOrFunctionInfo
        |> declarationValueOrFunctionInfoMapTypeVariables
            (\( context, name ) ->
                globalTypeVariableDisambiguationLookup
                    |> FastDict.get
                        ( context |> List.reverse |> List.drop 1
                        , name
                        )
                    |> Maybe.withDefault
                        "thisIsABugInDisambiguationPleaseReportToElmSyntaxTypeInfer"
            )


declarationValueOrFunctionInfoContainedGlobalTypeVariables :
    ValueOrFunctionDeclarationInfo (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
declarationValueOrFunctionInfoContainedGlobalTypeVariables declarationValueOrFunction =
    FastSet.union
        (declarationValueOrFunction.parameters
            |> List.foldl
                (\parameter soFar ->
                    FastSet.union
                        (parameter
                            |> patternTypedNodeContainedTypeVariables
                        )
                        soFar
                )
                FastSet.empty
        )
        (FastSet.union
            (declarationValueOrFunction.type_
                |> typeContainedVariables
            )
            (declarationValueOrFunction.result
                |> expressionTypedNodeContainedTypeVariables
            )
        )


patternTypedNodeContainedTypeVariables :
    TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
patternTypedNodeContainedTypeVariables patternTypedNode =
    FastSet.union
        (patternTypedNode.type_
            |> typeContainedVariables
        )
        (patternTypedNode.value
            |> patternContainedTypeVariables
        )


patternContainedTypeVariables :
    Pattern (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
patternContainedTypeVariables pattern =
    case pattern of
        PatternIgnored ->
            FastSet.empty

        PatternUnit ->
            FastSet.empty

        PatternChar _ ->
            FastSet.empty

        PatternString _ ->
            FastSet.empty

        PatternInt _ ->
            FastSet.empty

        PatternVariable _ ->
            FastSet.empty

        PatternParenthesized inParens ->
            patternTypedNodeContainedTypeVariables
                inParens

        PatternAs patternAs ->
            patternTypedNodeContainedTypeVariables
                patternAs.pattern

        PatternTuple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternTriple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (parts.part1
                        |> patternTypedNodeContainedTypeVariables
                    )
                    (parts.part2
                        |> patternTypedNodeContainedTypeVariables
                    )
                )

        PatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head
                    |> patternTypedNodeContainedTypeVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeContainedTypeVariables
                )

        PatternListExact elements ->
            elements
                |> listMapAndFastSetsUnify
                    (\element ->
                        element
                            |> patternTypedNodeContainedTypeVariables
                    )

        PatternVariant patternVariant ->
            patternVariant.values
                |> listMapAndFastSetsUnify
                    (\value ->
                        value
                            |> patternTypedNodeContainedTypeVariables
                    )

        PatternRecord fields ->
            fields
                |> listMapAndFastSetsUnify
                    (\fieldTypedNode ->
                        fieldTypedNode.type_
                            |> typeContainedVariables
                    )


listMapAndFastSetsUnify : (a -> FastSet.Set comparable) -> List a -> FastSet.Set comparable
listMapAndFastSetsUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


listMapAndFastDictsUnify :
    (a -> FastDict.Dict comparable value)
    -> List a
    -> FastDict.Dict comparable value
listMapAndFastDictsUnify elementToSet elements =
    elements
        |> List.foldl
            (\element soFar ->
                FastDict.union
                    (element |> elementToSet)
                    soFar
            )
            FastDict.empty


expressionTypedNodeContainedTypeVariables :
    TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
expressionTypedNodeContainedTypeVariables expressionTypedNode =
    FastSet.union
        (expressionTypedNode.type_
            |> typeContainedVariables
        )
        (expressionTypedNode.value
            |> expressionContainedTypeVariables
        )


expressionContainedTypeVariables :
    Expression (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
expressionContainedTypeVariables expression =
    case expression of
        ExpressionUnit ->
            FastSet.empty

        ExpressionInteger _ ->
            FastSet.empty

        ExpressionFloat _ ->
            FastSet.empty

        ExpressionString _ ->
            FastSet.empty

        ExpressionChar _ ->
            FastSet.empty

        ExpressionReference _ ->
            FastSet.empty

        ExpressionOperatorFunction _ ->
            FastSet.empty

        ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ExpressionNegation negated ->
            expressionTypedNodeContainedTypeVariables
                negated

        ExpressionParenthesized inParens ->
            expressionTypedNodeContainedTypeVariables
                inParens

        ExpressionRecordAccess expressionRecordAccess ->
            expressionTypedNodeContainedTypeVariables
                expressionRecordAccess.record

        ExpressionInfixOperation expressionInfixOperation ->
            FastSet.union
                (expressionInfixOperation.left
                    |> expressionTypedNodeContainedTypeVariables
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTuple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (parts.part1
                    |> expressionTypedNodeContainedTypeVariables
                )

        ExpressionTriple parts ->
            FastSet.union
                (parts.part0
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (parts.part1
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (parts.part2
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionIfThenElse expressionIfThenElse ->
            FastSet.union
                (expressionIfThenElse.condition
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionIfThenElse.onTrue
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionIfThenElse.onFalse
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionList elements ->
            elements
                |> listMapAndFastSetsUnify
                    (\element ->
                        element
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionRecord fields ->
            fields
                |> listMapAndFastSetsUnify
                    (\field ->
                        field.value
                            |> expressionTypedNodeContainedTypeVariables
                    )

        ExpressionCall expressionCall ->
            FastSet.union
                (expressionCall.called
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionCall.argument0
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionCall.argument1Up
                        |> listMapAndFastSetsUnify
                            (\argument ->
                                argument
                                    |> expressionTypedNodeContainedTypeVariables
                            )
                    )
                )

        ExpressionLambda expressionLambda ->
            FastSet.union
                (expressionLambda.parameter0
                    |> patternTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionLambda.parameter1Up
                        |> listMapAndFastSetsUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (expressionLambda.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.union
                (expressionRecordUpdate.recordVariable.type_
                    |> typeContainedVariables
                )
                (FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeContainedTypeVariables
                    )
                    (expressionRecordUpdate.field1Up
                        |> listMapAndFastSetsUnify
                            (\field ->
                                field.value
                                    |> expressionTypedNodeContainedTypeVariables
                            )
                    )
                )

        ExpressionCaseOf expressionCaseOf ->
            FastSet.union
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeContainedTypeVariables
                )
                (FastSet.union
                    (expressionCaseOf.case0
                        |> expressionCaseOfCaseContainedTypeVariables
                    )
                    (expressionCaseOf.case1Up
                        |> listMapAndFastSetsUnify
                            expressionCaseOfCaseContainedTypeVariables
                    )
                )

        ExpressionLetIn expressionLetIn ->
            FastSet.union
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationContainedTypeVariables
                )
                (FastSet.union
                    (expressionLetIn.declaration1Up
                        |> listMapAndFastSetsUnify
                            (\letDeclaration ->
                                letDeclaration.declaration
                                    |> letDeclarationContainedTypeVariables
                            )
                    )
                    (expressionLetIn.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )


letDeclarationContainedTypeVariables :
    LetDeclaration (Type comparableTypeVariable)
    -> FastSet.Set comparableTypeVariable
letDeclarationContainedTypeVariables letDeclaration =
    case letDeclaration of
        LetDestructuring letDestructuring ->
            FastSet.union
                (letDestructuring.pattern
                    |> patternTypedNodeContainedTypeVariables
                )
                (letDestructuring.expression
                    |> expressionTypedNodeContainedTypeVariables
                )

        LetValueOrFunctionDeclaration letValueOrFunctionDeclaration ->
            FastSet.union
                (letValueOrFunctionDeclaration.type_
                    |> typeContainedVariables
                )
                (FastSet.union
                    (letValueOrFunctionDeclaration.parameters
                        |> listMapAndFastSetsUnify
                            (\parameter ->
                                parameter
                                    |> patternTypedNodeContainedTypeVariables
                            )
                    )
                    (letValueOrFunctionDeclaration.result
                        |> expressionTypedNodeContainedTypeVariables
                    )
                )


expressionCaseOfCaseContainedTypeVariables :
    { pattern : TypedNode (Pattern (Type comparableTypeVariable)) (Type comparableTypeVariable)
    , result : TypedNode (Expression (Type comparableTypeVariable)) (Type comparableTypeVariable)
    }
    -> FastSet.Set comparableTypeVariable
expressionCaseOfCaseContainedTypeVariables syntaxCase =
    FastSet.union
        (syntaxCase.pattern
            |> patternTypedNodeContainedTypeVariables
        )
        (syntaxCase.result
            |> expressionTypedNodeContainedTypeVariables
        )


createEquivalentVariablesToCondensedVariableLookup :
    List (FastSet.Set TypeVariableFromContext)
    -> Result String (FastDict.Dict TypeVariableFromContext TypeVariableFromContext)
createEquivalentVariablesToCondensedVariableLookup equivalentVariables =
    equivalentVariables
        |> listFoldlWhileOkFrom
            FastDict.empty
            (\equivalentVariableSet soFar ->
                Result.map
                    (\unifiedVariable ->
                        equivalentVariableSet
                            |> FastSet.foldl
                                (\variable soFarInSet ->
                                    soFarInSet
                                        |> FastDict.insert variable unifiedVariable
                                )
                                soFar
                    )
                    (equivalentVariablesCreateCondensedVariable equivalentVariableSet)
            )


equivalentVariablesGetSetThatContains :
    TypeVariableFromContext
    -> List (FastSet.Set TypeVariableFromContext)
    -> Maybe (FastSet.Set TypeVariableFromContext)
equivalentVariablesGetSetThatContains needle equivalentVariables =
    equivalentVariables
        |> listMapAndFirstJust
            (\equivalentVariableSet ->
                if equivalentVariableSet |> FastSet.member needle then
                    Just equivalentVariableSet

                else
                    Nothing
            )


listMapAndFirstJust : (a -> Maybe b) -> List a -> Maybe b
listMapAndFirstJust elementToMaybe list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case elementToMaybe head of
                Just headValue ->
                    Just headValue

                Nothing ->
                    listMapAndFirstJust elementToMaybe tail


valueOrFunctionDeclarationsApplySubstitutions :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , usesOfTypeVariablesFromPartiallyInferredDeclarations :
        FastDict.Dict
            TypeVariableFromContext
            (FastSet.Set TypeVariableFromContext)
    , substitutions : VariableSubstitutions
    }
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            (FastDict.Dict
                String
                (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            )
valueOrFunctionDeclarationsApplySubstitutions state declarationValueOrFunctionsSoFar =
    case state.substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            let
                partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariablesOrNothing :
                    Maybe
                        { condensedTypeVariableConstraint : TypeVariableConstraint
                        , affected : FastSet.Set TypeVariableFromContext
                        }
                partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariablesOrNothing =
                    state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                        |> FastDict.stoppableFoldl
                            (\uncondensedPartialTypeVariable uses _ ->
                                case
                                    (equivalentVariableSet0 :: equivalentVariableSet1Up)
                                        |> equivalentVariablesGetSetThatContains uncondensedPartialTypeVariable
                                        |> Maybe.andThen
                                            (\set ->
                                                set
                                                    |> equivalentVariablesCreateCondensedVariable
                                                    |> Result.toMaybe
                                            )
                                of
                                    Nothing ->
                                        FastDict.Continue Nothing

                                    Just condensedPartialTypeVariable ->
                                        case
                                            condensedPartialTypeVariable
                                                |> typeVariableIgnoringContext
                                                |> typeVariableConstraint
                                        of
                                            Nothing ->
                                                FastDict.Continue Nothing

                                            Just condensedTypeVariableConstraint ->
                                                let
                                                    sameCondensedTypeVariableConstraintWasAlreadyPresent : Bool
                                                    sameCondensedTypeVariableConstraintWasAlreadyPresent =
                                                        case
                                                            uncondensedPartialTypeVariable
                                                                |> typeVariableIgnoringContext
                                                                |> typeVariableConstraint
                                                        of
                                                            Just existingConstraint ->
                                                                existingConstraint == condensedTypeVariableConstraint

                                                            Nothing ->
                                                                False
                                                in
                                                if sameCondensedTypeVariableConstraintWasAlreadyPresent then
                                                    FastDict.Continue Nothing

                                                else
                                                    FastDict.Stop
                                                        (Just
                                                            { condensedTypeVariableConstraint = condensedTypeVariableConstraint
                                                            , affected =
                                                                uses
                                                                    |> FastSet.insert uncondensedPartialTypeVariable
                                                            }
                                                        )
                            )
                            Nothing
            in
            case partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariablesOrNothing of
                Nothing ->
                    case
                        createEquivalentVariablesToCondensedVariableLookup
                            (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    of
                        Err error ->
                            Err error

                        Ok variableToCondensedLookup ->
                            case
                                state.substitutions.variableToType
                                    |> variableToTypeSubstitutionsCondenseVariables state.declarationTypes
                                        variableToCondensedLookup
                            of
                                Err error ->
                                    Err error

                                Ok variableToTypeUsingCondensed ->
                                    valueOrFunctionDeclarationsApplySubstitutions
                                        { declarationTypes = state.declarationTypes
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                |> usesOfTypeVariablesFromPartiallyInferredDeclarationsCondenseVariables
                                                    variableToCondensedLookup
                                        , substitutions = variableToTypeUsingCondensed
                                        }
                                        (declarationValueOrFunctionsSoFar
                                            |> FastDict.map
                                                (\_ declarationValueOrFunctionToCondenseVariablesIn ->
                                                    declarationValueOrFunctionToCondenseVariablesIn
                                                        |> declarationValueOrFunctionInfoMapTypeVariables
                                                            (\variable ->
                                                                variableToCondensedLookup
                                                                    |> FastDict.get variable
                                                                    |> Maybe.withDefault variable
                                                            )
                                                )
                                        )

                Just partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariables ->
                    let
                        affectedCompatibilityWithAdditionalConstraint : Result String ()
                        affectedCompatibilityWithAdditionalConstraint =
                            partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariables.affected
                                |> FastSet.stoppableFoldl
                                    (\affected _ ->
                                        case
                                            affected
                                                |> typeVariableFromContextMergeConstraintWith
                                                    partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariables.condensedTypeVariableConstraint
                                        of
                                            Err error ->
                                                FastDict.Stop (Err error)

                                            Ok _ ->
                                                FastDict.Continue (Ok ())
                                    )
                                    (Ok ())
                    in
                    case affectedCompatibilityWithAdditionalConstraint of
                        Err error ->
                            Err error

                        Ok () ->
                            let
                                typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected : TypeVariableFromContext -> TypeVariableFromContext
                                typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected typeVariable =
                                    if
                                        partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariables.affected
                                            |> FastSet.member typeVariable
                                    then
                                        typeVariable
                                            |> typeVariableFromContextMergeConstraintWith
                                                partialTypeVariableThatGainsConstraintsAfterCondensingWithEquivalentVariables.condensedTypeVariableConstraint
                                            |> -- The case that type variables have non-compatible constraints (like number and appendable)
                                               -- is already caught in affectedCompatibilityWithAdditionalConstraint
                                               Result.withDefault typeVariable

                                    else
                                        typeVariable

                                equivalentVariablesWithConstrainedPartialTypeVariables : List (FastSet.Set TypeVariableFromContext)
                                equivalentVariablesWithConstrainedPartialTypeVariables =
                                    (equivalentVariableSet0 :: equivalentVariableSet1Up)
                                        |> List.map
                                            (\equivalentVariableSet ->
                                                equivalentVariableSet
                                                    |> FastSet.map
                                                        typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                            )

                                variableToTypeUsingCondensed :
                                    FastDict.Dict
                                        TypeVariableFromContext
                                        (TypeNotVariable TypeVariableFromContext)
                                variableToTypeUsingCondensed =
                                    state.substitutions.variableToType
                                        |> fastDictMapToFastDict
                                            (\substitutionVariable substitutionTypeNotVariable ->
                                                { key =
                                                    substitutionVariable
                                                        |> typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                                , value =
                                                    substitutionTypeNotVariable
                                                        |> typeNotVariableMapVariables
                                                            typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                                }
                                            )

                                usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed :
                                    FastDict.Dict
                                        TypeVariableFromContext
                                        (FastSet.Set TypeVariableFromContext)
                                usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed =
                                    state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        |> fastDictMapToFastDict
                                            (\partialTypeVariable uses ->
                                                { key =
                                                    partialTypeVariable
                                                        |> typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                                , value =
                                                    uses
                                                        |> FastSet.map
                                                            typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                                }
                                            )

                                declarationsUsingCondensed :
                                    FastDict.Dict
                                        String
                                        (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
                                declarationsUsingCondensed =
                                    declarationValueOrFunctionsSoFar
                                        |> FastDict.map
                                            (\_ declarationValueOrFunctionToCondenseVariablesIn ->
                                                declarationValueOrFunctionToCondenseVariablesIn
                                                    |> declarationValueOrFunctionInfoMapTypeVariables
                                                        typeVariableFromContextMergeConstraintWithPartialCondensedConstraintIfAffected
                                            )
                            in
                            valueOrFunctionDeclarationsApplySubstitutions
                                { declarationTypes = state.declarationTypes
                                , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                    usesOfTypeVariablesFromPartiallyInferredDeclarationsUsingCondensed
                                , substitutions =
                                    { variableToType = variableToTypeUsingCondensed
                                    , equivalentVariables = equivalentVariablesWithConstrainedPartialTypeVariables
                                    }
                                }
                                declarationsUsingCondensed

        [] ->
            let
                new :
                    { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations :
                        FastDict.Dict
                            TypeVariableFromContext
                            (TypeNotVariable TypeVariableFromContext)
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                        FastDict.Dict
                            TypeVariableFromContext
                            (FastSet.Set TypeVariableFromContext)
                    }
                new =
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ type_ uses soFar ->
                            uses
                                |> FastSet.foldl
                                    (\useVariable withUsesSoFar ->
                                        let
                                            ( useVariableContext, useVariableName ) =
                                                useVariable

                                            variableNameForUseFromMoreConcreteReplacementType : TypeVariableFromContext -> TypeVariableFromContext
                                            variableNameForUseFromMoreConcreteReplacementType ( moreConcreteReplacementTypeVariableContext, moreConcreteReplacementTypeVariableName ) =
                                                ( "_usedAs"
                                                    :: useVariableName
                                                    :: useVariableContext
                                                    ++ ("_from"
                                                            :: moreConcreteReplacementTypeVariableName
                                                            :: moreConcreteReplacementTypeVariableContext
                                                       )
                                                , "moreConcrete"
                                                )
                                        in
                                        { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                                            withUsesSoFar.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                                                |> FastDict.insert useVariable
                                                    (type_
                                                        |> typeNotVariableMapVariables
                                                            (\replacementTypeVariable ->
                                                                variableNameForUseFromMoreConcreteReplacementType
                                                                    replacementTypeVariable
                                                            )
                                                    )
                                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                            type_
                                                |> typeNotVariableContainedVariables
                                                |> FastSet.foldl
                                                    (\replacementTypeVariable newUsesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar ->
                                                        newUsesOfTypeVariablesFromPartiallyInferredDeclarationsSoFar
                                                            |> usesOfTypeVariablesFromPartiallyInferredDeclarationsMergeInsert
                                                                replacementTypeVariable
                                                                (variableNameForUseFromMoreConcreteReplacementType
                                                                    replacementTypeVariable
                                                                )
                                                    )
                                                    soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                        }
                                    )
                                    soFar
                        )
                        (\typeVariableFromPartiallyInferredDeclaration uses soFar ->
                            { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                                soFar.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                soFar.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                    |> FastDict.insert typeVariableFromPartiallyInferredDeclaration
                                        uses
                            }
                        )
                        state.substitutions.variableToType
                        state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                        { substitutionsOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                            FastDict.empty
                        }
            in
            if Basics.not (FastDict.isEmpty new.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations) then
                valueOrFunctionDeclarationsApplySubstitutions
                    { declarationTypes = state.declarationTypes
                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                        new.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    , substitutions =
                        { equivalentVariables = []
                        , variableToType =
                            FastDict.union
                                state.substitutions.variableToType
                                new.substitutionsOfTypeVariablesFromPartiallyInferredDeclarations
                        }
                    }
                    declarationValueOrFunctionsSoFar

            else
                case state.substitutions.variableToType |> FastDict.popMin of
                    Nothing ->
                        Ok declarationValueOrFunctionsSoFar

                    Just ( ( variableOfSubstitutionToApply, typeNotVariableOfSubstitutionToApply ), remainingVariableToType ) ->
                        case
                            declarationValueOrFunctionsSoFar
                                |> valueAndFunctionDeclarationsSubstituteVariableByNotVariable
                                    state.declarationTypes
                                    { variable = variableOfSubstitutionToApply
                                    , type_ = typeNotVariableOfSubstitutionToApply
                                    }
                        of
                            Err error ->
                                Err error

                            Ok substituted ->
                                case
                                    remainingVariableToType
                                        |> variableToTypeSubstitutionsSubstituteVariableByNotVariable
                                            state.declarationTypes
                                            { variable = variableOfSubstitutionToApply
                                            , type_ = typeNotVariableOfSubstitutionToApply
                                            }
                                of
                                    Err error ->
                                        Err error

                                    Ok remainingVariableToTypeAndSubstitutions ->
                                        case
                                            variableSubstitutionsMerge
                                                state.declarationTypes
                                                substituted.substitutions
                                                remainingVariableToTypeAndSubstitutions
                                        of
                                            Err error ->
                                                Err error

                                            Ok substitutionsAfterSubstitution ->
                                                valueOrFunctionDeclarationsApplySubstitutions
                                                    { declarationTypes = state.declarationTypes
                                                    , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                                                        state.usesOfTypeVariablesFromPartiallyInferredDeclarations
                                                    , substitutions = substitutionsAfterSubstitution
                                                    }
                                                    substituted.declarations


valueAndFunctionDeclarationsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        FastDict.Dict
            String
            (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
    ->
        Result
            String
            { declarations :
                FastDict.Dict
                    String
                    (ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext))
            , substitutions : VariableSubstitutions
            }
valueAndFunctionDeclarationsSubstituteVariableByNotVariable declarationTypes substitutionToApply valueAndFunctionDeclarationsToApplySubstitutionTo =
    valueAndFunctionDeclarationsToApplySubstitutionTo
        |> fastDictFoldlWhileOkFrom
            { substitutions = variableSubstitutionsNone
            , declarations = FastDict.empty
            }
            (\declarationName declarationToSubstituteIn soFar ->
                Result.andThen
                    (\declarationSubstituted ->
                        Result.map
                            (\fullSubstitutions ->
                                { substitutions = fullSubstitutions
                                , declarations =
                                    FastDict.insert declarationName
                                        declarationSubstituted.declaration
                                        soFar.declarations
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                soFar.substitutions
                                declarationSubstituted.substitutions
                            )
                    )
                    (declarationToSubstituteIn
                        |> declarationValueOrFunctionInfoSubstituteVariableByNotVariable
                            declarationTypes
                            substitutionToApply
                    )
                    |> Result.mapError
                        (\substitutionError ->
                            "I inferred various parts of the value/function declaration "
                                ++ declarationName
                                ++ " but there was a problem after substituting pieces of knowledge: "
                                ++ substitutionError
                        )
            )


variableToTypeSubstitutionsSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes variableToTypeSubstitutionToApply variableToTypeSubstitutions =
    variableToTypeSubstitutions
        |> fastDictFoldlWhileOkFrom
            variableSubstitutionsNone
            (\remainingVariable remainingReplacementTypeNotVariable soFar ->
                Result.andThen
                    (\replacementTypeSubstituted ->
                        variableSubstitutionsMerge3 declarationTypes
                            replacementTypeSubstituted.substitutions
                            { equivalentVariables = []
                            , variableToType =
                                FastDict.singleton remainingVariable
                                    replacementTypeSubstituted.type_
                            }
                            soFar
                    )
                    (remainingReplacementTypeNotVariable
                        |> typeNotVariableSubstituteVariableByNotVariable
                            declarationTypes
                            variableToTypeSubstitutionToApply
                    )
            )


variableToTypeSubstitutionsCondenseVariables :
    ModuleLevelDeclarationTypesAvailableInModule
    -> FastDict.Dict TypeVariableFromContext TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext (TypeNotVariable TypeVariableFromContext)
    -> Result String VariableSubstitutions
variableToTypeSubstitutionsCondenseVariables declarationTypes variableToCondensedLookup variableToType =
    variableToType
        |> fastDictFoldlWhileOkFrom
            variableSubstitutionsNone
            (\uncondensedVariable replacementType soFar ->
                case variableToCondensedLookup |> FastDict.get uncondensedVariable of
                    Nothing ->
                        Ok
                            { equivalentVariables = soFar.equivalentVariables
                            , variableToType =
                                soFar.variableToType
                                    |> FastDict.insert uncondensedVariable
                                        (replacementType
                                            |> typeNotVariableMapVariables
                                                (\variable ->
                                                    variableToCondensedLookup
                                                        |> FastDict.get variable
                                                        |> Maybe.withDefault variable
                                                )
                                        )
                            }

                    Just condensedVariable ->
                        let
                            replacementTypeUsingCondensedVariables : TypeNotVariable TypeVariableFromContext
                            replacementTypeUsingCondensedVariables =
                                replacementType
                                    |> typeNotVariableMapVariables
                                        (\variable ->
                                            variableToCondensedLookup
                                                |> FastDict.get variable
                                                |> Maybe.withDefault variable
                                        )
                        in
                        case soFar.variableToType |> FastDict.get condensedVariable of
                            Nothing ->
                                Ok
                                    { equivalentVariables = soFar.equivalentVariables
                                    , variableToType =
                                        soFar.variableToType
                                            |> FastDict.insert condensedVariable
                                                replacementTypeUsingCondensedVariables
                                    }

                            Just existingReplacementTypeForCondensedVariable ->
                                Result.andThen
                                    (\replacementTypeForCondensedVariable ->
                                        variableSubstitutionsMerge3 declarationTypes
                                            soFar
                                            replacementTypeForCondensedVariable.substitutions
                                            (variableSubstitutionsFromVariableToType
                                                condensedVariable
                                                replacementTypeForCondensedVariable.type_
                                            )
                                    )
                                    (typeNotVariableUnify declarationTypes
                                        existingReplacementTypeForCondensedVariable
                                        replacementTypeUsingCondensedVariables
                                    )
            )


usesOfTypeVariablesFromPartiallyInferredDeclarationsCondenseVariables :
    FastDict.Dict TypeVariableFromContext TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext (FastSet.Set TypeVariableFromContext)
    -> FastDict.Dict TypeVariableFromContext (FastSet.Set TypeVariableFromContext)
usesOfTypeVariablesFromPartiallyInferredDeclarationsCondenseVariables variableToCondensedLookup usesOfTypeVariablesFromPartiallyInferredDeclarations =
    usesOfTypeVariablesFromPartiallyInferredDeclarations
        |> FastDict.foldl
            (\partiallyInferredVariableUncondensed usesUncondensed soFar ->
                let
                    usesCondensed : FastSet.Set TypeVariableFromContext
                    usesCondensed =
                        usesUncondensed
                            |> FastSet.foldl
                                (\useUncondensed usesCondensedSoFar ->
                                    case variableToCondensedLookup |> FastDict.get useUncondensed of
                                        Nothing ->
                                            usesCondensedSoFar

                                        Just useCondensed ->
                                            usesCondensedSoFar
                                                |> FastSet.insert useCondensed
                                )
                                FastSet.empty
                in
                soFar
                    |> FastDict.update
                        (case variableToCondensedLookup |> FastDict.get partiallyInferredVariableUncondensed of
                            Nothing ->
                                partiallyInferredVariableUncondensed

                            Just partiallyInferredVariableCondensed ->
                                partiallyInferredVariableCondensed
                        )
                        (\maybeUsesCondensedSoFar ->
                            Just
                                (case maybeUsesCondensedSoFar of
                                    Nothing ->
                                        usesCondensed

                                    Just usesCondensedSoFar ->
                                        FastSet.union
                                            usesCondensed
                                            usesCondensedSoFar
                                )
                        )
            )
            FastDict.empty


declarationValueOrFunctionInfoSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    -> ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
    ->
        Result
            String
            { declaration : ValueOrFunctionDeclarationInfo (Type TypeVariableFromContext)
            , substitutions : VariableSubstitutions
            }
declarationValueOrFunctionInfoSubstituteVariableByNotVariable declarationTypes replacement declarationValueOrFunctionSoFar =
    if replacement.type_ |> typeNotVariableContainedVariables |> FastSet.member replacement.variable then
        if replacement.type_ |> typeNotVariableIsEquivalentToTypeVariable declarationTypes then
            -- is ok when type_ is an identity type alias
            Ok
                { declaration = declarationValueOrFunctionSoFar
                , substitutions = variableSubstitutionsNone
                }

        else
            Err
                ("cannot unify the variable "
                    ++ (replacement.variable |> typeVariableFromContextToName)
                    ++ " with the type "
                    ++ (replacement.type_ |> typeNotVariablePrintRoughly)
                    ++ " because that type contains the type variable itself."
                )

    else
        resultAndThen3
            (\argumentsInferred resultInferred typeInferred ->
                Result.map
                    (\fullSubstitutions ->
                        { declaration =
                            { nameRange = declarationValueOrFunctionSoFar.nameRange
                            , documentation = declarationValueOrFunctionSoFar.documentation
                            , signature = declarationValueOrFunctionSoFar.signature
                            , parameters =
                                argumentsInferred.nodesReverse
                                    |> List.reverse
                            , result = resultInferred.node
                            , type_ =
                                -- reconstructing the function at the end is faster
                                typeInferred.type_
                            }
                        , substitutions = fullSubstitutions
                        }
                    )
                    (variableSubstitutionsMerge3 declarationTypes
                        argumentsInferred.substitutions
                        resultInferred.substitutions
                        typeInferred.substitutions
                    )
            )
            (declarationValueOrFunctionSoFar.parameters
                |> listFoldlWhileOkFrom
                    { substitutions = variableSubstitutionsNone
                    , nodesReverse = []
                    }
                    (\patternTypedNode soFar ->
                        Result.andThen
                            (\patternSubstituted ->
                                Result.map
                                    (\fullSubstitutions ->
                                        { substitutions = fullSubstitutions
                                        , nodesReverse =
                                            patternSubstituted.node
                                                :: soFar.nodesReverse
                                        }
                                    )
                                    (variableSubstitutionsMerge declarationTypes
                                        patternSubstituted.substitutions
                                        soFar.substitutions
                                    )
                            )
                            (patternTypedNode
                                |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                    replacement
                            )
                    )
            )
            (declarationValueOrFunctionSoFar.result
                |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )
            (declarationValueOrFunctionSoFar.type_
                |> typeSubstituteVariableByNotVariable declarationTypes
                    replacement
            )


typeNotVariableIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> TypeNotVariable variable_
    -> Bool
typeNotVariableIsEquivalentToTypeVariable declarationTypes typeNotVariable =
    case typeNotVariable of
        TypeConstruct typeConstruct ->
            case declarationTypes |> FastDict.get typeConstruct.moduleOrigin of
                Nothing ->
                    False

                Just originModule ->
                    case originModule.typeAliases |> FastDict.get typeConstruct.name of
                        Nothing ->
                            False

                        Just typeAlias ->
                            typeAlias.type_ |> typeIsEquivalentToTypeVariable declarationTypes

        TypeUnit ->
            False

        TypeTuple _ ->
            False

        TypeTriple _ ->
            False

        TypeRecord _ ->
            False

        TypeRecordExtension _ ->
            False

        TypeFunction _ ->
            False


typeIsEquivalentToTypeVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    -> Type variable_
    -> Bool
typeIsEquivalentToTypeVariable declarationTypes type_ =
    case type_ of
        TypeVariable _ ->
            True

        TypeNotVariable typeNotVariable ->
            typeNotVariable
                |> typeNotVariableIsEquivalentToTypeVariable declarationTypes


typePrintRoughly : Type TypeVariableFromContext -> String
typePrintRoughly type_ =
    case type_ of
        TypeVariable variable ->
            variable |> typeVariableFromContextToName

        TypeNotVariable typeNotVariable ->
            typeNotVariablePrintRoughly typeNotVariable


typeNotVariablePrintRoughly : TypeNotVariable TypeVariableFromContext -> String
typeNotVariablePrintRoughly typeNotVariable =
    case typeNotVariable of
        TypeUnit ->
            "()"

        TypeFunction typeFunction ->
            "("
                ++ (typeFunction.input |> typePrintRoughly)
                ++ ") -> ("
                ++ (typeFunction.output |> typePrintRoughly)
                ++ ")"

        TypeTuple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ " )"

        TypeTriple parts ->
            "( "
                ++ (parts.part0 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part1 |> typePrintRoughly)
                ++ ", "
                ++ (parts.part2 |> typePrintRoughly)
                ++ " )"

        TypeConstruct typeConstruct ->
            (typeConstruct.moduleOrigin
                |> String.join "."
            )
                ++ "."
                ++ typeConstruct.name
                ++ " "
                ++ (typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                "(" ++ (argument |> typePrintRoughly) ++ ")"
                            )
                        |> String.join ", "
                   )

        TypeRecord fields ->
            "{ "
                ++ (fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"

        TypeRecordExtension typeRecordExtension ->
            "{ "
                ++ (typeRecordExtension.recordVariable
                        |> typeVariableFromContextToName
                   )
                ++ " | "
                ++ (typeRecordExtension.fields
                        |> FastDict.toList
                        |> List.map
                            (\( fieldName, fieldValue ) ->
                                fieldName
                                    ++ " : "
                                    ++ (fieldValue |> typePrintRoughly)
                            )
                        |> String.join ", "
                   )
                ++ " }"


declarationValueOrFunctionInfoMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> ValueOrFunctionDeclarationInfo (Type typeVariable)
    -> ValueOrFunctionDeclarationInfo (Type changedTypeVariable)
declarationValueOrFunctionInfoMapTypeVariables variableChange declarationValueOrFunctionSoFar =
    { nameRange = declarationValueOrFunctionSoFar.nameRange
    , documentation = declarationValueOrFunctionSoFar.documentation
    , signature =
        declarationValueOrFunctionSoFar.signature
            |> Maybe.map
                (\signature ->
                    { range = signature.range
                    , annotationType = signature.annotationType
                    , annotationTypeRange = signature.annotationTypeRange
                    , nameRange = signature.nameRange
                    }
                )
    , parameters =
        declarationValueOrFunctionSoFar.parameters
            |> List.map
                (\argument ->
                    argument |> patternTypedNodeMapTypeVariables variableChange
                )
    , result =
        declarationValueOrFunctionSoFar.result
            |> expressionTypedNodeMapTypeVariables variableChange
    , type_ =
        -- reconstructing the function is probably faster
        declarationValueOrFunctionSoFar.type_
            |> typeMapVariables variableChange
    }


expressionTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
expressionTypedNodeSubstituteVariableByNotVariable declarationTypes replacement expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ExpressionUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionFloat _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = expressionTypedNode
                }

        ExpressionInteger integer ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionInteger integer
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionReference reference ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionReference reference
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionOperatorFunction symbol ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionOperatorFunction symbol
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionNegation negated ->
            Result.map
                (\negatedSubstituted ->
                    { substitutions = negatedSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionNegation negatedSubstituted.node
                        , type_ = negatedSubstituted.node.type_
                        }
                    }
                )
                (negated
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionParenthesized inParensSubstituted.node
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (inParens
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccess recordAccess ->
            resultAndThen2
                (\typeSubstituted recordSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionRecordAccess
                                        { fieldName = recordAccess.fieldName
                                        , fieldNameRange = recordAccess.fieldNameRange
                                        , record = recordSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            recordSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (recordAccess.record
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionRecordAccessFunction field ->
            Result.map
                (\typeSubstituted ->
                    { substitutions = typeSubstituted.substitutions
                    , node =
                        { range = expressionTypedNode.range
                        , value = ExpressionRecordAccessFunction field
                        , type_ = typeSubstituted.type_
                        }
                    }
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionInfixOperation expressionInfixOperation ->
            resultAndThen3
                (\typeSubstituted leftSubstituted rightSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionInfixOperation
                                        { symbol = expressionInfixOperation.symbol
                                        , left = leftSubstituted.node
                                        , right = rightSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            leftSubstituted.substitutions
                            rightSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.left
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionInfixOperation.right
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTuple expressionTuple ->
            resultAndThen3
                (\typeSubstituted part0Substituted part1Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTuple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTuple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionTriple expressionTriple ->
            resultAndThen4
                (\typeSubstituted part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part1
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionTriple.part2
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionIfThenElse expressionIfThenElse ->
            resultAndThen4
                (\typeSubstituted conditionSubstituted onTrueSubstituted onFalseSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionTuple
                                        { part0 = conditionSubstituted.node
                                        , part1 = onTrueSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            conditionSubstituted.substitutions
                            onTrueSubstituted.substitutions
                            onFalseSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.condition
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onTrue
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionIfThenElse.onFalse
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionList expressionListElements ->
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionList
                                        (elementsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionListElements
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\elementNode soFar ->
                            Result.andThen
                                (\elementSubstituted ->
                                    Result.map
                                        (\substitutionsSoFarWithElement ->
                                            { substitutions = substitutionsSoFarWithElement
                                            , nodesReverse =
                                                elementSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            elementSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionCall expressionCall ->
            resultAndThen4
                (\typeSubstituted calledSubstituted argument0Substituted argument1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionCall
                                        { called = calledSubstituted.node
                                        , argument0 = argument0Substituted.node
                                        , argument1Up =
                                            argument1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            calledSubstituted.substitutions
                            argument0Substituted.substitutions
                            argument1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.called
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument0
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCall.argument1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecord expressionRecordFields ->
            resultAndThen2
                (\typeSubstituted fieldsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionRecord
                                        (fieldsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            fieldsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionRecordFields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            resultAndThen3
                (\typeSubstituted field0Substituted field1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionRecordUpdate
                                        { recordVariable =
                                            { value = expressionRecordUpdate.recordVariable.value
                                            , range = expressionRecordUpdate.recordVariable.range
                                            , type_ = typeSubstituted.type_
                                            }
                                        , field0 = field0Substituted.node
                                        , field1Up =
                                            field1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            field0Substituted.substitutions
                            field1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (Result.map
                    (\fieldValueSubstituted ->
                        { substitutions = fieldValueSubstituted.substitutions
                        , node =
                            { range = expressionRecordUpdate.field0.range
                            , name = expressionRecordUpdate.field0.name
                            , nameRange = expressionRecordUpdate.field0.nameRange
                            , value = fieldValueSubstituted.node
                            }
                        }
                    )
                    (expressionRecordUpdate.field0.value
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionRecordUpdate.field1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldValueSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { range = fieldNode.range
                                                , name = fieldNode.name
                                                , nameRange = fieldNode.nameRange
                                                , value = fieldValueSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            fieldValueSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.value
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLambda expressionLambda ->
            resultAndThen4
                (\typeSubstituted parameter0Substituted parameter1UpSubstituted resultSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLambda
                                        { parameter0 = parameter0Substituted.node
                                        , parameter1Up =
                                            parameter1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            parameter0Substituted.substitutions
                            parameter1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLambda.parameter0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLambda.parameter1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\parameterNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsSoFarWithParameter ->
                                            { substitutions = substitutionsSoFarWithParameter
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (parameterNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLambda.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        ExpressionCaseOf expressionCaseOf ->
            resultAndThen4
                (\typeSubstituted matchedSubstituted case0Substituted case1UpSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionCaseOf
                                        { case0 = case0Substituted.node
                                        , case1Up =
                                            case1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , matchedExpression = matchedSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            matchedSubstituted.substitutions
                            case0Substituted.substitutions
                            case1UpSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (expressionTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionCaseOf.matchedExpression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (resultAndThen2
                    (\patternSubstituted resultSubstituted ->
                        Result.map
                            (\fullSubstitutions ->
                                { substitutions = fullSubstitutions
                                , node =
                                    { pattern = patternSubstituted.node
                                    , result = resultSubstituted.node
                                    }
                                }
                            )
                            (variableSubstitutionsMerge declarationTypes
                                patternSubstituted.substitutions
                                resultSubstituted.substitutions
                            )
                    )
                    (expressionCaseOf.case0.pattern
                        |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                    (expressionCaseOf.case0.result
                        |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                            replacement
                    )
                )
                (expressionCaseOf.case1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\case_ soFar ->
                            resultAndThen2
                                (\patternSubstituted resultSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                { pattern = patternSubstituted.node
                                                , result = resultSubstituted.node
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge3 declarationTypes
                                            patternSubstituted.substitutions
                                            resultSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (case_.pattern
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                                (case_.result
                                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        ExpressionLetIn expressionLetIn ->
            resultAndThen3
                (\declaration0Substituted declaration1UpSubstituted resultSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = expressionTypedNode.range
                                , value =
                                    ExpressionLetIn
                                        { declaration0 =
                                            declaration0Substituted.node
                                        , declaration1Up =
                                            declaration1UpSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        }
                                , type_ = resultSubstituted.node.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            declaration0Substituted.substitutions
                            declaration1UpSubstituted.substitutions
                            resultSubstituted.substitutions
                        )
                )
                (expressionLetIn.declaration0
                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (expressionLetIn.declaration1Up
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\letDeclarationNode soFar ->
                            Result.andThen
                                (\declarationSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                declarationSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            declarationSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (letDeclarationNode
                                    |> letDeclarationSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (expressionLetIn.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


letDeclarationSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : LetDeclaration (Type TypeVariableFromContext)
        }
    ->
        Result
            String
            { node :
                { range : Elm.Syntax.Range.Range
                , declaration : LetDeclaration (Type TypeVariableFromContext)
                }
            , substitutions : VariableSubstitutions
            }
letDeclarationSubstituteVariableByNotVariable declarationTypes replacement letDeclarationAndRange =
    case letDeclarationAndRange.declaration of
        LetDestructuring letDestructuring ->
            resultAndThen2
                (\patternSubstituted expressionSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetDestructuring
                                        { pattern = patternSubstituted.node
                                        , expression = expressionSubstituted.node
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            patternSubstituted.substitutions
                            expressionSubstituted.substitutions
                        )
                )
                (letDestructuring.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letDestructuring.expression
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        LetValueOrFunctionDeclaration letValueOrFunction ->
            resultAndThen3
                (\argumentsSubstituted resultSubstituted typeSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    LetValueOrFunctionDeclaration
                                        { parameters =
                                            argumentsSubstituted.nodesReverse
                                                |> List.reverse
                                        , result = resultSubstituted.node
                                        , type_ = typeSubstituted.type_
                                        , signature = letValueOrFunction.signature
                                        , nameRange = letValueOrFunction.nameRange
                                        , name = letValueOrFunction.name
                                        }
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            argumentsSubstituted.substitutions
                            resultSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (letValueOrFunction.parameters
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\fullSubstitutions ->
                                            { substitutions = fullSubstitutions
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge
                                            declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )
                (letValueOrFunction.result
                    |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (letValueOrFunction.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )


expressionTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Expression (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Expression (Type changedTypeVariable)) (Type changedTypeVariable)
expressionTypedNodeMapTypeVariables typeVariableChange expressionTypedNode =
    expressionTypedNode
        |> expressionTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


expressionTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Expression type_) type_
    -> TypedNode (Expression changedType) changedType
expressionTypedNodeMapTypes typeVariableChange expressionTypedNode =
    { range = expressionTypedNode.range
    , value =
        expressionTypedNode.value
            |> expressionMapTypes typeVariableChange
    , type_ =
        expressionTypedNode.type_
            |> typeVariableChange
    }


expressionMapTypes :
    (type_ -> changedType)
    -> Expression type_
    -> Expression changedType
expressionMapTypes typeChange expression =
    -- IGNORE TCO
    case expression of
        ExpressionUnit ->
            ExpressionUnit

        ExpressionFloat floatValue ->
            ExpressionFloat floatValue

        ExpressionChar charValue ->
            ExpressionChar charValue

        ExpressionString stringValue ->
            ExpressionString stringValue

        ExpressionInteger expressionNumber ->
            ExpressionInteger expressionNumber

        ExpressionReference reference ->
            ExpressionReference reference

        ExpressionOperatorFunction expressionOperatorFunction ->
            ExpressionOperatorFunction expressionOperatorFunction

        ExpressionRecordAccessFunction fieldName ->
            ExpressionRecordAccessFunction fieldName

        ExpressionNegation inNegation ->
            ExpressionNegation
                (inNegation
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionParenthesized inParens ->
            ExpressionParenthesized
                (inParens
                    |> expressionTypedNodeMapTypes typeChange
                )

        ExpressionRecordAccess expressionRecordAccess ->
            ExpressionRecordAccess
                { record =
                    expressionRecordAccess.record
                        |> expressionTypedNodeMapTypes typeChange
                , fieldName = expressionRecordAccess.fieldName
                , fieldNameRange = expressionRecordAccess.fieldNameRange
                }

        ExpressionInfixOperation expressionInfixOperation ->
            ExpressionInfixOperation
                { symbol = expressionInfixOperation.symbol
                , left =
                    expressionInfixOperation.left
                        |> expressionTypedNodeMapTypes typeChange
                , right =
                    expressionInfixOperation.right
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTuple expressionTuple ->
            ExpressionTuple
                { part0 =
                    expressionTuple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTuple.part1
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionTriple expressionTriple ->
            ExpressionTriple
                { part0 =
                    expressionTriple.part0
                        |> expressionTypedNodeMapTypes typeChange
                , part1 =
                    expressionTriple.part1
                        |> expressionTypedNodeMapTypes typeChange
                , part2 =
                    expressionTriple.part2
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionIfThenElse expressionIfThenElse ->
            ExpressionIfThenElse
                { condition =
                    expressionIfThenElse.condition
                        |> expressionTypedNodeMapTypes typeChange
                , onTrue =
                    expressionIfThenElse.onTrue
                        |> expressionTypedNodeMapTypes typeChange
                , onFalse =
                    expressionIfThenElse.onFalse
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionList expressionListElements ->
            ExpressionList
                (expressionListElements
                    |> List.map
                        (\element ->
                            element
                                |> expressionTypedNodeMapTypes
                                    typeChange
                        )
                )

        ExpressionCall expressionCall ->
            ExpressionCall
                { called =
                    expressionCall.called
                        |> expressionTypedNodeMapTypes typeChange
                , argument0 =
                    expressionCall.argument0
                        |> expressionTypedNodeMapTypes typeChange
                , argument1Up =
                    expressionCall.argument1Up
                        |> List.map
                            (\argument ->
                                argument
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            )
                }

        ExpressionRecord expressionRecordFields ->
            ExpressionRecord
                (expressionRecordFields
                    |> List.map
                        (\field ->
                            { range = field.range
                            , name = field.name
                            , nameRange = field.nameRange
                            , value =
                                field.value
                                    |> expressionTypedNodeMapTypes
                                        typeChange
                            }
                        )
                )

        ExpressionRecordUpdate expressionRecordUpdate ->
            ExpressionRecordUpdate
                { recordVariable =
                    { range = expressionRecordUpdate.recordVariable.range
                    , value = expressionRecordUpdate.recordVariable.value
                    , type_ =
                        expressionRecordUpdate.recordVariable.type_
                            |> typeChange
                    }
                , field0 =
                    { range = expressionRecordUpdate.field0.range
                    , name = expressionRecordUpdate.field0.name
                    , nameRange = expressionRecordUpdate.field0.nameRange
                    , value =
                        expressionRecordUpdate.field0.value
                            |> expressionTypedNodeMapTypes
                                typeChange
                    }
                , field1Up =
                    expressionRecordUpdate.field1Up
                        |> List.map
                            (\field ->
                                { range = field.range
                                , name = field.name
                                , nameRange = field.nameRange
                                , value =
                                    field.value
                                        |> expressionTypedNodeMapTypes
                                            typeChange
                                }
                            )
                }

        ExpressionLambda expressionLambda ->
            ExpressionLambda
                { parameter0 =
                    expressionLambda.parameter0
                        |> patternTypedNodeMapTypes typeChange
                , parameter1Up =
                    expressionLambda.parameter1Up
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    expressionLambda.result
                        |> expressionTypedNodeMapTypes typeChange
                }

        ExpressionCaseOf expressionCaseOf ->
            ExpressionCaseOf
                { matchedExpression =
                    expressionCaseOf.matchedExpression
                        |> expressionTypedNodeMapTypes typeChange
                , case0 =
                    { pattern =
                        expressionCaseOf.case0.pattern
                            |> patternTypedNodeMapTypes typeChange
                    , result =
                        expressionCaseOf.case0.result
                            |> expressionTypedNodeMapTypes typeChange
                    }
                , case1Up =
                    expressionCaseOf.case1Up
                        |> List.map
                            (\case_ ->
                                { pattern =
                                    case_.pattern
                                        |> patternTypedNodeMapTypes typeChange
                                , result =
                                    case_.result
                                        |> expressionTypedNodeMapTypes typeChange
                                }
                            )
                }

        ExpressionLetIn expressionLetIn ->
            ExpressionLetIn
                { declaration0 =
                    { range = expressionLetIn.declaration0.range
                    , declaration =
                        expressionLetIn.declaration0.declaration
                            |> letDeclarationMapTypes typeChange
                    }
                , declaration1Up =
                    expressionLetIn.declaration1Up
                        |> List.map
                            (\letDeclarationAndRange ->
                                { range = letDeclarationAndRange.range
                                , declaration =
                                    letDeclarationAndRange.declaration
                                        |> letDeclarationMapTypes typeChange
                                }
                            )
                , result =
                    expressionLetIn.result
                        |> expressionTypedNodeMapTypes typeChange
                }


letDeclarationMapTypes :
    (type_ -> changedType)
    -> LetDeclaration type_
    -> LetDeclaration changedType
letDeclarationMapTypes typeChange expressionLetDeclaration =
    case expressionLetDeclaration of
        LetDestructuring letDestructuring ->
            LetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> patternTypedNodeMapTypes typeChange
                , expression =
                    letDestructuring.expression
                        |> expressionTypedNodeMapTypes typeChange
                }

        LetValueOrFunctionDeclaration letValueOrFunction ->
            LetValueOrFunctionDeclaration
                { signature =
                    letValueOrFunction.signature
                        |> Maybe.map
                            (\signature ->
                                { nameRange = signature.nameRange
                                , range = signature.range
                                , annotationType = signature.annotationType
                                , annotationTypeRange = signature.annotationTypeRange
                                }
                            )
                , nameRange = letValueOrFunction.nameRange
                , name = letValueOrFunction.name
                , parameters =
                    letValueOrFunction.parameters
                        |> List.map
                            (\argument ->
                                argument |> patternTypedNodeMapTypes typeChange
                            )
                , result =
                    letValueOrFunction.result
                        |> expressionTypedNodeMapTypes typeChange
                , type_ =
                    letValueOrFunction.type_
                        |> typeChange
                }


expressionTypeInferResultAddOrApplySubstitutions :
    { declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , locallyIntroducedExpressionVariables :
        FastDict.Dict String (Type TypeVariableFromContext)
    }
    -> VariableSubstitutions
    ->
        { substitutions : VariableSubstitutions
        , node :
            TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
        , usesOfTypeVariablesFromPartiallyInferredDeclarations :
            FastDict.Dict
                TypeVariableFromContext
                (FastSet.Set TypeVariableFromContext)
        }
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Expression (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            , usesOfTypeVariablesFromPartiallyInferredDeclarations :
                FastDict.Dict
                    TypeVariableFromContext
                    (FastSet.Set TypeVariableFromContext)
            }
expressionTypeInferResultAddOrApplySubstitutions context substitutionsToAddOrApply expressionTypeInferResult =
    let
        -- we don't want to apply a substitution locally if a non-local substitution could be substituted
        -- into such a variable
        nonLocalSubstitutionResultTypeVariables : FastSet.Set TypeVariableFromContext
        nonLocalSubstitutionResultTypeVariables =
            FastSet.union
                (expressionTypeInferResult.substitutions.equivalentVariables
                    |> listMapAndFastSetsUnify identity
                )
                (expressionTypeInferResult.substitutions.variableToType
                    |> FastDict.foldl
                        (\_ replacementType soFar ->
                            FastSet.union soFar
                                (replacementType |> typeNotVariableContainedVariables)
                        )
                        FastSet.empty
                )

        ( substitutionsVariableToTypeToAdd, substitutionsVariableToTypeToApply ) =
            substitutionsToAddOrApply.variableToType
                |> FastDict.partition
                    (\variable _ ->
                        (context.locallyIntroducedExpressionVariables
                            |> fastDictAny
                                (\expressionVariableType ->
                                    expressionVariableType
                                        |> typeContainedVariables
                                        |> FastSet.member variable
                                )
                        )
                            || (nonLocalSubstitutionResultTypeVariables
                                    |> FastSet.member variable
                               )
                    )

        ( substitutionsOfEquivalentVariablesToAdd, substitutionsOfEquivalentVariablesToApply ) =
            substitutionsToAddOrApply.equivalentVariables
                |> List.partition
                    (\equivalentVariablesSet ->
                        (context.locallyIntroducedExpressionVariables
                            |> fastDictAny
                                (\expressionVariableType ->
                                    fastSetAreIntersecting
                                        equivalentVariablesSet
                                        (expressionVariableType
                                            |> typeContainedVariables
                                        )
                                )
                        )
                            || (nonLocalSubstitutionResultTypeVariables
                                    |> fastSetAreIntersecting equivalentVariablesSet
                               )
                    )

        substitutionsToApply : VariableSubstitutions
        substitutionsToApply =
            { equivalentVariables = substitutionsOfEquivalentVariablesToApply
            , variableToType = substitutionsVariableToTypeToApply
            }
    in
    Result.map3
        (\nodeSubstituted variableToCondensedLookup substitutionsWithAdded ->
            { substitutions = substitutionsWithAdded
            , node = nodeSubstituted
            , usesOfTypeVariablesFromPartiallyInferredDeclarations =
                expressionTypeInferResult.usesOfTypeVariablesFromPartiallyInferredDeclarations
                    |> usesOfTypeVariablesFromPartiallyInferredDeclarationsCondenseVariables
                        variableToCondensedLookup
            }
        )
        (expressionTypeInferResult.node
            |> expressionTypedNodeApplyVariableSubstitutions context.declarationTypes
                substitutionsToApply
        )
        (createEquivalentVariablesToCondensedVariableLookup
            substitutionsOfEquivalentVariablesToApply
        )
        (variableSubstitutionsMerge context.declarationTypes
            expressionTypeInferResult.substitutions
            { equivalentVariables = substitutionsOfEquivalentVariablesToAdd
            , variableToType = substitutionsVariableToTypeToAdd
            }
        )


fastSetAreIntersecting : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetAreIntersecting a b =
    -- not sure there's a faster alternative since FastSet does not offer restructure
    Basics.not (FastSet.isEmpty (a |> FastSet.intersect b))


expressionTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Expression (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Expression (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
expressionTypedNodeApplyVariableSubstitutions declarationTypes substitutions expressionTypedNode =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (expressionTypedNode
                                    |> expressionTypedNodeMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok expressionTypedNode

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        expressionTypedNode
                            |> expressionTypedNodeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok expressionTypedNodeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            expressionTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            expressionTypedNodeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                expressionTypedNodeWithVariableToTypeSubstitutionApplied.node


patternTypedNodeApplyVariableSubstitutions :
    ModuleLevelDeclarationTypesAvailableInModule
    -> VariableSubstitutions
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            (TypedNode
                (Pattern (Type TypeVariableFromContext))
                (Type TypeVariableFromContext)
            )
patternTypedNodeApplyVariableSubstitutions declarationTypes substitutions patternTypedNode =
    case substitutions.equivalentVariables of
        equivalentVariableSet0 :: equivalentVariableSet1Up ->
            case
                (equivalentVariableSet0 :: equivalentVariableSet1Up)
                    |> createEquivalentVariablesToCondensedVariableLookup
            of
                Err error ->
                    Err error

                Ok variableToCondensedLookup ->
                    case
                        substitutions.variableToType
                            |> variableToTypeSubstitutionsCondenseVariables declarationTypes
                                variableToCondensedLookup
                    of
                        Err error ->
                            Err error

                        Ok variableToTypeWithCondensedVariables ->
                            patternTypedNodeApplyVariableSubstitutions declarationTypes
                                variableToTypeWithCondensedVariables
                                (patternTypedNode
                                    |> patternTypedNodeMapTypeVariables
                                        (\originalTypeVariable ->
                                            variableToCondensedLookup
                                                |> FastDict.get originalTypeVariable
                                                |> Maybe.withDefault originalTypeVariable
                                        )
                                )

        [] ->
            case substitutions.variableToType |> FastDict.popMin of
                Nothing ->
                    Ok patternTypedNode

                Just ( ( variableToSubstituteNext, typeToSubstituteByNext ), remainingVariableToTypeSubstitutions ) ->
                    let
                        variableToTypeSubstitutionToApplyNext :
                            { variable : TypeVariableFromContext
                            , type_ : TypeNotVariable TypeVariableFromContext
                            }
                        variableToTypeSubstitutionToApplyNext =
                            { variable = variableToSubstituteNext, type_ = typeToSubstituteByNext }
                    in
                    case
                        patternTypedNode
                            |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                variableToTypeSubstitutionToApplyNext
                    of
                        Err error ->
                            Err error

                        Ok patternTypedNodeWithVariableToTypeSubstitutionApplied ->
                            case
                                remainingVariableToTypeSubstitutions
                                    |> variableToTypeSubstitutionsSubstituteVariableByNotVariable declarationTypes
                                        variableToTypeSubstitutionToApplyNext
                            of
                                Err error ->
                                    Err error

                                Ok remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied ->
                                    case
                                        variableSubstitutionsMerge declarationTypes
                                            patternTypedNodeWithVariableToTypeSubstitutionApplied.substitutions
                                            remainingVariableToTypeSubstitutionsWithVariableToTypeSubstitutionApplied
                                    of
                                        Err error ->
                                            Err error

                                        Ok fullRemainingSubstitutions ->
                                            patternTypedNodeApplyVariableSubstitutions declarationTypes
                                                fullRemainingSubstitutions
                                                patternTypedNodeWithVariableToTypeSubstitutionApplied.node


patternTypedNodeSubstituteVariableByNotVariable :
    ModuleLevelDeclarationTypesAvailableInModule
    ->
        { variable : TypeVariableFromContext
        , type_ : TypeNotVariable TypeVariableFromContext
        }
    ->
        TypedNode
            (Pattern (Type TypeVariableFromContext))
            (Type TypeVariableFromContext)
    ->
        Result
            String
            { substitutions : VariableSubstitutions
            , node :
                TypedNode
                    (Pattern (Type TypeVariableFromContext))
                    (Type TypeVariableFromContext)
            }
patternTypedNodeSubstituteVariableByNotVariable declarationTypes replacement patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        PatternUnit ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternChar _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternString _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternInt _ ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternIgnored ->
            Ok
                { substitutions = variableSubstitutionsNone
                , node = patternTypedNode
                }

        PatternVariable name ->
            Result.map
                (\substituted ->
                    { substitutions = substituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternVariable name
                        , type_ = substituted.type_
                        }
                    }
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternParenthesized inParens ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value = PatternParenthesized inParensSubstituted.node
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (inParens
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternAs patternAs ->
            Result.map
                (\inParensSubstituted ->
                    { substitutions = inParensSubstituted.substitutions
                    , node =
                        { range = patternTypedNode.range
                        , value =
                            PatternAs
                                { pattern = inParensSubstituted.node
                                , variable =
                                    { range = patternAs.variable.range
                                    , value = patternAs.variable.value
                                    , type_ = inParensSubstituted.node.type_
                                    }
                                }
                        , type_ = inParensSubstituted.node.type_
                        }
                    }
                )
                (patternAs.pattern
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternListCons patternListCons ->
            resultAndThen3
                (\typeSubstituted headSubstituted tailSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListCons
                                        { head = headSubstituted.node
                                        , tail = tailSubstituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            typeSubstituted.substitutions
                            headSubstituted.substitutions
                            tailSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListCons.head
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListCons.tail
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTuple patternTuple ->
            resultAndThen3
                (\typeSubstituted part0Substituted part1Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTuple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge3 declarationTypes
                            typeSubstituted.substitutions
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTuple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTuple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternTriple patternTriple ->
            resultAndThen4
                (\typeSubstituted part0Substituted part1Substituted part2Substituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternTriple
                                        { part0 = part0Substituted.node
                                        , part1 = part1Substituted.node
                                        , part2 = part2Substituted.node
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge4 declarationTypes
                            typeSubstituted.substitutions
                            part0Substituted.substitutions
                            part1Substituted.substitutions
                            part2Substituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part0
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part1
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternTriple.part2
                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )

        PatternRecord patternRecordFields ->
            resultAndThen2
                (\typeSubstituted fieldsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternRecord
                                        (fieldsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            fieldsSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternRecordFields
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\fieldNode soFar ->
                            Result.andThen
                                (\fieldTypeSubstituted ->
                                    Result.map
                                        (\substitutionsWithField ->
                                            { substitutions = substitutionsWithField
                                            , nodesReverse =
                                                { value = fieldNode.value
                                                , range = fieldNode.range
                                                , type_ = fieldTypeSubstituted.type_
                                                }
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldTypeSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (fieldNode.type_
                                    |> typeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        PatternListExact patternListElement ->
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternListExact
                                        (elementsSubstituted.nodesReverse
                                            |> List.reverse
                                        )
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            elementsSubstituted.substitutions
                            typeSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternListElement
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\elementNode soFar ->
                            Result.andThen
                                (\fieldSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodesReverse =
                                                fieldSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            fieldSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (elementNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )

        PatternVariant patternVariant ->
            resultAndThen2
                (\typeSubstituted elementsSubstituted ->
                    Result.map
                        (\fullSubstitutions ->
                            { substitutions = fullSubstitutions
                            , node =
                                { range = patternTypedNode.range
                                , value =
                                    PatternVariant
                                        { qualification = patternVariant.qualification
                                        , name = patternVariant.name
                                        , moduleOrigin = patternVariant.moduleOrigin
                                        , values =
                                            elementsSubstituted.nodesReverse
                                                |> List.reverse
                                        }
                                , type_ = typeSubstituted.type_
                                }
                            }
                        )
                        (variableSubstitutionsMerge declarationTypes
                            typeSubstituted.substitutions
                            elementsSubstituted.substitutions
                        )
                )
                (patternTypedNode.type_
                    |> typeSubstituteVariableByNotVariable declarationTypes
                        replacement
                )
                (patternVariant.values
                    |> listFoldlWhileOkFrom
                        { substitutions = variableSubstitutionsNone
                        , nodesReverse = []
                        }
                        (\argumentNode soFar ->
                            Result.andThen
                                (\argumentSubstituted ->
                                    Result.map
                                        (\substitutionsWithElement ->
                                            { substitutions = substitutionsWithElement
                                            , nodesReverse =
                                                argumentSubstituted.node
                                                    :: soFar.nodesReverse
                                            }
                                        )
                                        (variableSubstitutionsMerge declarationTypes
                                            argumentSubstituted.substitutions
                                            soFar.substitutions
                                        )
                                )
                                (argumentNode
                                    |> patternTypedNodeSubstituteVariableByNotVariable declarationTypes
                                        replacement
                                )
                        )
                )


patternTypedNodeMapTypeVariables :
    (typeVariable -> changedTypeVariable)
    -> TypedNode (Pattern (Type typeVariable)) (Type typeVariable)
    -> TypedNode (Pattern (Type changedTypeVariable)) (Type changedTypeVariable)
patternTypedNodeMapTypeVariables typeVariableChange patternTypedNode =
    patternTypedNode
        |> patternTypedNodeMapTypes
            (\type_ -> type_ |> typeMapVariables typeVariableChange)


patternTypedNodeMapTypes :
    (type_ -> changedType)
    -> TypedNode (Pattern type_) type_
    -> TypedNode (Pattern changedType) changedType
patternTypedNodeMapTypes typeVariableChange patternTypedNode =
    { range = patternTypedNode.range
    , value =
        patternTypedNode.value
            |> patternMapTypes typeVariableChange
    , type_ =
        patternTypedNode.type_
            |> typeVariableChange
    }


patternMapTypes :
    (type_ -> changedType)
    -> Pattern type_
    -> Pattern changedType
patternMapTypes typeChange pattern =
    -- IGNORE TCO
    case pattern of
        PatternUnit ->
            PatternUnit

        PatternChar charValue ->
            PatternChar charValue

        PatternString stringValue ->
            PatternString stringValue

        PatternInt patternInt ->
            PatternInt patternInt

        PatternIgnored ->
            PatternIgnored

        PatternVariable variable ->
            PatternVariable variable

        PatternParenthesized inParens ->
            PatternParenthesized
                (inParens
                    |> patternTypedNodeMapTypes typeChange
                )

        PatternAs patternAs ->
            let
                patternWithTypeWithVariablesChanged : TypedNode (Pattern changedType) changedType
                patternWithTypeWithVariablesChanged =
                    patternAs.pattern
                        |> patternTypedNodeMapTypes typeChange
            in
            PatternAs
                { pattern = patternWithTypeWithVariablesChanged
                , variable =
                    { range = patternAs.variable.range
                    , value = patternAs.variable.value
                    , type_ = patternWithTypeWithVariablesChanged.type_
                    }
                }

        PatternListCons patternListCons ->
            PatternListCons
                { head =
                    patternListCons.head
                        |> patternTypedNodeMapTypes typeChange
                , tail =
                    patternListCons.tail
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTuple patternTuple ->
            PatternTuple
                { part0 =
                    patternTuple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTuple.part1
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternTriple patternTriple ->
            PatternTriple
                { part0 =
                    patternTriple.part0
                        |> patternTypedNodeMapTypes typeChange
                , part1 =
                    patternTriple.part1
                        |> patternTypedNodeMapTypes typeChange
                , part2 =
                    patternTriple.part2
                        |> patternTypedNodeMapTypes typeChange
                }

        PatternRecord patternRecordFields ->
            PatternRecord
                (patternRecordFields
                    |> List.map
                        (\field ->
                            { value = field.value
                            , range = field.range
                            , type_ =
                                field.type_ |> typeChange
                            }
                        )
                )

        PatternListExact patternListElement ->
            PatternListExact
                (patternListElement
                    |> List.map
                        (\element ->
                            element
                                |> patternTypedNodeMapTypes
                                    typeChange
                        )
                )

        PatternVariant patternVariant ->
            PatternVariant
                { qualification = patternVariant.qualification
                , name = patternVariant.name
                , moduleOrigin = patternVariant.moduleOrigin
                , values =
                    patternVariant.values
                        |> List.map
                            (\argument ->
                                argument
                                    |> patternTypedNodeMapTypes
                                        typeChange
                            )
                }


equivalentVariablesCreateCondensedVariable : FastSet.Set TypeVariableFromContext -> Result String TypeVariableFromContext
equivalentVariablesCreateCondensedVariable set =
    case set |> FastSet.toList of
        [] ->
            Err "implementation bug: equivalent variables set is empty"

        [ onlyVariable ] ->
            Ok onlyVariable

        variable0 :: variable1 :: variable2Up ->
            Result.map
                (\unifiedMaybeConstraint ->
                    case unifiedMaybeConstraint of
                        Nothing ->
                            variable0

                        Just unifiedConstraint ->
                            let
                                ( variable0Context, variable0IgnoringContext ) =
                                    variable0
                            in
                            ( variable0Context
                            , variable0IgnoringContext
                                |> typeVariableNameReplaceConstraint unifiedConstraint
                            )
                )
                ((variable0 :: variable1 :: variable2Up)
                    |> listFoldlWhileOkFrom Nothing
                        (\variable soFar ->
                            maybeTypeVariableConstraintMerge
                                (variable
                                    |> typeVariableIgnoringContext
                                    |> typeVariableConstraint
                                )
                                soFar
                        )
                )


typeVariableConstraintToString : TypeVariableConstraint -> String
typeVariableConstraintToString constraint =
    case constraint of
        TypeVariableConstraintNumber ->
            "number"

        TypeVariableConstraintAppendable ->
            "appendable"

        TypeVariableConstraintComparable ->
            "comparable"

        TypeVariableConstraintCompappend ->
            "compappend"


typeVariableNameReplaceConstraint : TypeVariableConstraint -> String -> String
typeVariableNameReplaceConstraint replacementConstraint typeVariableNameWithPotentialConstraint =
    let
        typeVariableNameWithoutConstraint : String
        typeVariableNameWithoutConstraint =
            case typeVariableNameWithPotentialConstraint |> typeVariableConstraint of
                Nothing ->
                    typeVariableNameWithPotentialConstraint

                Just constraint ->
                    String.dropLeft
                        (constraint |> typeVariableConstraintToString |> String.length)
                        typeVariableNameWithPotentialConstraint
                        |> stringFirstCharToLower
    in
    (replacementConstraint |> typeVariableConstraintToString)
        ++ (typeVariableNameWithoutConstraint |> stringFirstCharToUpper)


fastDictFoldlWhileOkFrom : ok -> (key -> value -> ok -> Result err ok) -> FastDict.Dict key value -> Result err ok
fastDictFoldlWhileOkFrom initialFolded reduceToResult fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value soFarOrError ->
                case soFarOrError of
                    Err error ->
                        Err error |> FastDict.Stop

                    Ok soFar ->
                        case reduceToResult key value soFar of
                            Err error ->
                                Err error |> FastDict.Stop

                            Ok foldedWithEntry ->
                                Ok foldedWithEntry |> FastDict.Continue
            )
            (Ok initialFolded)


fastDictMapAndSmallestJust : (key -> value -> Maybe ok) -> FastDict.Dict key value -> Maybe ok
fastDictMapAndSmallestJust keyValueToMaybe fastDict =
    fastDict
        |> FastDict.stoppableFoldl
            (\key value _ ->
                case keyValueToMaybe key value of
                    Just foldedWithEntry ->
                        Just foldedWithEntry |> FastDict.Stop

                    Nothing ->
                        Nothing |> FastDict.Continue
            )
            Nothing


parameterPatternsTypeInfer :
    { path : List String
    , declarationTypes : ModuleLevelDeclarationTypesAvailableInModule
    , moduleOriginLookup : ModuleOriginLookup
    }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Pattern.Pattern)
    ->
        Result
            String
            { introducedExpressionVariables :
                FastDict.Dict String (Type TypeVariableFromContext)
            , nodesReverse :
                List
                    (TypedNode
                        (Pattern (Type TypeVariableFromContext))
                        (Type TypeVariableFromContext)
                    )
            }
parameterPatternsTypeInfer context parameterPatterns =
    parameterPatterns
        |> listFoldlWhileOkFrom
            { introducedExpressionVariables = FastDict.empty
            , nodesReverse = []
            , index = 0
            }
            (\pattern soFar ->
                Result.map
                    (\patternInferred ->
                        { index = soFar.index + 1
                        , nodesReverse =
                            patternInferred
                                :: soFar.nodesReverse
                        , introducedExpressionVariables =
                            FastDict.union soFar.introducedExpressionVariables
                                (patternInferred |> patternTypedNodeIntroducedVariables)
                        }
                    )
                    (pattern
                        |> patternTypeInfer
                            (context
                                |> patternContextToInPath
                                    ("parameter" ++ (soFar.index |> String.fromInt))
                            )
                    )
            )
        |> Result.map
            (\folded ->
                { introducedExpressionVariables =
                    folded.introducedExpressionVariables
                , nodesReverse = folded.nodesReverse
                }
            )


{-| Extract all known types
from module [metadata](https://dark.elm.dmy.fr/packages/elm/project-metadata-utils/latest/),
usually from parsing the `docs.json` of a dependency.

For elm-syntax modules, use [`moduleDeclarationsToTypes`](#moduleDeclarationsToTypes)

-}
moduleInterfaceToTypes :
    Elm.Docs.Module
    -> { types : ModuleTypes, errors : List String }
moduleInterfaceToTypes moduleInterface =
    let
        typeAliases :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { type_ : Type String
                    , parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    }
            }
        typeAliases =
            moduleInterface.aliases
                |> List.foldl
                    (\typeAliasDeclarationInterface soFar ->
                        case
                            typeAliasDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            typeAliasDeclarationInterface.name
                                            { type_ = type_
                                            , parameters = typeAliasDeclarationInterface.args
                                            , recordFieldOrder =
                                                case typeAliasDeclarationInterface.tipe of
                                                    Elm.Type.Record fields Nothing ->
                                                        Just (fields |> List.map (\( name, _ ) -> name))

                                                    Elm.Type.Record _ (Just _) ->
                                                        Nothing

                                                    Elm.Type.Var _ ->
                                                        Nothing

                                                    Elm.Type.Lambda _ _ ->
                                                        Nothing

                                                    Elm.Type.Tuple _ ->
                                                        Nothing

                                                    Elm.Type.Type _ _ ->
                                                        Nothing
                                            }
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }

        choiceTypes :
            { errors : List String
            , types :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (List (Type String))
                    }
            }
        choiceTypes =
            moduleInterface.unions
                |> List.foldl
                    (\declarationChoiceType soFar ->
                        case
                            declarationChoiceType.tags
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\( variantName, variantValueInterfaces ) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        variantName
                                                        variantValues
                                            )
                                            (variantValueInterfaces
                                                |> listMapAndCombineOk
                                                    (\variantValue ->
                                                        variantValue |> interfaceToType
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            declarationChoiceType.name
                                            { parameters =
                                                declarationChoiceType.args
                                            , variants = variants
                                            }
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }

        signatures : { errors : List String, types : FastDict.Dict String (Type String) }
        signatures =
            moduleInterface.values
                |> List.foldl
                    (\valueOrFunctionDeclarationInterface soFar ->
                        case
                            valueOrFunctionDeclarationInterface.tipe
                                |> interfaceToType
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    soFar.types
                                        |> FastDict.insert
                                            valueOrFunctionDeclarationInterface.name
                                            type_
                                }
                    )
                    { types = FastDict.empty
                    , errors = []
                    }
    in
    { errors =
        typeAliases.errors
            ++ choiceTypes.errors
            ++ signatures.errors
    , types =
        { typeAliases = typeAliases.types
        , choiceTypes = choiceTypes.types
        , signatures = signatures.types
        }
    }


interfaceToType : Elm.Type.Type -> Result String (Type String)
interfaceToType typeInterface =
    -- IGNORE TCO
    case typeInterface of
        Elm.Type.Var name ->
            Ok (TypeVariable name)

        Elm.Type.Lambda functionInput functionOutput ->
            Result.map2
                (\input output ->
                    TypeNotVariable
                        (TypeFunction { input = input, output = output })
                )
                (functionInput |> interfaceToType)
                (functionOutput |> interfaceToType)

        Elm.Type.Tuple parts ->
            case parts of
                [] ->
                    Ok (TypeNotVariable TypeUnit)

                [ inParens ] ->
                    inParens |> interfaceToType

                [ tuplePart0, tuplePart1 ] ->
                    Result.map2
                        (\part0 part1 ->
                            TypeNotVariable
                                (TypeTuple { part0 = part0, part1 = part1 })
                        )
                        (tuplePart1 |> interfaceToType)
                        (tuplePart0 |> interfaceToType)

                [ triplePart0, triplePart1, triplePart2 ] ->
                    Result.map3
                        (\part0 part1 part2 ->
                            TypeNotVariable
                                (TypeTriple { part0 = part0, part1 = part1, part2 = part2 })
                        )
                        (triplePart0 |> interfaceToType)
                        (triplePart1 |> interfaceToType)
                        (triplePart2 |> interfaceToType)

                _ :: _ :: _ :: _ :: _ ->
                    Err "too many tuple parts"

        Elm.Type.Type reference argumentInterfaces ->
            case reference |> String.split "." |> List.reverse of
                referenceName :: referenceModulePartLast :: referenceModulePartBeforeLastDown ->
                    Result.map
                        (\arguments ->
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin =
                                        (referenceModulePartLast :: referenceModulePartBeforeLastDown)
                                            |> List.reverse
                                    , name = referenceName
                                    , arguments = arguments
                                    }
                                )
                        )
                        (argumentInterfaces |> listMapAndCombineOk interfaceToType)

                [ _ ] ->
                    Err "invalid reference"

                [] ->
                    Err "invalid reference"

        Elm.Type.Record fieldInterfaces Nothing ->
            Result.map
                (\fields -> TypeNotVariable (TypeRecord fields))
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )

        Elm.Type.Record fieldInterfaces (Just extendedRecordVariable) ->
            Result.map
                (\fields ->
                    TypeNotVariable
                        (TypeRecordExtension
                            { fields = fields
                            , recordVariable = extendedRecordVariable
                            }
                        )
                )
                (fieldInterfaces
                    |> listFoldlWhileOkFrom FastDict.empty
                        (\( name, valueInterface ) soFar ->
                            Result.map
                                (\value ->
                                    soFar |> FastDict.insert name value
                                )
                                (valueInterface |> interfaceToType)
                        )
                )


{-| Extract all known types
from declarations within a module.
Un-annotated value/function declarations are ignored.

For dependency modules, use [`moduleInterfaceToTypes`](#moduleInterfaceToTypes)

-}
moduleDeclarationsToTypes :
    ModuleOriginLookup
    -> List Elm.Syntax.Declaration.Declaration
    -> { types : ModuleTypes, errors : List String }
moduleDeclarationsToTypes moduleOriginLookupNotIncludingLocalDeclarations declarations =
    let
        moduleOriginLookup : ModuleOriginLookup
        moduleOriginLookup =
            declarations
                |> List.foldl
                    (\declaration soFar ->
                        case declaration of
                            Elm.Syntax.Declaration.InfixDeclaration _ ->
                                soFar

                            Elm.Syntax.Declaration.Destructuring _ _ ->
                                soFar

                            Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( []
                                                , declarationValueOrFunction.declaration
                                                    |> Elm.Syntax.Node.value
                                                    |> .name
                                                    |> Elm.Syntax.Node.value
                                                )
                                                []
                                }

                            Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationTypeAlias.name |> Elm.Syntax.Node.value )
                                                []
                                }

                            Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                                { soFar
                                    | typeConstructs =
                                        soFar.typeConstructs
                                            |> FastDict.insert
                                                ( [], declarationChoiceType.name |> Elm.Syntax.Node.value )
                                                []
                                    , references =
                                        declarationChoiceType.constructors
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ variant) soFarReferencesIncludingVariantsSoFar ->
                                                    soFarReferencesIncludingVariantsSoFar
                                                        |> FastDict.insert
                                                            ( [], variant.name |> Elm.Syntax.Node.value )
                                                            []
                                                )
                                                soFar.references
                                }

                            Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                                { soFar
                                    | references =
                                        soFar.references
                                            |> FastDict.insert
                                                ( [], declarationPortSignature.name |> Elm.Syntax.Node.value )
                                                []
                                }
                    )
                    moduleOriginLookupNotIncludingLocalDeclarations
    in
    declarations
        |> List.foldl
            (\declaration soFar ->
                case declaration of
                    Elm.Syntax.Declaration.InfixDeclaration _ ->
                        soFar

                    Elm.Syntax.Declaration.Destructuring _ _ ->
                        { errors =
                            "destructuring at the module level is invalid syntax"
                                :: soFar.errors
                        , types = soFar.types
                        }

                    Elm.Syntax.Declaration.FunctionDeclaration declarationValueOrFunction ->
                        case declarationValueOrFunction.signature of
                            Nothing ->
                                soFar

                            Just (Elm.Syntax.Node.Node _ declarationValueOrFunctionSignature) ->
                                case
                                    declarationValueOrFunctionSignature.typeAnnotation
                                        |> Elm.Syntax.Node.value
                                        |> syntaxToType moduleOriginLookup
                                of
                                    Err error ->
                                        { errors = error :: soFar.errors
                                        , types = soFar.types
                                        }

                                    Ok type_ ->
                                        { errors = soFar.errors
                                        , types =
                                            { signatures =
                                                soFar.types.signatures
                                                    |> FastDict.insert
                                                        (declarationValueOrFunctionSignature.name |> Elm.Syntax.Node.value)
                                                        type_
                                            , typeAliases = soFar.types.typeAliases
                                            , choiceTypes = soFar.types.choiceTypes
                                            }
                                        }

                    Elm.Syntax.Declaration.AliasDeclaration declarationTypeAlias ->
                        case
                            declarationTypeAlias.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases =
                                        soFar.types.typeAliases
                                            |> FastDict.insert
                                                (declarationTypeAlias.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationTypeAlias.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , type_ = type_
                                                , recordFieldOrder =
                                                    case declarationTypeAlias.typeAnnotation |> Elm.Syntax.Node.value of
                                                        Elm.Syntax.TypeAnnotation.Record fields ->
                                                            Just
                                                                (fields
                                                                    |> List.map
                                                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                                                            name
                                                                        )
                                                                )

                                                        Elm.Syntax.TypeAnnotation.GenericType _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Unit ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                                                            Nothing

                                                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                                                            Nothing
                                                }
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }

                    Elm.Syntax.Declaration.CustomTypeDeclaration declarationChoiceType ->
                        case
                            declarationChoiceType.constructors
                                |> listFoldlWhileOkFrom
                                    FastDict.empty
                                    (\(Elm.Syntax.Node.Node _ variant) variantsSoFar ->
                                        Result.map
                                            (\variantValues ->
                                                variantsSoFar
                                                    |> FastDict.insert
                                                        (variant.name |> Elm.Syntax.Node.value)
                                                        variantValues
                                            )
                                            (variant.arguments
                                                |> listMapAndCombineOk
                                                    (\(Elm.Syntax.Node.Node _ variantValue) ->
                                                        variantValue |> syntaxToType moduleOriginLookup
                                                    )
                                            )
                                    )
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok variants ->
                                { errors = soFar.errors
                                , types =
                                    { signatures = soFar.types.signatures
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes =
                                        soFar.types.choiceTypes
                                            |> FastDict.insert
                                                (declarationChoiceType.name |> Elm.Syntax.Node.value)
                                                { parameters =
                                                    declarationChoiceType.generics
                                                        |> List.map Elm.Syntax.Node.value
                                                , variants = variants
                                                }
                                    }
                                }

                    Elm.Syntax.Declaration.PortDeclaration declarationPortSignature ->
                        case
                            declarationPortSignature.typeAnnotation
                                |> Elm.Syntax.Node.value
                                |> syntaxToType moduleOriginLookup
                        of
                            Err error ->
                                { errors = error :: soFar.errors
                                , types = soFar.types
                                }

                            Ok type_ ->
                                { errors = soFar.errors
                                , types =
                                    { signatures =
                                        soFar.types.signatures
                                            |> FastDict.insert
                                                (declarationPortSignature.name |> Elm.Syntax.Node.value)
                                                type_
                                    , typeAliases = soFar.types.typeAliases
                                    , choiceTypes = soFar.types.choiceTypes
                                    }
                                }
            )
            { types =
                { signatures = FastDict.empty
                , typeAliases = FastDict.empty
                , choiceTypes = FastDict.empty
                }
            , errors = []
            }


typeVariablesFromContextToDisambiguationLookup :
    FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookup variables =
    typeVariablesFromContextToDisambiguationLookupInto FastDict.empty variables


typeVariablesFromContextToDisambiguationLookupInto :
    FastDict.Dict TypeVariableFromContext String
    -> FastSet.Set TypeVariableFromContext
    -> FastDict.Dict TypeVariableFromContext String
typeVariablesFromContextToDisambiguationLookupInto soFar variables =
    case variables |> FastSet.popMin of
        Nothing ->
            soFar

        Just ( variable, remainingVariables ) ->
            let
                ( _, name ) =
                    variable

                alreadyExists : String -> Bool
                alreadyExists toDisambiguate =
                    soFar
                        |> fastDictAny
                            (\soFarVariableAsString ->
                                soFarVariableAsString == toDisambiguate
                            )

                variableAsDisambiguatedString : String
                variableAsDisambiguatedString =
                    name |> nameDisambiguateBy alreadyExists
            in
            typeVariablesFromContextToDisambiguationLookupInto
                (soFar
                    |> FastDict.insert variable
                        variableAsDisambiguatedString
                )
                remainingVariables


typeVariableFromContextToName : TypeVariableFromContext -> String
typeVariableFromContextToName ( context, name ) =
    (name
        |> String.replace "_" ""
    )
        ++ (context
                |> List.map
                    (\part ->
                        part
                            |> String.replace "_" ""
                            |> stringFirstCharToUpper
                    )
                |> String.concat
           )


nameDisambiguateBy : (String -> Bool) -> String -> String
nameDisambiguateBy alreadyExists currentName =
    nameDisambiguateWithIndexBy 0 alreadyExists currentName


nameDisambiguateWithIndexBy : Int -> (String -> Bool) -> String -> String
nameDisambiguateWithIndexBy index alreadyExists currentName =
    let
        indexedCurrentName : String
        indexedCurrentName =
            case index of
                0 ->
                    currentName

                indexAtLeast1 ->
                    currentName ++ (indexAtLeast1 |> String.fromInt)
    in
    if alreadyExists indexedCurrentName then
        nameDisambiguateWithIndexBy (index + 1) alreadyExists currentName

    else
        indexedCurrentName


fastDictAny : (value -> Bool) -> FastDict.Dict key_ value -> Bool
fastDictAny valueIsFound dict =
    dict
        |> FastDict.restructure False
            (\state ->
                valueIsFound state.value
                    || state.left ()
                    || state.right ()
            )


{-| Like `FastDict.map` but also changing the key
-}
fastDictMapToFastDict :
    (key -> value -> { key : comparableMappedKey, value : mappedValue })
    -> FastDict.Dict key value
    -> FastDict.Dict comparableMappedKey mappedValue
fastDictMapToFastDict toNewEntry fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                let
                    entry : { key : comparableMappedKey, value : mappedValue }
                    entry =
                        toNewEntry key value
                in
                soFar |> FastDict.insert entry.key entry.value
            )
            FastDict.empty


listMapToFastDict :
    (a -> { key : comparableKey, value : value })
    -> List a
    -> FastDict.Dict comparableKey value
listMapToFastDict elementToKeyValue list =
    list
        |> List.foldl
            (\element soFar ->
                let
                    keyValue : { key : comparableKey, value : value }
                    keyValue =
                        element |> elementToKeyValue
                in
                soFar |> FastDict.insert keyValue.key keyValue.value
            )
            FastDict.empty


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


resultAndThen3 :
    (a -> b -> c -> Result error d)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
resultAndThen3 abToResult aResult bResult cResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            abToResult a b c


resultAndThen4 :
    (a -> b -> c -> d -> Result error e)
    -> Result error a
    -> Result error b
    -> Result error c
    -> Result error d
    -> Result error e
resultAndThen4 abToResult aResult bResult cResult dResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    case cResult of
                        Err error ->
                            Err error

                        Ok c ->
                            case dResult of
                                Err error ->
                                    Err error

                                Ok d ->
                                    abToResult a b c d


elmCoreTypesGeneratedFromDocsJson :
    FastDict.Dict
        Elm.Syntax.ModuleName.ModuleName
        ModuleTypes
elmCoreTypesGeneratedFromDocsJson =
    FastDict.fromList
        [ ( [ "Array" ]
          , { signatures =
                FastDict.fromList
                    [ ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Array" ]
                                , name = "Array"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "initialize"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "push"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Array" ]
                                                        , name = "Array"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Array"
                                                                        ]
                                                                    , name =
                                                                        "Array"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toIndexedList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeVariable
                                                                "a"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Array" ]
                                            , name = "Array"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Array"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Basics" ]
          , { signatures =
                FastDict.fromList
                    [ ( "abs"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "acos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "always"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "asin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "atan2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "ceiling"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "clamp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "number"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "number"
                                                        , output =
                                                            TypeVariable
                                                                "number"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "compare"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Order"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cos"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "degrees"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "e"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "floor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "isInfinite"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isNaN"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "logBase"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "max"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "min"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "modBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable "number"
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "never"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Never"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "not"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pi"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Basics" ]
                                , name = "Float"
                                , arguments = []
                                }
                            )
                      )
                    , ( "radians"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remainderBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "round"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sin"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sqrt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "tan"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toPolar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "truncate"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "turns"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bool"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "True", [] ), ( "False", [] ) ]
                        }
                      )
                    , ( "Float"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Int"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Never"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Order"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "LT", [] ), ( "EQ", [] ), ( "GT", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Bitwise" ]
          , { signatures =
                FastDict.fromList
                    [ ( "and"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "complement"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "or"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftLeftBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "shiftRightZfBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "xor"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Char" ]
          , { signatures =
                FastDict.fromList
                    [ ( "fromCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlpha"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isAlphaNum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isHexDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isOctDigit"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toCode"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLocaleUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Char"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Debug" ]
          , { signatures =
                FastDict.fromList
                    [ ( "log"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toString"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "todo"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Dict" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Dict" ]
                                , name = "Dict"
                                , arguments =
                                    [ TypeVariable "k"
                                    , TypeVariable "v"
                                    ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "b"
                                                                    , output =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "k"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "comparable"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "get"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keys"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "k"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "k"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "merge"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "result"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "comparable"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "a"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "comparable"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "b"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Dict"
                                                                                    ]
                                                                                , name =
                                                                                    "Dict"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "comparable"
                                                                                    , TypeVariable
                                                                                        "a"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Dict"
                                                                                                ]
                                                                                            , name =
                                                                                                "Dict"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "comparable"
                                                                                                , TypeVariable
                                                                                                    "b"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "v"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "v"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "k"
                                                        , part1 =
                                                            TypeVariable
                                                                "v"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Dict" ]
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            , TypeVariable
                                                                "v"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "update"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Dict"
                                                                        ]
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        , TypeVariable
                                                                            "v"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "values"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Dict" ]
                                            , name = "Dict"
                                            , arguments =
                                                [ TypeVariable
                                                    "k"
                                                , TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "v"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Dict"
                      , { parameters = [ "k", "v" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "List" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concatMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "drop"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filterMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "head"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexedMap"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersperse"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "List"
                                                                                    ]
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "List"
                                                                                                ]
                                                                                            , name =
                                                                                                "List"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "List"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "List"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maximum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "minimum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "List"
                                                                        ]
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "product"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "range"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sort"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortBy"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "comparable"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sortWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "a"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Order"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sum"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "number"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeVariable "number"
                                }
                            )
                      )
                    , ( "tail"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "take"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unzip"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , part1 =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.singleton
                    "List"
                    { parameters = [ "a" ], variants = FastDict.empty }
            }
          )
        , ( [ "Maybe" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Maybe"
                                                                        ]
                                                                    , name =
                                                                        "Maybe"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Maybe"
                                                                                    ]
                                                                                , name =
                                                                                    "Maybe"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Maybe"
                                                                                                ]
                                                                                            , name =
                                                                                                "Maybe"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Maybe"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Maybe"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Maybe"
                      , { parameters = [ "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Just"
                                  , [ TypeVariable "a" ]
                                  )
                                , ( "Nothing", [] )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform" ]
          , { signatures =
                FastDict.fromList
                    [ ( "sendToApp"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sendToSelf"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Router"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "msg"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeNotVariable
                                                                TypeUnit
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "worker"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeRecord
                                            (FastDict.fromList
                                                [ ( "init"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "flags"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeTuple
                                                                        { part0 =
                                                                            TypeVariable
                                                                                "model"
                                                                        , part1 =
                                                                            TypeNotVariable
                                                                                (TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        [ "Platform"
                                                                                        , "Cmd"
                                                                                        ]
                                                                                    , name =
                                                                                        "Cmd"
                                                                                    , arguments =
                                                                                        [ TypeVariable
                                                                                            "msg"
                                                                                        ]
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "subscriptions"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "model"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeConstruct
                                                                        { moduleOrigin =
                                                                            [ "Platform"
                                                                            , "Sub"
                                                                            ]
                                                                        , name =
                                                                            "Sub"
                                                                        , arguments =
                                                                            [ TypeVariable
                                                                                "msg"
                                                                            ]
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                , ( "update"
                                                  , TypeNotVariable
                                                        (TypeFunction
                                                            { input =
                                                                TypeVariable
                                                                    "msg"
                                                            , output =
                                                                TypeNotVariable
                                                                    (TypeFunction
                                                                        { input =
                                                                            TypeVariable
                                                                                "model"
                                                                        , output =
                                                                            TypeNotVariable
                                                                                (TypeTuple
                                                                                    { part0 =
                                                                                        TypeVariable
                                                                                            "model"
                                                                                    , part1 =
                                                                                        TypeNotVariable
                                                                                            (TypeConstruct
                                                                                                { moduleOrigin =
                                                                                                    [ "Platform"
                                                                                                    , "Cmd"
                                                                                                    ]
                                                                                                , name =
                                                                                                    "Cmd"
                                                                                                , arguments =
                                                                                                    [ TypeVariable
                                                                                                        "msg"
                                                                                                    ]
                                                                                                }
                                                                                            )
                                                                                    }
                                                                                )
                                                                        }
                                                                    )
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Platform" ]
                                            , name = "Program"
                                            , arguments =
                                                [ TypeVariable
                                                    "flags"
                                                , TypeVariable
                                                    "model"
                                                , TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "ProcessId"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Program"
                      , { parameters = [ "flags", "model", "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Router"
                      , { parameters = [ "appMsg", "selfMsg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Task"
                      , { parameters = [ "err", "ok" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Cmd" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Cmd" ]
                                            , name = "Cmd"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Cmd" ]
                                , name = "Cmd"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Cmd"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Platform", "Sub" ]
          , { signatures =
                FastDict.fromList
                    [ ( "batch"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin =
                                                [ "Platform", "Sub" ]
                                            , name = "Sub"
                                            , arguments =
                                                [ TypeVariable
                                                    "msg"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Sub"
                                                            ]
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "none"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Platform", "Sub" ]
                                , name = "Sub"
                                , arguments =
                                    [ TypeVariable "msg" ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Sub"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "Process" ]
          , { signatures =
                FastDict.fromList
                    [ ( "kill"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Process" ]
                                            , name = "Id"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sleep"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    TypeUnit
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "spawn"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "y"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Process" ]
                                                        , name = "Id"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Id"
                      , { parameters = []
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "ProcessId"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Result" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Maybe" ]
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "value"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "value"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "value"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "value"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "value"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "value"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "value"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "value"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "value"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Result"
                                                                        ]
                                                                    , name =
                                                                        "Result"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Result"
                                                                                    ]
                                                                                , name =
                                                                                    "Result"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Result"
                                                                                                ]
                                                                                            , name =
                                                                                                "Result"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Result"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Result"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "value"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMaybe"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Result" ]
                                            , name = "Result"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "withDefault"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "a"
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Result"
                      , { parameters = [ "error", "value" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Ok"
                                  , [ TypeVariable "value" ]
                                  )
                                , ( "Err"
                                  , [ TypeVariable "error" ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( [ "Set" ]
          , { signatures =
                FastDict.fromList
                    [ ( "diff"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "empty"
                      , TypeNotVariable
                            (TypeConstruct
                                { moduleOrigin = [ "Set" ]
                                , name = "Set"
                                , arguments =
                                    [ TypeVariable "a" ]
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "a"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "insert"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "intersect"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeVariable
                                                    "comparable2"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable2"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "member"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "partition"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "comparable"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Set"
                                                                        ]
                                                                    , name =
                                                                        "Set"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "comparable"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "remove"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "singleton"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeVariable
                                        "comparable"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "size"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "union"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Set" ]
                                            , name = "Set"
                                            , arguments =
                                                [ TypeVariable
                                                    "comparable"
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Set" ]
                                                        , name = "Set"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "comparable"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Set"
                      , { parameters = [ "t" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        , ( [ "String" ]
          , { signatures =
                FastDict.fromList
                    [ ( "all"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "any"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "append"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "concat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "contains"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dropRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "endsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "filter"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldl"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "foldr"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromChar"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Char" ]
                                            , name = "Char"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indexes"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "indices"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "isEmpty"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "join"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "left"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lines"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pad"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "padRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "repeat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replace"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "reverse"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "right"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "slice"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Basics" ]
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "startsWith"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toFloat"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toInt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Basics" ]
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toList"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Char" ]
                                                        , name = "Char"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toLower"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toUpper"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trim"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimLeft"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "trimRight"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uncons"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Maybe" ]
                                            , name = "Maybe"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Char"
                                                                        ]
                                                                    , name =
                                                                        "Char"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "String"
                                                                        ]
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "words"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "String" ]
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "String" ]
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "String"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( [ "Task" ]
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attempt"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Result" ]
                                                        , name = "Result"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "x"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "b"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "result"
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "result"
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeVariable
                                                                            "result"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "result"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeVariable
                                                                                        "result"
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "result"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeVariable
                                                                            "c"
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeVariable
                                                                                        "d"
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeVariable
                                                                                                    "e"
                                                                                            , output =
                                                                                                TypeVariable
                                                                                                    "result"
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Task"
                                                                        ]
                                                                    , name =
                                                                        "Task"
                                                                    , arguments =
                                                                        [ TypeVariable
                                                                            "x"
                                                                        , TypeVariable
                                                                            "b"
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeFunction
                                                                    { input =
                                                                        TypeNotVariable
                                                                            (TypeConstruct
                                                                                { moduleOrigin =
                                                                                    [ "Task"
                                                                                    ]
                                                                                , name =
                                                                                    "Task"
                                                                                , arguments =
                                                                                    [ TypeVariable
                                                                                        "x"
                                                                                    , TypeVariable
                                                                                        "c"
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        TypeNotVariable
                                                                            (TypeFunction
                                                                                { input =
                                                                                    TypeNotVariable
                                                                                        (TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                [ "Task"
                                                                                                ]
                                                                                            , name =
                                                                                                "Task"
                                                                                            , arguments =
                                                                                                [ TypeVariable
                                                                                                    "x"
                                                                                                , TypeVariable
                                                                                                    "d"
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    TypeNotVariable
                                                                                        (TypeFunction
                                                                                            { input =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "e"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                TypeNotVariable
                                                                                                    (TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            [ "Task"
                                                                                                            ]
                                                                                                        , name =
                                                                                                            "Task"
                                                                                                        , arguments =
                                                                                                            [ TypeVariable
                                                                                                                "x"
                                                                                                            , TypeVariable
                                                                                                                "result"
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "onError"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "x"
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "y"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "perform"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "msg"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeNotVariable
                                                                (TypeConstruct
                                                                    { moduleOrigin =
                                                                        [ "Basics"
                                                                        ]
                                                                    , name =
                                                                        "Never"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Platform"
                                                            , "Cmd"
                                                            ]
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "msg"
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "List" ]
                                            , name = "List"
                                            , arguments =
                                                [ TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "Task" ]
                                                        , name = "Task"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "x"
                                                            , TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeNotVariable
                                                    (TypeConstruct
                                                        { moduleOrigin =
                                                            [ "List" ]
                                                        , name = "List"
                                                        , arguments =
                                                            [ TypeVariable
                                                                "a"
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeConstruct
                                            { moduleOrigin = [ "Task" ]
                                            , name = "Task"
                                            , arguments =
                                                [ TypeVariable
                                                    "x"
                                                , TypeVariable
                                                    "a"
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Task"
                      , { parameters = [ "x", "a" ]
                        , type_ =
                            TypeNotVariable
                                (TypeConstruct
                                    { moduleOrigin = [ "Platform" ]
                                    , name = "Task"
                                    , arguments =
                                        [ TypeVariable "x"
                                        , TypeVariable "a"
                                        ]
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes = FastDict.fromList []
            }
          )
        , ( [ "Tuple" ]
          , { signatures =
                FastDict.fromList
                    [ ( "first"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "a"
                                }
                            )
                      )
                    , ( "mapBoth"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeVariable
                                                                "b"
                                                        , output =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeFunction
                                                        { input =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "a"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "b"
                                                                    }
                                                                )
                                                        , output =
                                                            TypeNotVariable
                                                                (TypeTuple
                                                                    { part0 =
                                                                        TypeVariable
                                                                            "x"
                                                                    , part1 =
                                                                        TypeVariable
                                                                            "y"
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapFirst"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "a"
                                            , output =
                                                TypeVariable
                                                    "x"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "x"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapSecond"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeVariable
                                                    "y"
                                            }
                                        )
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "y"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "pair"
                      , TypeNotVariable
                            (TypeFunction
                                { input = TypeVariable "a"
                                , output =
                                    TypeNotVariable
                                        (TypeFunction
                                            { input =
                                                TypeVariable
                                                    "b"
                                            , output =
                                                TypeNotVariable
                                                    (TypeTuple
                                                        { part0 =
                                                            TypeVariable
                                                                "a"
                                                        , part1 =
                                                            TypeVariable
                                                                "b"
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "second"
                      , TypeNotVariable
                            (TypeFunction
                                { input =
                                    TypeNotVariable
                                        (TypeTuple
                                            { part0 =
                                                TypeVariable
                                                    "a"
                                            , part1 =
                                                TypeVariable
                                                    "b"
                                            }
                                        )
                                , output = TypeVariable "b"
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes = FastDict.fromList []
            }
          )
        ]
